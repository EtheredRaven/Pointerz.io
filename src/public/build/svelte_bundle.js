
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function _mergeNamespaces(n, m) {
        m.forEach(function (e) {
            e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
                if (k !== 'default' && !(k in n)) {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        });
        return Object.freeze(n);
    }

    function noop() { }
    const identity$1 = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }
    function set_store_value(store, ret, value) {
        store.set(value);
        return ret;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function get_root_for_style(node) {
        if (!node)
            return document;
        const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
        if (root && root.host) {
            return root;
        }
        return node.ownerDocument;
    }
    function append_empty_stylesheet(node) {
        const style_element = element('style');
        append_stylesheet(get_root_for_style(node), style_element);
        return style_element.sheet;
    }
    function append_stylesheet(node, style) {
        append(node.head || node, style);
        return style.sheet;
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function stop_propagation(fn) {
        return function (event) {
            event.stopPropagation();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function set_custom_element_data(node, prop, value) {
        if (prop in node) {
            node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;
        }
        else {
            attr(node, prop, value);
        }
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        if (value === null) {
            node.style.removeProperty(key);
        }
        else {
            node.style.setProperty(key, value, important ? 'important' : '');
        }
    }
    // unfortunately this can't be a constant as that wouldn't be tree-shakeable
    // so we cache the result instead
    let crossorigin;
    function is_crossorigin() {
        if (crossorigin === undefined) {
            crossorigin = false;
            try {
                if (typeof window !== 'undefined' && window.parent) {
                    void window.parent.document;
                }
            }
            catch (error) {
                crossorigin = true;
            }
        }
        return crossorigin;
    }
    function add_resize_listener(node, fn) {
        const computed_style = getComputedStyle(node);
        if (computed_style.position === 'static') {
            node.style.position = 'relative';
        }
        const iframe = element('iframe');
        iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +
            'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
        iframe.setAttribute('aria-hidden', 'true');
        iframe.tabIndex = -1;
        const crossorigin = is_crossorigin();
        let unsubscribe;
        if (crossorigin) {
            iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
            unsubscribe = listen(window, 'message', (event) => {
                if (event.source === iframe.contentWindow)
                    fn();
            });
        }
        else {
            iframe.src = 'about:blank';
            iframe.onload = () => {
                unsubscribe = listen(iframe.contentWindow, 'resize', fn);
            };
        }
        append(node, iframe);
        return () => {
            if (crossorigin) {
                unsubscribe();
            }
            else if (unsubscribe && iframe.contentWindow) {
                unsubscribe();
            }
            detach(iframe);
        };
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, cancelable, detail);
        return e;
    }
    class HtmlTag {
        constructor(is_svg = false) {
            this.is_svg = false;
            this.is_svg = is_svg;
            this.e = this.n = null;
        }
        c(html) {
            this.h(html);
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                if (this.is_svg)
                    this.e = svg_element(target.nodeName);
                else
                    this.e = element(target.nodeName);
                this.t = target;
                this.c(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    // we need to store the information for multiple documents because a Svelte application could also contain iframes
    // https://github.com/sveltejs/svelte/issues/3624
    const managed_styles = new Map();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_style_information(doc, node) {
        const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
        managed_styles.set(doc, info);
        return info;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = get_root_for_style(node);
        const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
        if (!rules[name]) {
            rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            managed_styles.forEach(info => {
                const { ownerNode } = info.stylesheet;
                // there is no ownerNode if it runs on jsdom.
                if (ownerNode)
                    detach(ownerNode);
            });
            managed_styles.clear();
        });
    }

    function create_animation(node, from, fn, params) {
        if (!from)
            return noop;
        const to = node.getBoundingClientRect();
        if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
            return noop;
        const { delay = 0, duration = 300, easing = identity$1, 
        // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
        start: start_time = now() + delay, 
        // @ts-ignore todo:
        end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);
        let running = true;
        let started = false;
        let name;
        function start() {
            if (css) {
                name = create_rule(node, 0, 1, duration, delay, easing, css);
            }
            if (!delay) {
                started = true;
            }
        }
        function stop() {
            if (css)
                delete_rule(node, name);
            running = false;
        }
        loop(now => {
            if (!started && now >= start_time) {
                started = true;
            }
            if (started && now >= end) {
                tick(1, 0);
                stop();
            }
            if (!running) {
                return false;
            }
            if (started) {
                const p = now - start_time;
                const t = 0 + 1 * easing(p / duration);
                tick(t, 1 - t);
            }
            return true;
        });
        start();
        tick(0, 1);
        return stop;
    }
    function fix_position(node) {
        const style = getComputedStyle(node);
        if (style.position !== 'absolute' && style.position !== 'fixed') {
            const { width, height } = style;
            const a = node.getBoundingClientRect();
            node.style.position = 'absolute';
            node.style.width = width;
            node.style.height = height;
            add_transform(node, a);
        }
    }
    function add_transform(node, a) {
        const b = node.getBoundingClientRect();
        if (a.left !== b.left || a.top !== b.top) {
            const style = getComputedStyle(node);
            const transform = style.transform === 'none' ? '' : style.transform;
            node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
        }
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function beforeUpdate(fn) {
        get_current_component().$$.before_update.push(fn);
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail, { cancelable = false } = {}) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail, { cancelable });
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
                return !event.defaultPrevented;
            }
            return true;
        };
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            // @ts-ignore
            callbacks.slice().forEach(fn => fn.call(this, event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            while (flushidx < dirty_components.length) {
                const component = dirty_components[flushidx];
                flushidx++;
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
        else if (callback) {
            callback();
        }
    }
    const null_transition = { duration: 0 };
    function create_in_transition(node, fn, params) {
        let config = fn(node, params);
        let running = false;
        let animation_name;
        let task;
        let uid = 0;
        function cleanup() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function go() {
            const { delay = 0, duration = 300, easing = identity$1, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
            tick(0, 1);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            if (task)
                task.abort();
            running = true;
            add_render_callback(() => dispatch(node, true, 'start'));
            task = loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(1, 0);
                        dispatch(node, true, 'end');
                        cleanup();
                        return running = false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(t, 1 - t);
                    }
                }
                return running;
            });
        }
        let started = false;
        return {
            start() {
                if (started)
                    return;
                started = true;
                delete_rule(node);
                if (is_function(config)) {
                    config = config();
                    wait().then(go);
                }
                else {
                    go();
                }
            },
            invalidate() {
                started = false;
            },
            end() {
                if (running) {
                    cleanup();
                    running = false;
                }
            }
        };
    }
    function create_out_transition(node, fn, params) {
        let config = fn(node, params);
        let running = true;
        let animation_name;
        const group = outros;
        group.r += 1;
        function go() {
            const { delay = 0, duration = 300, easing = identity$1, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            add_render_callback(() => dispatch(node, false, 'start'));
            loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(0, 1);
                        dispatch(node, false, 'end');
                        if (!--group.r) {
                            // this will result in `end()` being called,
                            // so we don't need to clean up here
                            run_all(group.c);
                        }
                        return false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(1 - t, t);
                    }
                }
                return running;
            });
        }
        if (is_function(config)) {
            wait().then(() => {
                // @ts-ignore
                config = config();
                go();
            });
        }
        else {
            go();
        }
        return {
            end(reset) {
                if (reset && config.tick) {
                    config.tick(1, 0);
                }
                if (running) {
                    if (animation_name)
                        delete_rule(node, animation_name);
                    running = false;
                }
            }
        };
    }
    function create_bidirectional_transition(node, fn, params, intro) {
        let config = fn(node, params);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = (program.b - t);
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity$1, tick = noop, css } = config || null_transition;
            const program = {
                start: now() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program || pending_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config();
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);
    function outro_and_destroy_block(block, lookup) {
        transition_out(block, 1, 1, () => {
            lookup.delete(block.key);
        });
    }
    function fix_and_outro_and_destroy_block(block, lookup) {
        block.f();
        outro_and_destroy_block(block, lookup);
    }
    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--)
            old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        i = n;
        while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
                block = create_each_block(key, child_ctx);
                block.c();
            }
            else if (dynamic) {
                block.p(child_ctx, dirty);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
                deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
            transition_in(block, 1);
            block.m(node, next);
            lookup.set(block.key, block);
            next = block.first;
            n--;
        }
        while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
                // do nothing
                next = new_block.first;
                o--;
                n--;
            }
            else if (!new_lookup.has(old_key)) {
                // remove old block
                destroy(old_block, lookup);
                o--;
            }
            else if (!lookup.has(new_key) || will_move.has(new_key)) {
                insert(new_block);
            }
            else if (did_move.has(old_key)) {
                o--;
            }
            else if (deltas.get(new_key) > deltas.get(old_key)) {
                did_move.add(new_key);
                insert(new_block);
            }
            else {
                will_move.add(old_key);
                o--;
            }
        }
        while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
                destroy(old_block, lookup);
        }
        while (n)
            insert(new_blocks[n - 1]);
        return new_blocks;
    }
    function validate_each_keys(ctx, list, get_context, get_key) {
        const keys = new Set();
        for (let i = 0; i < list.length; i++) {
            const key = get_key(get_context(ctx, list, i));
            if (keys.has(key)) {
                throw new Error('Cannot have duplicate keys in a keyed each');
            }
            keys.add(key);
        }
    }

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.50.1' }, detail), { bubbles: true }));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    /**
     * @typedef {Object} WrappedComponent Object returned by the `wrap` method
     * @property {SvelteComponent} component - Component to load (this is always asynchronous)
     * @property {RoutePrecondition[]} [conditions] - Route pre-conditions to validate
     * @property {Object} [props] - Optional dictionary of static props
     * @property {Object} [userData] - Optional user data dictionary
     * @property {bool} _sveltesparouter - Internal flag; always set to true
     */

    /**
     * @callback AsyncSvelteComponent
     * @returns {Promise<SvelteComponent>} Returns a Promise that resolves with a Svelte component
     */

    /**
     * @callback RoutePrecondition
     * @param {RouteDetail} detail - Route detail object
     * @returns {boolean|Promise<boolean>} If the callback returns a false-y value, it's interpreted as the precondition failed, so it aborts loading the component (and won't process other pre-condition callbacks)
     */

    /**
     * @typedef {Object} WrapOptions Options object for the call to `wrap`
     * @property {SvelteComponent} [component] - Svelte component to load (this is incompatible with `asyncComponent`)
     * @property {AsyncSvelteComponent} [asyncComponent] - Function that returns a Promise that fulfills with a Svelte component (e.g. `{asyncComponent: () => import('Foo.svelte')}`)
     * @property {SvelteComponent} [loadingComponent] - Svelte component to be displayed while the async route is loading (as a placeholder); when unset or false-y, no component is shown while component
     * @property {object} [loadingParams] - Optional dictionary passed to the `loadingComponent` component as params (for an exported prop called `params`)
     * @property {object} [userData] - Optional object that will be passed to events such as `routeLoading`, `routeLoaded`, `conditionsFailed`
     * @property {object} [props] - Optional key-value dictionary of static props that will be passed to the component. The props are expanded with {...props}, so the key in the dictionary becomes the name of the prop.
     * @property {RoutePrecondition[]|RoutePrecondition} [conditions] - Route pre-conditions to add, which will be executed in order
     */

    /**
     * Wraps a component to enable multiple capabilities:
     * 1. Using dynamically-imported component, with (e.g. `{asyncComponent: () => import('Foo.svelte')}`), which also allows bundlers to do code-splitting.
     * 2. Adding route pre-conditions (e.g. `{conditions: [...]}`)
     * 3. Adding static props that are passed to the component
     * 4. Adding custom userData, which is passed to route events (e.g. route loaded events) or to route pre-conditions (e.g. `{userData: {foo: 'bar}}`)
     * 
     * @param {WrapOptions} args - Arguments object
     * @returns {WrappedComponent} Wrapped component
     */
    function wrap$1(args) {
        if (!args) {
            throw Error('Parameter args is required')
        }

        // We need to have one and only one of component and asyncComponent
        // This does a "XNOR"
        if (!args.component == !args.asyncComponent) {
            throw Error('One and only one of component and asyncComponent is required')
        }

        // If the component is not async, wrap it into a function returning a Promise
        if (args.component) {
            args.asyncComponent = () => Promise.resolve(args.component);
        }

        // Parameter asyncComponent and each item of conditions must be functions
        if (typeof args.asyncComponent != 'function') {
            throw Error('Parameter asyncComponent must be a function')
        }
        if (args.conditions) {
            // Ensure it's an array
            if (!Array.isArray(args.conditions)) {
                args.conditions = [args.conditions];
            }
            for (let i = 0; i < args.conditions.length; i++) {
                if (!args.conditions[i] || typeof args.conditions[i] != 'function') {
                    throw Error('Invalid parameter conditions[' + i + ']')
                }
            }
        }

        // Check if we have a placeholder component
        if (args.loadingComponent) {
            args.asyncComponent.loading = args.loadingComponent;
            args.asyncComponent.loadingParams = args.loadingParams || undefined;
        }

        // Returns an object that contains all the functions to execute too
        // The _sveltesparouter flag is to confirm the object was created by this router
        const obj = {
            component: args.asyncComponent,
            userData: args.userData,
            conditions: (args.conditions && args.conditions.length) ? args.conditions : undefined,
            props: (args.props && Object.keys(args.props).length) ? args.props : {},
            _sveltesparouter: true
        };

        return obj
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    function parse(str, loose) {
    	if (str instanceof RegExp) return { keys:false, pattern:str };
    	var c, o, tmp, ext, keys=[], pattern='', arr = str.split('/');
    	arr[0] || arr.shift();

    	while (tmp = arr.shift()) {
    		c = tmp[0];
    		if (c === '*') {
    			keys.push('wild');
    			pattern += '/(.*)';
    		} else if (c === ':') {
    			o = tmp.indexOf('?', 1);
    			ext = tmp.indexOf('.', 1);
    			keys.push( tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length) );
    			pattern += !!~o && !~ext ? '(?:/([^/]+?))?' : '/([^/]+?)';
    			if (!!~ext) pattern += (!!~o ? '?' : '') + '\\' + tmp.substring(ext);
    		} else {
    			pattern += '/' + tmp;
    		}
    	}

    	return {
    		keys: keys,
    		pattern: new RegExp('^' + pattern + (loose ? '(?=$|\/)' : '\/?$'), 'i')
    	};
    }

    /* node_modules\svelte-spa-router\Router.svelte generated by Svelte v3.50.1 */

    const { Error: Error_1, Object: Object_1$2, console: console_1$2 } = globals;

    // (267:0) {:else}
    function create_else_block$9(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*props*/ 4)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*props*/ ctx[2])])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(267:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (260:0) {#if componentParams}
    function create_if_block$u(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [{ params: /*componentParams*/ ctx[1] }, /*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*componentParams, props*/ 6)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*componentParams*/ 2 && { params: /*componentParams*/ ctx[1] },
    					dirty & /*props*/ 4 && get_spread_object(/*props*/ ctx[2])
    				])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$u.name,
    		type: "if",
    		source: "(260:0) {#if componentParams}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$L(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$u, create_else_block$9];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*componentParams*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function wrap(component, userData, ...conditions) {
    	// Use the new wrap method and show a deprecation warning
    	// eslint-disable-next-line no-console
    	console.warn('Method `wrap` from `svelte-spa-router` is deprecated and will be removed in a future version. Please use `svelte-spa-router/wrap` instead. See http://bit.ly/svelte-spa-router-upgrading');

    	return wrap$1({ component, userData, conditions });
    }

    /**
     * @typedef {Object} Location
     * @property {string} location - Location (page/view), for example `/book`
     * @property {string} [querystring] - Querystring from the hash, as a string not parsed
     */
    /**
     * Returns the current location from the hash.
     *
     * @returns {Location} Location object
     * @private
     */
    function getLocation() {
    	const hashPosition = window.location.href.indexOf('#/');

    	let location = hashPosition > -1
    	? window.location.href.substr(hashPosition + 1)
    	: '/';

    	// Check if there's a querystring
    	const qsPosition = location.indexOf('?');

    	let querystring = '';

    	if (qsPosition > -1) {
    		querystring = location.substr(qsPosition + 1);
    		location = location.substr(0, qsPosition);
    	}

    	return { location, querystring };
    }

    const loc = readable(null, // eslint-disable-next-line prefer-arrow-callback
    function start(set) {
    	set(getLocation());

    	const update = () => {
    		set(getLocation());
    	};

    	window.addEventListener('hashchange', update, false);

    	return function stop() {
    		window.removeEventListener('hashchange', update, false);
    	};
    });

    const location$1 = derived(loc, $loc => $loc.location);
    const querystring = derived(loc, $loc => $loc.querystring);
    const params = writable(undefined);

    async function push(location) {
    	if (!location || location.length < 1 || location.charAt(0) != '/' && location.indexOf('#/') !== 0) {
    		throw Error('Invalid parameter location');
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	// Note: this will include scroll state in history even when restoreScrollState is false
    	history.replaceState(
    		{
    			...history.state,
    			__svelte_spa_router_scrollX: window.scrollX,
    			__svelte_spa_router_scrollY: window.scrollY
    		},
    		undefined
    	);

    	window.location.hash = (location.charAt(0) == '#' ? '' : '#') + location;
    }

    async function pop() {
    	// Execute this code when the current call stack is complete
    	await tick();

    	window.history.back();
    }

    async function replace(location) {
    	if (!location || location.length < 1 || location.charAt(0) != '/' && location.indexOf('#/') !== 0) {
    		throw Error('Invalid parameter location');
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	const dest = (location.charAt(0) == '#' ? '' : '#') + location;

    	try {
    		const newState = { ...history.state };
    		delete newState['__svelte_spa_router_scrollX'];
    		delete newState['__svelte_spa_router_scrollY'];
    		window.history.replaceState(newState, undefined, dest);
    	} catch(e) {
    		// eslint-disable-next-line no-console
    		console.warn('Caught exception while replacing the current page. If you\'re running this in the Svelte REPL, please note that the `replace` method might not work in this environment.');
    	}

    	// The method above doesn't trigger the hashchange event, so let's do that manually
    	window.dispatchEvent(new Event('hashchange'));
    }

    function link(node, opts) {
    	opts = linkOpts(opts);

    	// Only apply to <a> tags
    	if (!node || !node.tagName || node.tagName.toLowerCase() != 'a') {
    		throw Error('Action "link" can only be used with <a> tags');
    	}

    	updateLink(node, opts);

    	return {
    		update(updated) {
    			updated = linkOpts(updated);
    			updateLink(node, updated);
    		}
    	};
    }

    function restoreScroll(state) {
    	// If this exists, then this is a back navigation: restore the scroll position
    	if (state) {
    		window.scrollTo(state.__svelte_spa_router_scrollX, state.__svelte_spa_router_scrollY);
    	} else {
    		// Otherwise this is a forward navigation: scroll to top
    		window.scrollTo(0, 0);
    	}
    }

    // Internal function used by the link function
    function updateLink(node, opts) {
    	let href = opts.href || node.getAttribute('href');

    	// Destination must start with '/' or '#/'
    	if (href && href.charAt(0) == '/') {
    		// Add # to the href attribute
    		href = '#' + href;
    	} else if (!href || href.length < 2 || href.slice(0, 2) != '#/') {
    		throw Error('Invalid value for "href" attribute: ' + href);
    	}

    	node.setAttribute('href', href);

    	node.addEventListener('click', event => {
    		// Prevent default anchor onclick behaviour
    		event.preventDefault();

    		if (!opts.disabled) {
    			scrollstateHistoryHandler(event.currentTarget.getAttribute('href'));
    		}
    	});
    }

    // Internal function that ensures the argument of the link action is always an object
    function linkOpts(val) {
    	if (val && typeof val == 'string') {
    		return { href: val };
    	} else {
    		return val || {};
    	}
    }

    /**
     * The handler attached to an anchor tag responsible for updating the
     * current history state with the current scroll state
     *
     * @param {string} href - Destination
     */
    function scrollstateHistoryHandler(href) {
    	// Setting the url (3rd arg) to href will break clicking for reasons, so don't try to do that
    	history.replaceState(
    		{
    			...history.state,
    			__svelte_spa_router_scrollX: window.scrollX,
    			__svelte_spa_router_scrollY: window.scrollY
    		},
    		undefined
    	);

    	// This will force an update as desired, but this time our scroll state will be attached
    	window.location.hash = href;
    }

    function instance$L($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Router', slots, []);
    	let { routes = {} } = $$props;
    	let { prefix = '' } = $$props;
    	let { restoreScrollState = false } = $$props;

    	/**
     * Container for a route: path, component
     */
    	class RouteItem {
    		/**
     * Initializes the object and creates a regular expression from the path, using regexparam.
     *
     * @param {string} path - Path to the route (must start with '/' or '*')
     * @param {SvelteComponent|WrappedComponent} component - Svelte component for the route, optionally wrapped
     */
    		constructor(path, component) {
    			if (!component || typeof component != 'function' && (typeof component != 'object' || component._sveltesparouter !== true)) {
    				throw Error('Invalid component object');
    			}

    			// Path must be a regular or expression, or a string starting with '/' or '*'
    			if (!path || typeof path == 'string' && (path.length < 1 || path.charAt(0) != '/' && path.charAt(0) != '*') || typeof path == 'object' && !(path instanceof RegExp)) {
    				throw Error('Invalid value for "path" argument - strings must start with / or *');
    			}

    			const { pattern, keys } = parse(path);
    			this.path = path;

    			// Check if the component is wrapped and we have conditions
    			if (typeof component == 'object' && component._sveltesparouter === true) {
    				this.component = component.component;
    				this.conditions = component.conditions || [];
    				this.userData = component.userData;
    				this.props = component.props || {};
    			} else {
    				// Convert the component to a function that returns a Promise, to normalize it
    				this.component = () => Promise.resolve(component);

    				this.conditions = [];
    				this.props = {};
    			}

    			this._pattern = pattern;
    			this._keys = keys;
    		}

    		/**
     * Checks if `path` matches the current route.
     * If there's a match, will return the list of parameters from the URL (if any).
     * In case of no match, the method will return `null`.
     *
     * @param {string} path - Path to test
     * @returns {null|Object.<string, string>} List of paramters from the URL if there's a match, or `null` otherwise.
     */
    		match(path) {
    			// If there's a prefix, check if it matches the start of the path.
    			// If not, bail early, else remove it before we run the matching.
    			if (prefix) {
    				if (typeof prefix == 'string') {
    					if (path.startsWith(prefix)) {
    						path = path.substr(prefix.length) || '/';
    					} else {
    						return null;
    					}
    				} else if (prefix instanceof RegExp) {
    					const match = path.match(prefix);

    					if (match && match[0]) {
    						path = path.substr(match[0].length) || '/';
    					} else {
    						return null;
    					}
    				}
    			}

    			// Check if the pattern matches
    			const matches = this._pattern.exec(path);

    			if (matches === null) {
    				return null;
    			}

    			// If the input was a regular expression, this._keys would be false, so return matches as is
    			if (this._keys === false) {
    				return matches;
    			}

    			const out = {};
    			let i = 0;

    			while (i < this._keys.length) {
    				// In the match parameters, URL-decode all values
    				try {
    					out[this._keys[i]] = decodeURIComponent(matches[i + 1] || '') || null;
    				} catch(e) {
    					out[this._keys[i]] = null;
    				}

    				i++;
    			}

    			return out;
    		}

    		/**
     * Dictionary with route details passed to the pre-conditions functions, as well as the `routeLoading`, `routeLoaded` and `conditionsFailed` events
     * @typedef {Object} RouteDetail
     * @property {string|RegExp} route - Route matched as defined in the route definition (could be a string or a reguar expression object)
     * @property {string} location - Location path
     * @property {string} querystring - Querystring from the hash
     * @property {object} [userData] - Custom data passed by the user
     * @property {SvelteComponent} [component] - Svelte component (only in `routeLoaded` events)
     * @property {string} [name] - Name of the Svelte component (only in `routeLoaded` events)
     */
    		/**
     * Executes all conditions (if any) to control whether the route can be shown. Conditions are executed in the order they are defined, and if a condition fails, the following ones aren't executed.
     * 
     * @param {RouteDetail} detail - Route detail
     * @returns {boolean} Returns true if all the conditions succeeded
     */
    		async checkConditions(detail) {
    			for (let i = 0; i < this.conditions.length; i++) {
    				if (!await this.conditions[i](detail)) {
    					return false;
    				}
    			}

    			return true;
    		}
    	}

    	// Set up all routes
    	const routesList = [];

    	if (routes instanceof Map) {
    		// If it's a map, iterate on it right away
    		routes.forEach((route, path) => {
    			routesList.push(new RouteItem(path, route));
    		});
    	} else {
    		// We have an object, so iterate on its own properties
    		Object.keys(routes).forEach(path => {
    			routesList.push(new RouteItem(path, routes[path]));
    		});
    	}

    	// Props for the component to render
    	let component = null;

    	let componentParams = null;
    	let props = {};

    	// Event dispatcher from Svelte
    	const dispatch = createEventDispatcher();

    	// Just like dispatch, but executes on the next iteration of the event loop
    	async function dispatchNextTick(name, detail) {
    		// Execute this code when the current call stack is complete
    		await tick();

    		dispatch(name, detail);
    	}

    	// If this is set, then that means we have popped into this var the state of our last scroll position
    	let previousScrollState = null;

    	let popStateChanged = null;

    	if (restoreScrollState) {
    		popStateChanged = event => {
    			// If this event was from our history.replaceState, event.state will contain
    			// our scroll history. Otherwise, event.state will be null (like on forward
    			// navigation)
    			if (event.state && (event.state.__svelte_spa_router_scrollY || event.state.__svelte_spa_router_scrollX)) {
    				previousScrollState = event.state;
    			} else {
    				previousScrollState = null;
    			}
    		};

    		// This is removed in the destroy() invocation below
    		window.addEventListener('popstate', popStateChanged);

    		afterUpdate(() => {
    			restoreScroll(previousScrollState);
    		});
    	}

    	// Always have the latest value of loc
    	let lastLoc = null;

    	// Current object of the component loaded
    	let componentObj = null;

    	// Handle hash change events
    	// Listen to changes in the $loc store and update the page
    	// Do not use the $: syntax because it gets triggered by too many things
    	const unsubscribeLoc = loc.subscribe(async newLoc => {
    		lastLoc = newLoc;

    		// Find a route matching the location
    		let i = 0;

    		while (i < routesList.length) {
    			const match = routesList[i].match(newLoc.location);

    			if (!match) {
    				i++;
    				continue;
    			}

    			const detail = {
    				route: routesList[i].path,
    				location: newLoc.location,
    				querystring: newLoc.querystring,
    				userData: routesList[i].userData,
    				params: match && typeof match == 'object' && Object.keys(match).length
    				? match
    				: null
    			};

    			// Check if the route can be loaded - if all conditions succeed
    			if (!await routesList[i].checkConditions(detail)) {
    				// Don't display anything
    				$$invalidate(0, component = null);

    				componentObj = null;

    				// Trigger an event to notify the user, then exit
    				dispatchNextTick('conditionsFailed', detail);

    				return;
    			}

    			// Trigger an event to alert that we're loading the route
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick('routeLoading', Object.assign({}, detail));

    			// If there's a component to show while we're loading the route, display it
    			const obj = routesList[i].component;

    			// Do not replace the component if we're loading the same one as before, to avoid the route being unmounted and re-mounted
    			if (componentObj != obj) {
    				if (obj.loading) {
    					$$invalidate(0, component = obj.loading);
    					componentObj = obj;
    					$$invalidate(1, componentParams = obj.loadingParams);
    					$$invalidate(2, props = {});

    					// Trigger the routeLoaded event for the loading component
    					// Create a copy of detail so we don't modify the object for the dynamic route (and the dynamic route doesn't modify our object too)
    					dispatchNextTick('routeLoaded', Object.assign({}, detail, {
    						component,
    						name: component.name,
    						params: componentParams
    					}));
    				} else {
    					$$invalidate(0, component = null);
    					componentObj = null;
    				}

    				// Invoke the Promise
    				const loaded = await obj();

    				// Now that we're here, after the promise resolved, check if we still want this component, as the user might have navigated to another page in the meanwhile
    				if (newLoc != lastLoc) {
    					// Don't update the component, just exit
    					return;
    				}

    				// If there is a "default" property, which is used by async routes, then pick that
    				$$invalidate(0, component = loaded && loaded.default || loaded);

    				componentObj = obj;
    			}

    			// Set componentParams only if we have a match, to avoid a warning similar to `<Component> was created with unknown prop 'params'`
    			// Of course, this assumes that developers always add a "params" prop when they are expecting parameters
    			if (match && typeof match == 'object' && Object.keys(match).length) {
    				$$invalidate(1, componentParams = match);
    			} else {
    				$$invalidate(1, componentParams = null);
    			}

    			// Set static props, if any
    			$$invalidate(2, props = routesList[i].props);

    			// Dispatch the routeLoaded event then exit
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick('routeLoaded', Object.assign({}, detail, {
    				component,
    				name: component.name,
    				params: componentParams
    			})).then(() => {
    				params.set(componentParams);
    			});

    			return;
    		}

    		// If we're still here, there was no match, so show the empty component
    		$$invalidate(0, component = null);

    		componentObj = null;
    		params.set(undefined);
    	});

    	onDestroy(() => {
    		unsubscribeLoc();
    		popStateChanged && window.removeEventListener('popstate', popStateChanged);
    	});

    	const writable_props = ['routes', 'prefix', 'restoreScrollState'];

    	Object_1$2.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$2.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	function routeEvent_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function routeEvent_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('routes' in $$props) $$invalidate(3, routes = $$props.routes);
    		if ('prefix' in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ('restoreScrollState' in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    	};

    	$$self.$capture_state = () => ({
    		readable,
    		writable,
    		derived,
    		tick,
    		_wrap: wrap$1,
    		wrap,
    		getLocation,
    		loc,
    		location: location$1,
    		querystring,
    		params,
    		push,
    		pop,
    		replace,
    		link,
    		restoreScroll,
    		updateLink,
    		linkOpts,
    		scrollstateHistoryHandler,
    		onDestroy,
    		createEventDispatcher,
    		afterUpdate,
    		parse,
    		routes,
    		prefix,
    		restoreScrollState,
    		RouteItem,
    		routesList,
    		component,
    		componentParams,
    		props,
    		dispatch,
    		dispatchNextTick,
    		previousScrollState,
    		popStateChanged,
    		lastLoc,
    		componentObj,
    		unsubscribeLoc
    	});

    	$$self.$inject_state = $$props => {
    		if ('routes' in $$props) $$invalidate(3, routes = $$props.routes);
    		if ('prefix' in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ('restoreScrollState' in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    		if ('component' in $$props) $$invalidate(0, component = $$props.component);
    		if ('componentParams' in $$props) $$invalidate(1, componentParams = $$props.componentParams);
    		if ('props' in $$props) $$invalidate(2, props = $$props.props);
    		if ('previousScrollState' in $$props) previousScrollState = $$props.previousScrollState;
    		if ('popStateChanged' in $$props) popStateChanged = $$props.popStateChanged;
    		if ('lastLoc' in $$props) lastLoc = $$props.lastLoc;
    		if ('componentObj' in $$props) componentObj = $$props.componentObj;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*restoreScrollState*/ 32) {
    			// Update history.scrollRestoration depending on restoreScrollState
    			history.scrollRestoration = restoreScrollState ? 'manual' : 'auto';
    		}
    	};

    	return [
    		component,
    		componentParams,
    		props,
    		routes,
    		prefix,
    		restoreScrollState,
    		routeEvent_handler,
    		routeEvent_handler_1
    	];
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$L, create_fragment$L, safe_not_equal, {
    			routes: 3,
    			prefix: 4,
    			restoreScrollState: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router",
    			options,
    			id: create_fragment$L.name
    		});
    	}

    	get routes() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set routes(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get prefix() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set prefix(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get restoreScrollState() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set restoreScrollState(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function cubicOut(t) {
        const f = t - 1.0;
        return f * f * f + 1.0;
    }
    function sineInOut(t) {
        return -0.5 * (Math.cos(Math.PI * t) - 1);
    }

    function fade(node, { delay = 0, duration = 400, easing = identity$1 } = {}) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }
    function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 } = {}) {
        const style = getComputedStyle(node);
        const target_opacity = +style.opacity;
        const transform = style.transform === 'none' ? '' : style.transform;
        const od = target_opacity * (1 - opacity);
        return {
            delay,
            duration,
            easing,
            css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
        };
    }
    function slide(node, { delay = 0, duration = 400, easing = cubicOut } = {}) {
        const style = getComputedStyle(node);
        const opacity = +style.opacity;
        const height = parseFloat(style.height);
        const padding_top = parseFloat(style.paddingTop);
        const padding_bottom = parseFloat(style.paddingBottom);
        const margin_top = parseFloat(style.marginTop);
        const margin_bottom = parseFloat(style.marginBottom);
        const border_top_width = parseFloat(style.borderTopWidth);
        const border_bottom_width = parseFloat(style.borderBottomWidth);
        return {
            delay,
            duration,
            easing,
            css: t => 'overflow: hidden;' +
                `opacity: ${Math.min(t * 20, 1) * opacity};` +
                `height: ${t * height}px;` +
                `padding-top: ${t * padding_top}px;` +
                `padding-bottom: ${t * padding_bottom}px;` +
                `margin-top: ${t * margin_top}px;` +
                `margin-bottom: ${t * margin_bottom}px;` +
                `border-top-width: ${t * border_top_width}px;` +
                `border-bottom-width: ${t * border_bottom_width}px;`
        };
    }
    function scale(node, { delay = 0, duration = 400, easing = cubicOut, start = 0, opacity = 0 } = {}) {
        const style = getComputedStyle(node);
        const target_opacity = +style.opacity;
        const transform = style.transform === 'none' ? '' : style.transform;
        const sd = 1 - start;
        const od = target_opacity * (1 - opacity);
        return {
            delay,
            duration,
            easing,
            css: (_t, u) => `
			transform: ${transform} scale(${1 - (sd * u)});
			opacity: ${target_opacity - (od * u)}
		`
        };
    }

    var Client$1 = window.Client;
    var infoError = writable(false);
    var infoInfo = writable(false);

    var loadedCircuits = writable([]);
    var loadedEditorCircuits = writable([]);
    var loadedVoteCircuits = writable([]);
    var userModel = writable(null);
    var loggedIn = writable(false);

    var editorSelectedBlock = writable(null);

    const playerNameMaxChar = 19;
    var playerMail = writable("");
    var playerPassword = writable("");
    let storedName = localStorage.getItem("pointerz_username");
    var playerName = writable(storedName ? storedName : "");

    var passedData = writable({});

    var editorMenuLastClick = writable({ name: "" });

    const css = {
      uiContainer: {
        minMargin: 0,
        maxMargin: 16,
      },
      publicMenu: {
        minWidth: 308,
        maxWidth: 360,
      },
      endRace: {
        blockWidth: 280,
      },
      default: {
        margin: 8,
        blockWidth: 280,
      },
    };

    /* src\client\svelte\components\ui\TextBlock.svelte generated by Svelte v3.50.1 */
    const file$I = "src\\client\\svelte\\components\\ui\\TextBlock.svelte";

    function create_fragment$K(ctx) {
    	let div;
    	let div_class_value;
    	let div_style_value;
    	let div_transition;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", div_class_value = "textBlock " + /*color*/ ctx[0] + " " + (/*clickable*/ ctx[1] ? 'clickable' : '') + " " + (/*small*/ ctx[4] ? 'smallPadding' : '') + " " + (/*noMargins*/ ctx[5] ? 'noMargins' : '') + " svelte-1iskqpo");
    			attr_dev(div, "style", div_style_value = "" + /*style*/ ctx[3] + " width: " + ('calc(' + 100 / /*elementsPerRow*/ ctx[6] + '% - ' + css.default.margin * (/*elementsPerRow*/ ctx[6] - 1) / /*elementsPerRow*/ ctx[6] + 'px)') + "; margin-right: " + (/*lastElementOfRow*/ ctx[7] ? 0 : css.default.margin) + "px; margin-bottom: " + ((/*lastRow*/ ctx[8] ? 0 : css.default.margin) + 4) + "px;");
    			add_location(div, file$I, 20, 0, 599);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*click_handler*/ ctx[13], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[11],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*color, clickable, small, noMargins*/ 51 && div_class_value !== (div_class_value = "textBlock " + /*color*/ ctx[0] + " " + (/*clickable*/ ctx[1] ? 'clickable' : '') + " " + (/*small*/ ctx[4] ? 'smallPadding' : '') + " " + (/*noMargins*/ ctx[5] ? 'noMargins' : '') + " svelte-1iskqpo")) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (!current || dirty & /*style, elementsPerRow, lastElementOfRow, lastRow*/ 456 && div_style_value !== (div_style_value = "" + /*style*/ ctx[3] + " width: " + ('calc(' + 100 / /*elementsPerRow*/ ctx[6] + '% - ' + css.default.margin * (/*elementsPerRow*/ ctx[6] - 1) / /*elementsPerRow*/ ctx[6] + 'px)') + "; margin-right: " + (/*lastElementOfRow*/ ctx[7] ? 0 : css.default.margin) + "px; margin-bottom: " + ((/*lastRow*/ ctx[8] ? 0 : css.default.margin) + 4) + "px;")) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, /*slideTransition*/ ctx[2], true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			if (!div_transition) div_transition = create_bidirectional_transition(div, slide, /*slideTransition*/ ctx[2], false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			if (detaching && div_transition) div_transition.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$K($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TextBlock', slots, ['default']);
    	let { color = "grey" } = $$props;
    	let { width = false } = $$props;
    	let { clickable = false } = $$props;
    	let { slideTransition = false } = $$props;
    	let { style = width ? "width:" + width + "%;" : "" } = $$props;
    	let { small = false } = $$props;
    	let { noMargins = false } = $$props;
    	let { elementsPerRow = 1 } = $$props;
    	let { lastElementOfRow = elementsPerRow == 1 ? true : false } = $$props;
    	let { lastRow = false } = $$props;
    	const dispatch = createEventDispatcher();

    	const writable_props = [
    		'color',
    		'width',
    		'clickable',
    		'slideTransition',
    		'style',
    		'small',
    		'noMargins',
    		'elementsPerRow',
    		'lastElementOfRow',
    		'lastRow'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TextBlock> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		dispatch("click");
    	};

    	$$self.$$set = $$props => {
    		if ('color' in $$props) $$invalidate(0, color = $$props.color);
    		if ('width' in $$props) $$invalidate(10, width = $$props.width);
    		if ('clickable' in $$props) $$invalidate(1, clickable = $$props.clickable);
    		if ('slideTransition' in $$props) $$invalidate(2, slideTransition = $$props.slideTransition);
    		if ('style' in $$props) $$invalidate(3, style = $$props.style);
    		if ('small' in $$props) $$invalidate(4, small = $$props.small);
    		if ('noMargins' in $$props) $$invalidate(5, noMargins = $$props.noMargins);
    		if ('elementsPerRow' in $$props) $$invalidate(6, elementsPerRow = $$props.elementsPerRow);
    		if ('lastElementOfRow' in $$props) $$invalidate(7, lastElementOfRow = $$props.lastElementOfRow);
    		if ('lastRow' in $$props) $$invalidate(8, lastRow = $$props.lastRow);
    		if ('$$scope' in $$props) $$invalidate(11, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		slide,
    		color,
    		css,
    		width,
    		clickable,
    		slideTransition,
    		style,
    		small,
    		noMargins,
    		elementsPerRow,
    		lastElementOfRow,
    		lastRow,
    		createEventDispatcher,
    		dispatch
    	});

    	$$self.$inject_state = $$props => {
    		if ('color' in $$props) $$invalidate(0, color = $$props.color);
    		if ('width' in $$props) $$invalidate(10, width = $$props.width);
    		if ('clickable' in $$props) $$invalidate(1, clickable = $$props.clickable);
    		if ('slideTransition' in $$props) $$invalidate(2, slideTransition = $$props.slideTransition);
    		if ('style' in $$props) $$invalidate(3, style = $$props.style);
    		if ('small' in $$props) $$invalidate(4, small = $$props.small);
    		if ('noMargins' in $$props) $$invalidate(5, noMargins = $$props.noMargins);
    		if ('elementsPerRow' in $$props) $$invalidate(6, elementsPerRow = $$props.elementsPerRow);
    		if ('lastElementOfRow' in $$props) $$invalidate(7, lastElementOfRow = $$props.lastElementOfRow);
    		if ('lastRow' in $$props) $$invalidate(8, lastRow = $$props.lastRow);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		color,
    		clickable,
    		slideTransition,
    		style,
    		small,
    		noMargins,
    		elementsPerRow,
    		lastElementOfRow,
    		lastRow,
    		dispatch,
    		width,
    		$$scope,
    		slots,
    		click_handler
    	];
    }

    class TextBlock extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$K, create_fragment$K, safe_not_equal, {
    			color: 0,
    			width: 10,
    			clickable: 1,
    			slideTransition: 2,
    			style: 3,
    			small: 4,
    			noMargins: 5,
    			elementsPerRow: 6,
    			lastElementOfRow: 7,
    			lastRow: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TextBlock",
    			options,
    			id: create_fragment$K.name
    		});
    	}

    	get color() {
    		throw new Error("<TextBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<TextBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<TextBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<TextBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get clickable() {
    		throw new Error("<TextBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set clickable(value) {
    		throw new Error("<TextBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get slideTransition() {
    		throw new Error("<TextBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set slideTransition(value) {
    		throw new Error("<TextBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<TextBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<TextBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get small() {
    		throw new Error("<TextBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set small(value) {
    		throw new Error("<TextBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noMargins() {
    		throw new Error("<TextBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noMargins(value) {
    		throw new Error("<TextBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get elementsPerRow() {
    		throw new Error("<TextBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set elementsPerRow(value) {
    		throw new Error("<TextBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lastElementOfRow() {
    		throw new Error("<TextBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lastElementOfRow(value) {
    		throw new Error("<TextBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lastRow() {
    		throw new Error("<TextBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lastRow(value) {
    		throw new Error("<TextBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\client\svelte\components\ui\CellTitle.svelte generated by Svelte v3.50.1 */
    const file$H = "src\\client\\svelte\\components\\ui\\CellTitle.svelte";

    // (11:2) {#if imagePath}
    function create_if_block$t(ctx) {
    	let img;
    	let img_class_value;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", img_class_value = "titleImage " + (/*small*/ ctx[2] ? 'smallImage' : '') + " svelte-yv8692");
    			attr_dev(img, "alt", "titleImage");
    			if (!src_url_equal(img.src, img_src_value = /*imagePath*/ ctx[0])) attr_dev(img, "src", img_src_value);
    			add_location(img, file$H, 11, 4, 307);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*small*/ 4 && img_class_value !== (img_class_value = "titleImage " + (/*small*/ ctx[2] ? 'smallImage' : '') + " svelte-yv8692")) {
    				attr_dev(img, "class", img_class_value);
    			}

    			if (dirty & /*imagePath*/ 1 && !src_url_equal(img.src, img_src_value = /*imagePath*/ ctx[0])) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$t.name,
    		type: "if",
    		source: "(11:2) {#if imagePath}",
    		ctx
    	});

    	return block;
    }

    // (10:0) <TextBlock style="text-align:center;{style}" {color} {small} {noMargins}>
    function create_default_slot$f(ctx) {
    	let t;
    	let span;
    	let span_class_value;
    	let current;
    	let if_block = /*imagePath*/ ctx[0] && create_if_block$t(ctx);
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			span = element("span");
    			if (default_slot) default_slot.c();
    			attr_dev(span, "class", span_class_value = "cellTitle " + (/*small*/ ctx[2] ? 'smallTitle' : '') + " svelte-yv8692");
    			add_location(span, file$H, 17, 2, 433);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, span, anchor);

    			if (default_slot) {
    				default_slot.m(span, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*imagePath*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$t(ctx);
    					if_block.c();
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*small*/ 4 && span_class_value !== (span_class_value = "cellTitle " + (/*small*/ ctx[2] ? 'smallTitle' : '') + " svelte-yv8692")) {
    				attr_dev(span, "class", span_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(span);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$f.name,
    		type: "slot",
    		source: "(10:0) <TextBlock style=\\\"text-align:center;{style}\\\" {color} {small} {noMargins}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$J(ctx) {
    	let textblock;
    	let current;

    	textblock = new TextBlock({
    			props: {
    				style: "text-align:center;" + /*style*/ ctx[4],
    				color: /*color*/ ctx[1],
    				small: /*small*/ ctx[2],
    				noMargins: /*noMargins*/ ctx[3],
    				$$slots: { default: [create_default_slot$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(textblock.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(textblock, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const textblock_changes = {};
    			if (dirty & /*style*/ 16) textblock_changes.style = "text-align:center;" + /*style*/ ctx[4];
    			if (dirty & /*color*/ 2) textblock_changes.color = /*color*/ ctx[1];
    			if (dirty & /*small*/ 4) textblock_changes.small = /*small*/ ctx[2];
    			if (dirty & /*noMargins*/ 8) textblock_changes.noMargins = /*noMargins*/ ctx[3];

    			if (dirty & /*$$scope, small, imagePath*/ 69) {
    				textblock_changes.$$scope = { dirty, ctx };
    			}

    			textblock.$set(textblock_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(textblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$J($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CellTitle', slots, ['default']);
    	let { imagePath = "" } = $$props;
    	let { color } = $$props;
    	let { small = false } = $$props;
    	let { noMargins = false } = $$props;
    	let { style = "" } = $$props;
    	const writable_props = ['imagePath', 'color', 'small', 'noMargins', 'style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CellTitle> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('imagePath' in $$props) $$invalidate(0, imagePath = $$props.imagePath);
    		if ('color' in $$props) $$invalidate(1, color = $$props.color);
    		if ('small' in $$props) $$invalidate(2, small = $$props.small);
    		if ('noMargins' in $$props) $$invalidate(3, noMargins = $$props.noMargins);
    		if ('style' in $$props) $$invalidate(4, style = $$props.style);
    		if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		TextBlock,
    		imagePath,
    		color,
    		small,
    		noMargins,
    		style
    	});

    	$$self.$inject_state = $$props => {
    		if ('imagePath' in $$props) $$invalidate(0, imagePath = $$props.imagePath);
    		if ('color' in $$props) $$invalidate(1, color = $$props.color);
    		if ('small' in $$props) $$invalidate(2, small = $$props.small);
    		if ('noMargins' in $$props) $$invalidate(3, noMargins = $$props.noMargins);
    		if ('style' in $$props) $$invalidate(4, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [imagePath, color, small, noMargins, style, slots, $$scope];
    }

    class CellTitle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$J, create_fragment$J, safe_not_equal, {
    			imagePath: 0,
    			color: 1,
    			small: 2,
    			noMargins: 3,
    			style: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CellTitle",
    			options,
    			id: create_fragment$J.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*color*/ ctx[1] === undefined && !('color' in props)) {
    			console.warn("<CellTitle> was created without expected prop 'color'");
    		}
    	}

    	get imagePath() {
    		throw new Error("<CellTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set imagePath(value) {
    		throw new Error("<CellTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<CellTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<CellTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get small() {
    		throw new Error("<CellTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set small(value) {
    		throw new Error("<CellTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noMargins() {
    		throw new Error("<CellTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noMargins(value) {
    		throw new Error("<CellTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<CellTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<CellTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\client\svelte\components\ui\Cell.svelte generated by Svelte v3.50.1 */
    const file$G = "src\\client\\svelte\\components\\ui\\Cell.svelte";

    // (27:2) {#if title}
    function create_if_block$s(ctx) {
    	let celltitle;
    	let current;

    	celltitle = new CellTitle({
    			props: {
    				imagePath: /*titleImagePath*/ ctx[1],
    				color: /*color*/ ctx[2],
    				style: /*titleStyle*/ ctx[4],
    				$$slots: { default: [create_default_slot$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(celltitle.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(celltitle, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const celltitle_changes = {};
    			if (dirty & /*titleImagePath*/ 2) celltitle_changes.imagePath = /*titleImagePath*/ ctx[1];
    			if (dirty & /*color*/ 4) celltitle_changes.color = /*color*/ ctx[2];
    			if (dirty & /*titleStyle*/ 16) celltitle_changes.style = /*titleStyle*/ ctx[4];

    			if (dirty & /*$$scope, title*/ 2049) {
    				celltitle_changes.$$scope = { dirty, ctx };
    			}

    			celltitle.$set(celltitle_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(celltitle.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(celltitle.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(celltitle, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$s.name,
    		type: "if",
    		source: "(27:2) {#if title}",
    		ctx
    	});

    	return block;
    }

    // (28:4) <CellTitle imagePath={titleImagePath} {color} style={titleStyle}        >
    function create_default_slot$e(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*title*/ ctx[0]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 1) set_data_dev(t, /*title*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$e.name,
    		type: "slot",
    		source: "(28:4) <CellTitle imagePath={titleImagePath} {color} style={titleStyle}        >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$I(ctx) {
    	let div;
    	let t;
    	let div_style_value;
    	let current;
    	let if_block = /*title*/ ctx[0] && create_if_block$s(ctx);
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "cell svelte-1gigcgs");
    			attr_dev(div, "style", div_style_value = "padding-left: " + (/*noMarginLeft*/ ctx[7] ? 0 : css.default.margin) + "px; padding-right: " + (/*noMarginRight*/ ctx[6] ? 0 : css.default.margin) + "px; padding-top: " + (/*noMarginTop*/ ctx[5] ? 0 : css.default.margin) + "px; padding-bottom: " + (/*noMarginBottom*/ ctx[8] ? 0 : css.default.margin) + "px; " + /*style*/ ctx[3] + "");
    			add_location(div, file$G, 16, 0, 451);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*title*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*title*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$s(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[11],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*noMarginLeft, noMarginRight, noMarginTop, noMarginBottom, style*/ 488 && div_style_value !== (div_style_value = "padding-left: " + (/*noMarginLeft*/ ctx[7] ? 0 : css.default.margin) + "px; padding-right: " + (/*noMarginRight*/ ctx[6] ? 0 : css.default.margin) + "px; padding-top: " + (/*noMarginTop*/ ctx[5] ? 0 : css.default.margin) + "px; padding-bottom: " + (/*noMarginBottom*/ ctx[8] ? 0 : css.default.margin) + "px; " + /*style*/ ctx[3] + "")) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Cell', slots, ['default']);
    	let { title = "" } = $$props;
    	let { titleImagePath = "" } = $$props;
    	let { color = "blue" } = $$props;
    	let { style = "" } = $$props;
    	let { titleStyle = "" } = $$props;
    	let { noMargin = false } = $$props;
    	let { noMarginTop = noMargin } = $$props;
    	let { noMarginRight = noMargin } = $$props;
    	let { noMarginLeft = noMargin } = $$props;
    	let { noMarginBottom = noMargin } = $$props;

    	const writable_props = [
    		'title',
    		'titleImagePath',
    		'color',
    		'style',
    		'titleStyle',
    		'noMargin',
    		'noMarginTop',
    		'noMarginRight',
    		'noMarginLeft',
    		'noMarginBottom'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Cell> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('titleImagePath' in $$props) $$invalidate(1, titleImagePath = $$props.titleImagePath);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('style' in $$props) $$invalidate(3, style = $$props.style);
    		if ('titleStyle' in $$props) $$invalidate(4, titleStyle = $$props.titleStyle);
    		if ('noMargin' in $$props) $$invalidate(9, noMargin = $$props.noMargin);
    		if ('noMarginTop' in $$props) $$invalidate(5, noMarginTop = $$props.noMarginTop);
    		if ('noMarginRight' in $$props) $$invalidate(6, noMarginRight = $$props.noMarginRight);
    		if ('noMarginLeft' in $$props) $$invalidate(7, noMarginLeft = $$props.noMarginLeft);
    		if ('noMarginBottom' in $$props) $$invalidate(8, noMarginBottom = $$props.noMarginBottom);
    		if ('$$scope' in $$props) $$invalidate(11, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		CellTitle,
    		css,
    		title,
    		titleImagePath,
    		color,
    		style,
    		titleStyle,
    		noMargin,
    		noMarginTop,
    		noMarginRight,
    		noMarginLeft,
    		noMarginBottom
    	});

    	$$self.$inject_state = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('titleImagePath' in $$props) $$invalidate(1, titleImagePath = $$props.titleImagePath);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('style' in $$props) $$invalidate(3, style = $$props.style);
    		if ('titleStyle' in $$props) $$invalidate(4, titleStyle = $$props.titleStyle);
    		if ('noMargin' in $$props) $$invalidate(9, noMargin = $$props.noMargin);
    		if ('noMarginTop' in $$props) $$invalidate(5, noMarginTop = $$props.noMarginTop);
    		if ('noMarginRight' in $$props) $$invalidate(6, noMarginRight = $$props.noMarginRight);
    		if ('noMarginLeft' in $$props) $$invalidate(7, noMarginLeft = $$props.noMarginLeft);
    		if ('noMarginBottom' in $$props) $$invalidate(8, noMarginBottom = $$props.noMarginBottom);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		title,
    		titleImagePath,
    		color,
    		style,
    		titleStyle,
    		noMarginTop,
    		noMarginRight,
    		noMarginLeft,
    		noMarginBottom,
    		noMargin,
    		slots,
    		$$scope
    	];
    }

    class Cell extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$I, create_fragment$I, safe_not_equal, {
    			title: 0,
    			titleImagePath: 1,
    			color: 2,
    			style: 3,
    			titleStyle: 4,
    			noMargin: 9,
    			noMarginTop: 5,
    			noMarginRight: 6,
    			noMarginLeft: 7,
    			noMarginBottom: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Cell",
    			options,
    			id: create_fragment$I.name
    		});
    	}

    	get title() {
    		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleImagePath() {
    		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleImagePath(value) {
    		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleStyle() {
    		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleStyle(value) {
    		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noMargin() {
    		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noMargin(value) {
    		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noMarginTop() {
    		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noMarginTop(value) {
    		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noMarginRight() {
    		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noMarginRight(value) {
    		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noMarginLeft() {
    		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noMarginLeft(value) {
    		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noMarginBottom() {
    		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noMarginBottom(value) {
    		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\client\svelte\components\ui\ClosableDisplay.svelte generated by Svelte v3.50.1 */
    const file$F = "src\\client\\svelte\\components\\ui\\ClosableDisplay.svelte";

    // (33:0) {#if displayedText}
    function create_if_block$r(ctx) {
    	let div;
    	let cell;
    	let div_transition;
    	let current;

    	cell = new Cell({
    			props: {
    				style: "width:fit-content;margin:auto;",
    				$$slots: { default: [create_default_slot$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(cell.$$.fragment);
    			attr_dev(div, "class", "closableDisplay svelte-3lplng");
    			add_location(div, file$F, 33, 2, 804);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(cell, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const cell_changes = {};

    			if (dirty & /*$$scope, color, width, displayedText, imagePath*/ 527) {
    				cell_changes.$$scope = { dirty, ctx };
    			}

    			cell.$set(cell_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cell.$$.fragment, local);

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {}, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cell.$$.fragment, local);
    			if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {}, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(cell);
    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$r.name,
    		type: "if",
    		source: "(33:0) {#if displayedText}",
    		ctx
    	});

    	return block;
    }

    // (37:8) {#if imagePath}
    function create_if_block_1$e(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "alt", "closableImage");
    			if (!src_url_equal(img.src, img_src_value = /*imagePath*/ ctx[3])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "class", "closableImage svelte-3lplng");
    			add_location(img, file$F, 37, 10, 973);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*imagePath*/ 8 && !src_url_equal(img.src, img_src_value = /*imagePath*/ ctx[3])) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$e.name,
    		type: "if",
    		source: "(37:8) {#if imagePath}",
    		ctx
    	});

    	return block;
    }

    // (36:6) <TextBlock {color} {width}>
    function create_default_slot_1$8(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let img;
    	let img_src_value;
    	let mounted;
    	let dispose;
    	let if_block = /*imagePath*/ ctx[3] && create_if_block_1$e(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t0 = space();
    			t1 = text(/*displayedText*/ ctx[0]);
    			t2 = space();
    			img = element("img");
    			attr_dev(img, "alt", "close");
    			if (!src_url_equal(img.src, img_src_value = "assets/images/connection/close.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "class", "closingCross svelte-3lplng");
    			add_location(img, file$F, 40, 8, 1088);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, img, anchor);

    			if (!mounted) {
    				dispose = listen_dev(img, "click", /*click_handler*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*imagePath*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$e(ctx);
    					if_block.c();
    					if_block.m(t0.parentNode, t0);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*displayedText*/ 1) set_data_dev(t1, /*displayedText*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(img);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$8.name,
    		type: "slot",
    		source: "(36:6) <TextBlock {color} {width}>",
    		ctx
    	});

    	return block;
    }

    // (35:4) <Cell style="width:fit-content;margin:auto;">
    function create_default_slot$d(ctx) {
    	let textblock;
    	let current;

    	textblock = new TextBlock({
    			props: {
    				color: /*color*/ ctx[1],
    				width: /*width*/ ctx[2],
    				$$slots: { default: [create_default_slot_1$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(textblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(textblock, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const textblock_changes = {};
    			if (dirty & /*color*/ 2) textblock_changes.color = /*color*/ ctx[1];
    			if (dirty & /*width*/ 4) textblock_changes.width = /*width*/ ctx[2];

    			if (dirty & /*$$scope, displayedText, imagePath*/ 521) {
    				textblock_changes.$$scope = { dirty, ctx };
    			}

    			textblock.$set(textblock_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(textblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$d.name,
    		type: "slot",
    		source: "(35:4) <Cell style=\\\"width:fit-content;margin:auto;\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$H(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*displayedText*/ ctx[0] && create_if_block$r(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*displayedText*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*displayedText*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$r(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ClosableDisplay', slots, []);
    	let { color = "green" } = $$props;
    	let { width = 100 } = $$props;
    	let { imagePath = false } = $$props;
    	let { displayedText = false } = $$props;
    	let { sound } = $$props;
    	let autoCloseTimer = false;

    	function displayedTextChanger(newDisplayedText) {
    		if (sound && newDisplayedText) {
    			Client$1.phaser.playSound(sound);
    		}

    		clearTimeout(autoCloseTimer);

    		autoCloseTimer = setTimeout(
    			() => {
    				close();
    				clearTimeout(autoCloseTimer);
    			},
    			3000
    		);
    	}

    	function close() {
    		$$invalidate(0, displayedText = false);
    	}

    	const writable_props = ['color', 'width', 'imagePath', 'displayedText', 'sound'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ClosableDisplay> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => close();

    	$$self.$$set = $$props => {
    		if ('color' in $$props) $$invalidate(1, color = $$props.color);
    		if ('width' in $$props) $$invalidate(2, width = $$props.width);
    		if ('imagePath' in $$props) $$invalidate(3, imagePath = $$props.imagePath);
    		if ('displayedText' in $$props) $$invalidate(0, displayedText = $$props.displayedText);
    		if ('sound' in $$props) $$invalidate(5, sound = $$props.sound);
    	};

    	$$self.$capture_state = () => ({
    		slide,
    		Cell,
    		TextBlock,
    		Client: Client$1,
    		color,
    		width,
    		imagePath,
    		displayedText,
    		sound,
    		autoCloseTimer,
    		displayedTextChanger,
    		close
    	});

    	$$self.$inject_state = $$props => {
    		if ('color' in $$props) $$invalidate(1, color = $$props.color);
    		if ('width' in $$props) $$invalidate(2, width = $$props.width);
    		if ('imagePath' in $$props) $$invalidate(3, imagePath = $$props.imagePath);
    		if ('displayedText' in $$props) $$invalidate(0, displayedText = $$props.displayedText);
    		if ('sound' in $$props) $$invalidate(5, sound = $$props.sound);
    		if ('autoCloseTimer' in $$props) autoCloseTimer = $$props.autoCloseTimer;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*displayedText*/ 1) {
    			{
    				displayedTextChanger(displayedText);
    			}
    		}
    	};

    	return [displayedText, color, width, imagePath, close, sound, click_handler];
    }

    class ClosableDisplay extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$H, create_fragment$H, safe_not_equal, {
    			color: 1,
    			width: 2,
    			imagePath: 3,
    			displayedText: 0,
    			sound: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ClosableDisplay",
    			options,
    			id: create_fragment$H.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*sound*/ ctx[5] === undefined && !('sound' in props)) {
    			console.warn("<ClosableDisplay> was created without expected prop 'sound'");
    		}
    	}

    	get color() {
    		throw new Error("<ClosableDisplay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<ClosableDisplay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<ClosableDisplay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<ClosableDisplay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get imagePath() {
    		throw new Error("<ClosableDisplay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set imagePath(value) {
    		throw new Error("<ClosableDisplay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get displayedText() {
    		throw new Error("<ClosableDisplay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set displayedText(value) {
    		throw new Error("<ClosableDisplay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sound() {
    		throw new Error("<ClosableDisplay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sound(value) {
    		throw new Error("<ClosableDisplay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\client\svelte\components\ui\PointerzButton.svelte generated by Svelte v3.50.1 */
    const file$E = "src\\client\\svelte\\components\\ui\\PointerzButton.svelte";

    // (48:4) {#if imagePath}
    function create_if_block$q(ctx) {
    	let img;
    	let img_src_value;
    	let img_class_value;
    	let img_style_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "alt", "buttonImage");
    			if (!src_url_equal(img.src, img_src_value = /*imagePath*/ ctx[1])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "class", img_class_value = "buttonImage " + (/*important*/ ctx[0] ? 'importantButtonImage' : '') + " " + (/*imageOnly*/ ctx[2] ? 'imageOnly' : '') + " svelte-apdozu");
    			attr_dev(img, "style", img_style_value = "height: " + /*imageHeight*/ ctx[3] + "; " + (/*animateImage*/ ctx[4] ? 'animation: growing 1s;' : ''));
    			add_location(img, file$E, 48, 6, 1511);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*imagePath*/ 2 && !src_url_equal(img.src, img_src_value = /*imagePath*/ ctx[1])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*important, imageOnly*/ 5 && img_class_value !== (img_class_value = "buttonImage " + (/*important*/ ctx[0] ? 'importantButtonImage' : '') + " " + (/*imageOnly*/ ctx[2] ? 'imageOnly' : '') + " svelte-apdozu")) {
    				attr_dev(img, "class", img_class_value);
    			}

    			if (dirty & /*imageHeight, animateImage*/ 24 && img_style_value !== (img_style_value = "height: " + /*imageHeight*/ ctx[3] + "; " + (/*animateImage*/ ctx[4] ? 'animation: growing 1s;' : ''))) {
    				attr_dev(img, "style", img_style_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$q.name,
    		type: "if",
    		source: "(48:4) {#if imagePath}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$G(ctx) {
    	let button;
    	let p;
    	let t;
    	let button_class_value;
    	let button_style_value;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*imagePath*/ ctx[1] && create_if_block$q(ctx);
    	const default_slot_template = /*#slots*/ ctx[19].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], null);

    	const block = {
    		c: function create() {
    			button = element("button");
    			p = element("p");
    			if (if_block) if_block.c();
    			t = space();
    			if (default_slot) default_slot.c();
    			attr_dev(p, "class", "svelte-apdozu");
    			add_location(p, file$E, 46, 2, 1479);
    			attr_dev(button, "class", button_class_value = "" + (/*multicolorClass*/ ctx[13] + " " + /*importantClass*/ ctx[14] + " " + /*buttonColor*/ ctx[5] + " " + (/*animating*/ ctx[6] ? 'animatingHover' : '') + " " + (/*clickable*/ ctx[8] ? '' : 'unclickable') + " svelte-apdozu"));

    			attr_dev(button, "style", button_style_value = "width: " + ('calc(' + 100 / /*elementsPerRow*/ ctx[9] + '% - ' + css.default.margin * (/*elementsPerRow*/ ctx[9] - 1) / /*elementsPerRow*/ ctx[9] + 'px)') + "; margin-right: " + (/*lastElementOfRow*/ ctx[10] || /*noMargins*/ ctx[12]
    			? 0
    			: css.default.margin) + "px; margin-bottom: " + ((/*lastRow*/ ctx[11] || /*noMargins*/ ctx[12]
    			? 0
    			: css.default.margin) + 4) + "px; " + (/*fullHeight*/ ctx[7] ? 'height: 100%' : '') + "");

    			add_location(button, file$E, 31, 0, 939);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, p);
    			if (if_block) if_block.m(p, null);
    			append_dev(p, t);

    			if (default_slot) {
    				default_slot.m(p, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "mousedown", /*proceedClick*/ ctx[15], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*imagePath*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$q(ctx);
    					if_block.c();
    					if_block.m(p, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 262144)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[18],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[18])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[18], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*buttonColor, animating, clickable*/ 352 && button_class_value !== (button_class_value = "" + (/*multicolorClass*/ ctx[13] + " " + /*importantClass*/ ctx[14] + " " + /*buttonColor*/ ctx[5] + " " + (/*animating*/ ctx[6] ? 'animatingHover' : '') + " " + (/*clickable*/ ctx[8] ? '' : 'unclickable') + " svelte-apdozu"))) {
    				attr_dev(button, "class", button_class_value);
    			}

    			if (!current || dirty & /*elementsPerRow, lastElementOfRow, noMargins, lastRow, fullHeight*/ 7808 && button_style_value !== (button_style_value = "width: " + ('calc(' + 100 / /*elementsPerRow*/ ctx[9] + '% - ' + css.default.margin * (/*elementsPerRow*/ ctx[9] - 1) / /*elementsPerRow*/ ctx[9] + 'px)') + "; margin-right: " + (/*lastElementOfRow*/ ctx[10] || /*noMargins*/ ctx[12]
    			? 0
    			: css.default.margin) + "px; margin-bottom: " + ((/*lastRow*/ ctx[11] || /*noMargins*/ ctx[12]
    			? 0
    			: css.default.margin) + 4) + "px; " + (/*fullHeight*/ ctx[7] ? 'height: 100%' : '') + "")) {
    				attr_dev(button, "style", button_style_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (if_block) if_block.d();
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PointerzButton', slots, ['default']);
    	const dispatch = createEventDispatcher();
    	let { multicolor = false } = $$props;
    	let { important = false } = $$props;
    	let { imagePath = false } = $$props;
    	let { imageOnly = false } = $$props;
    	let { imageHeight = "24px" } = $$props;
    	let { animateImage = true } = $$props;
    	let { buttonColor = "" } = $$props;
    	let { animating = false } = $$props;
    	let { fullHeight = false } = $$props;
    	let { clickable = true } = $$props;
    	let { noSound = false } = $$props;
    	let { elementsPerRow = 1 } = $$props;
    	let { lastElementOfRow = elementsPerRow == 1 ? true : false } = $$props;
    	let { lastRow = false } = $$props;
    	let { noMargins = false } = $$props;
    	let multicolorClass = multicolor ? "multicolorButton" : "";
    	let importantClass = important ? "importantButton" : "";

    	function proceedClick() {
    		!noSound && Client.phaser.playSound("buttonClick");
    		dispatch("click");
    	}

    	const writable_props = [
    		'multicolor',
    		'important',
    		'imagePath',
    		'imageOnly',
    		'imageHeight',
    		'animateImage',
    		'buttonColor',
    		'animating',
    		'fullHeight',
    		'clickable',
    		'noSound',
    		'elementsPerRow',
    		'lastElementOfRow',
    		'lastRow',
    		'noMargins'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PointerzButton> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('multicolor' in $$props) $$invalidate(16, multicolor = $$props.multicolor);
    		if ('important' in $$props) $$invalidate(0, important = $$props.important);
    		if ('imagePath' in $$props) $$invalidate(1, imagePath = $$props.imagePath);
    		if ('imageOnly' in $$props) $$invalidate(2, imageOnly = $$props.imageOnly);
    		if ('imageHeight' in $$props) $$invalidate(3, imageHeight = $$props.imageHeight);
    		if ('animateImage' in $$props) $$invalidate(4, animateImage = $$props.animateImage);
    		if ('buttonColor' in $$props) $$invalidate(5, buttonColor = $$props.buttonColor);
    		if ('animating' in $$props) $$invalidate(6, animating = $$props.animating);
    		if ('fullHeight' in $$props) $$invalidate(7, fullHeight = $$props.fullHeight);
    		if ('clickable' in $$props) $$invalidate(8, clickable = $$props.clickable);
    		if ('noSound' in $$props) $$invalidate(17, noSound = $$props.noSound);
    		if ('elementsPerRow' in $$props) $$invalidate(9, elementsPerRow = $$props.elementsPerRow);
    		if ('lastElementOfRow' in $$props) $$invalidate(10, lastElementOfRow = $$props.lastElementOfRow);
    		if ('lastRow' in $$props) $$invalidate(11, lastRow = $$props.lastRow);
    		if ('noMargins' in $$props) $$invalidate(12, noMargins = $$props.noMargins);
    		if ('$$scope' in $$props) $$invalidate(18, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		css,
    		dispatch,
    		multicolor,
    		important,
    		imagePath,
    		imageOnly,
    		imageHeight,
    		animateImage,
    		buttonColor,
    		animating,
    		fullHeight,
    		clickable,
    		noSound,
    		elementsPerRow,
    		lastElementOfRow,
    		lastRow,
    		noMargins,
    		multicolorClass,
    		importantClass,
    		proceedClick
    	});

    	$$self.$inject_state = $$props => {
    		if ('multicolor' in $$props) $$invalidate(16, multicolor = $$props.multicolor);
    		if ('important' in $$props) $$invalidate(0, important = $$props.important);
    		if ('imagePath' in $$props) $$invalidate(1, imagePath = $$props.imagePath);
    		if ('imageOnly' in $$props) $$invalidate(2, imageOnly = $$props.imageOnly);
    		if ('imageHeight' in $$props) $$invalidate(3, imageHeight = $$props.imageHeight);
    		if ('animateImage' in $$props) $$invalidate(4, animateImage = $$props.animateImage);
    		if ('buttonColor' in $$props) $$invalidate(5, buttonColor = $$props.buttonColor);
    		if ('animating' in $$props) $$invalidate(6, animating = $$props.animating);
    		if ('fullHeight' in $$props) $$invalidate(7, fullHeight = $$props.fullHeight);
    		if ('clickable' in $$props) $$invalidate(8, clickable = $$props.clickable);
    		if ('noSound' in $$props) $$invalidate(17, noSound = $$props.noSound);
    		if ('elementsPerRow' in $$props) $$invalidate(9, elementsPerRow = $$props.elementsPerRow);
    		if ('lastElementOfRow' in $$props) $$invalidate(10, lastElementOfRow = $$props.lastElementOfRow);
    		if ('lastRow' in $$props) $$invalidate(11, lastRow = $$props.lastRow);
    		if ('noMargins' in $$props) $$invalidate(12, noMargins = $$props.noMargins);
    		if ('multicolorClass' in $$props) $$invalidate(13, multicolorClass = $$props.multicolorClass);
    		if ('importantClass' in $$props) $$invalidate(14, importantClass = $$props.importantClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		important,
    		imagePath,
    		imageOnly,
    		imageHeight,
    		animateImage,
    		buttonColor,
    		animating,
    		fullHeight,
    		clickable,
    		elementsPerRow,
    		lastElementOfRow,
    		lastRow,
    		noMargins,
    		multicolorClass,
    		importantClass,
    		proceedClick,
    		multicolor,
    		noSound,
    		$$scope,
    		slots
    	];
    }

    class PointerzButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$G, create_fragment$G, safe_not_equal, {
    			multicolor: 16,
    			important: 0,
    			imagePath: 1,
    			imageOnly: 2,
    			imageHeight: 3,
    			animateImage: 4,
    			buttonColor: 5,
    			animating: 6,
    			fullHeight: 7,
    			clickable: 8,
    			noSound: 17,
    			elementsPerRow: 9,
    			lastElementOfRow: 10,
    			lastRow: 11,
    			noMargins: 12
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PointerzButton",
    			options,
    			id: create_fragment$G.name
    		});
    	}

    	get multicolor() {
    		throw new Error("<PointerzButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set multicolor(value) {
    		throw new Error("<PointerzButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get important() {
    		throw new Error("<PointerzButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set important(value) {
    		throw new Error("<PointerzButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get imagePath() {
    		throw new Error("<PointerzButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set imagePath(value) {
    		throw new Error("<PointerzButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get imageOnly() {
    		throw new Error("<PointerzButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set imageOnly(value) {
    		throw new Error("<PointerzButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get imageHeight() {
    		throw new Error("<PointerzButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set imageHeight(value) {
    		throw new Error("<PointerzButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get animateImage() {
    		throw new Error("<PointerzButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set animateImage(value) {
    		throw new Error("<PointerzButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get buttonColor() {
    		throw new Error("<PointerzButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set buttonColor(value) {
    		throw new Error("<PointerzButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get animating() {
    		throw new Error("<PointerzButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set animating(value) {
    		throw new Error("<PointerzButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fullHeight() {
    		throw new Error("<PointerzButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fullHeight(value) {
    		throw new Error("<PointerzButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get clickable() {
    		throw new Error("<PointerzButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set clickable(value) {
    		throw new Error("<PointerzButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noSound() {
    		throw new Error("<PointerzButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noSound(value) {
    		throw new Error("<PointerzButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get elementsPerRow() {
    		throw new Error("<PointerzButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set elementsPerRow(value) {
    		throw new Error("<PointerzButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lastElementOfRow() {
    		throw new Error("<PointerzButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lastElementOfRow(value) {
    		throw new Error("<PointerzButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lastRow() {
    		throw new Error("<PointerzButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lastRow(value) {
    		throw new Error("<PointerzButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noMargins() {
    		throw new Error("<PointerzButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noMargins(value) {
    		throw new Error("<PointerzButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\client\svelte\components\ui\PointerzModal.svelte generated by Svelte v3.50.1 */
    const file$D = "src\\client\\svelte\\components\\ui\\PointerzModal.svelte";
    const get_confirm_slot_changes$1 = dirty => ({});
    const get_confirm_slot_context$1 = ctx => ({});
    const get_cancel_slot_changes$1 = dirty => ({});
    const get_cancel_slot_context$1 = ctx => ({});
    const get_description_slot_changes$1 = dirty => ({});
    const get_description_slot_context$1 = ctx => ({});
    const get_title_slot_changes$1 = dirty => ({});
    const get_title_slot_context$1 = ctx => ({});

    // (28:0) {#if showDialog}
    function create_if_block$p(ctx) {
    	let div3;
    	let div2;
    	let div1;
    	let div0;
    	let span0;
    	let t0;
    	let span1;
    	let t1;
    	let t2;
    	let span2;
    	let div2_class_value;
    	let div2_intro;
    	let div2_outro;
    	let div3_intro;
    	let div3_outro;
    	let current;
    	let mounted;
    	let dispose;
    	const title_slot_template = /*#slots*/ ctx[11].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[10], get_title_slot_context$1);
    	const title_slot_or_fallback = title_slot || fallback_block_2$1(ctx);
    	const description_slot_template = /*#slots*/ ctx[11].description;
    	const description_slot = create_slot(description_slot_template, ctx, /*$$scope*/ ctx[10], get_description_slot_context$1);
    	let if_block = (/*canCancel*/ ctx[4] || /*showConfirmButton*/ ctx[5]) && create_if_block_1$d(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			span0 = element("span");
    			if (title_slot_or_fallback) title_slot_or_fallback.c();
    			t0 = space();
    			span1 = element("span");
    			if (description_slot) description_slot.c();
    			t1 = space();
    			if (if_block) if_block.c();
    			t2 = space();
    			span2 = element("span");
    			span2.textContent = "✕";
    			attr_dev(span0, "class", "message-title svelte-1bzsxw9");
    			add_location(span0, file$D, 45, 10, 1104);
    			attr_dev(span1, "class", "message-description svelte-1bzsxw9");
    			add_location(span1, file$D, 49, 10, 1264);
    			attr_dev(div0, "class", "message-section");
    			add_location(div0, file$D, 44, 8, 1063);
    			attr_dev(span2, "class", "close svelte-1bzsxw9");
    			add_location(span2, file$D, 77, 8, 2131);
    			set_style(div1, "position", "relative");
    			add_location(div1, file$D, 43, 6, 1021);
    			attr_dev(div2, "class", div2_class_value = "" + (null_to_empty("confirm-dialog " + /*color*/ ctx[3]) + " svelte-1bzsxw9"));
    			add_location(div2, file$D, 32, 4, 809);
    			attr_dev(div3, "class", "overlay svelte-1bzsxw9");
    			add_location(div3, file$D, 28, 2, 698);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, span0);

    			if (title_slot_or_fallback) {
    				title_slot_or_fallback.m(span0, null);
    			}

    			append_dev(div0, t0);
    			append_dev(div0, span1);

    			if (description_slot) {
    				description_slot.m(span1, null);
    			}

    			append_dev(div1, t1);
    			if (if_block) if_block.m(div1, null);
    			append_dev(div1, t2);
    			append_dev(div1, span2);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(span2, "click", /*callCancelFunction*/ ctx[7], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (title_slot) {
    				if (title_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[10],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[10], dirty, get_title_slot_changes$1),
    						get_title_slot_context$1
    					);
    				}
    			}

    			if (description_slot) {
    				if (description_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
    					update_slot_base(
    						description_slot,
    						description_slot_template,
    						ctx,
    						/*$$scope*/ ctx[10],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
    						: get_slot_changes(description_slot_template, /*$$scope*/ ctx[10], dirty, get_description_slot_changes$1),
    						get_description_slot_context$1
    					);
    				}
    			}

    			if (/*canCancel*/ ctx[4] || /*showConfirmButton*/ ctx[5]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*canCancel, showConfirmButton*/ 48) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$d(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, t2);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*color*/ 8 && div2_class_value !== (div2_class_value = "" + (null_to_empty("confirm-dialog " + /*color*/ ctx[3]) + " svelte-1bzsxw9"))) {
    				attr_dev(div2, "class", div2_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot_or_fallback, local);
    			transition_in(description_slot, local);
    			transition_in(if_block);

    			add_render_callback(() => {
    				if (div2_outro) div2_outro.end(1);
    				div2_intro = create_in_transition(div2, fly, { y: -10, delay: 200, duration: 200 });
    				div2_intro.start();
    			});

    			add_render_callback(() => {
    				if (div3_outro) div3_outro.end(1);
    				div3_intro = create_in_transition(div3, fade, { duration: 200 });
    				div3_intro.start();
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot_or_fallback, local);
    			transition_out(description_slot, local);
    			transition_out(if_block);
    			if (div2_intro) div2_intro.invalidate();
    			div2_outro = create_out_transition(div2, fly, { y: -10, duration: 200 });
    			if (div3_intro) div3_intro.invalidate();
    			div3_outro = create_out_transition(div3, fade, { delay: 200, duration: 200 });
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (title_slot_or_fallback) title_slot_or_fallback.d(detaching);
    			if (description_slot) description_slot.d(detaching);
    			if (if_block) if_block.d();
    			if (detaching && div2_outro) div2_outro.end();
    			if (detaching && div3_outro) div3_outro.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$p.name,
    		type: "if",
    		source: "(28:0) {#if showDialog}",
    		ctx
    	});

    	return block;
    }

    // (48:15) Are you sure you want to perform this action?
    function fallback_block_2$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Are you sure you want to perform this action?");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_2$1.name,
    		type: "fallback",
    		source: "(48:15) Are you sure you want to perform this action?",
    		ctx
    	});

    	return block;
    }

    // (54:8) {#if canCancel || showConfirmButton}
    function create_if_block_1$d(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block0 = /*canCancel*/ ctx[4] && create_if_block_3$4(ctx);
    	let if_block1 = /*showConfirmButton*/ ctx[5] && create_if_block_2$8(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", "actions svelte-1bzsxw9");
    			add_location(div, file$D, 54, 10, 1432);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*canCancel*/ ctx[4]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*canCancel*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3$4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*showConfirmButton*/ ctx[5]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*showConfirmButton*/ 32) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_2$8(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$d.name,
    		type: "if",
    		source: "(54:8) {#if canCancel || showConfirmButton}",
    		ctx
    	});

    	return block;
    }

    // (56:12) {#if canCancel}
    function create_if_block_3$4(ctx) {
    	let button;
    	let current;
    	let mounted;
    	let dispose;
    	const cancel_slot_template = /*#slots*/ ctx[11].cancel;
    	const cancel_slot = create_slot(cancel_slot_template, ctx, /*$$scope*/ ctx[10], get_cancel_slot_context$1);
    	const cancel_slot_or_fallback = cancel_slot || fallback_block_1$1(ctx);

    	const block = {
    		c: function create() {
    			button = element("button");
    			if (cancel_slot_or_fallback) cancel_slot_or_fallback.c();
    			attr_dev(button, "class", "modal-button cancel-button svelte-1bzsxw9");
    			attr_dev(button, "important", "");
    			add_location(button, file$D, 56, 14, 1498);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (cancel_slot_or_fallback) {
    				cancel_slot_or_fallback.m(button, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*callCancelFunction*/ ctx[7], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (cancel_slot) {
    				if (cancel_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
    					update_slot_base(
    						cancel_slot,
    						cancel_slot_template,
    						ctx,
    						/*$$scope*/ ctx[10],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
    						: get_slot_changes(cancel_slot_template, /*$$scope*/ ctx[10], dirty, get_cancel_slot_changes$1),
    						get_cancel_slot_context$1
    					);
    				}
    			} else {
    				if (cancel_slot_or_fallback && cancel_slot_or_fallback.p && (!current || dirty & /*cancelTitle*/ 4)) {
    					cancel_slot_or_fallback.p(ctx, !current ? -1 : dirty);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cancel_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cancel_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (cancel_slot_or_fallback) cancel_slot_or_fallback.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(56:12) {#if canCancel}",
    		ctx
    	});

    	return block;
    }

    // (61:36)                     
    function fallback_block_1$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*cancelTitle*/ ctx[2]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*cancelTitle*/ 4) set_data_dev(t, /*cancelTitle*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_1$1.name,
    		type: "fallback",
    		source: "(61:36)                     ",
    		ctx
    	});

    	return block;
    }

    // (66:12) {#if showConfirmButton}
    function create_if_block_2$8(ctx) {
    	let button;
    	let current;
    	let mounted;
    	let dispose;
    	const confirm_slot_template = /*#slots*/ ctx[11].confirm;
    	const confirm_slot = create_slot(confirm_slot_template, ctx, /*$$scope*/ ctx[10], get_confirm_slot_context$1);
    	const confirm_slot_or_fallback = confirm_slot || fallback_block$2(ctx);

    	const block = {
    		c: function create() {
    			button = element("button");
    			if (confirm_slot_or_fallback) confirm_slot_or_fallback.c();
    			attr_dev(button, "class", "modal-button svelte-1bzsxw9");
    			attr_dev(button, "important", "");
    			add_location(button, file$D, 66, 14, 1825);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (confirm_slot_or_fallback) {
    				confirm_slot_or_fallback.m(button, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*callConfirmFunction*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (confirm_slot) {
    				if (confirm_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
    					update_slot_base(
    						confirm_slot,
    						confirm_slot_template,
    						ctx,
    						/*$$scope*/ ctx[10],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
    						: get_slot_changes(confirm_slot_template, /*$$scope*/ ctx[10], dirty, get_confirm_slot_changes$1),
    						get_confirm_slot_context$1
    					);
    				}
    			} else {
    				if (confirm_slot_or_fallback && confirm_slot_or_fallback.p && (!current || dirty & /*confirmTitle*/ 2)) {
    					confirm_slot_or_fallback.p(ctx, !current ? -1 : dirty);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(confirm_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(confirm_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (confirm_slot_or_fallback) confirm_slot_or_fallback.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(66:12) {#if showConfirmButton}",
    		ctx
    	});

    	return block;
    }

    // (71:37)                     
    function fallback_block$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*confirmTitle*/ ctx[1]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*confirmTitle*/ 2) set_data_dev(t, /*confirmTitle*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$2.name,
    		type: "fallback",
    		source: "(71:37)                     ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$F(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*showDialog*/ ctx[0] && create_if_block$p(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*showDialog*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*showDialog*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$p(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PointerzModal', slots, ['title','description','cancel','confirm']);
    	let { confirmTitle = "Confirm" } = $$props;
    	let { cancelTitle = "Cancel" } = $$props;
    	let { color = "red" } = $$props;
    	let { canCancel = true } = $$props;

    	let { cancelFunction = () => {
    		
    	} } = $$props;

    	let { confirmFunction = () => {
    		
    	} } = $$props;

    	let { showConfirmButton = true } = $$props;
    	let { showDialog = false } = $$props;

    	function callConfirmFunction() {
    		Client.phaser.playSound("buttonClick");
    		let ret = confirmFunction();

    		if (ret) {
    			$$invalidate(0, showDialog = false);
    		}
    	}

    	function callCancelFunction() {
    		Client.phaser.playSound("cancelClick");
    		$$invalidate(0, showDialog = false);
    		cancelFunction();
    	}

    	const writable_props = [
    		'confirmTitle',
    		'cancelTitle',
    		'color',
    		'canCancel',
    		'cancelFunction',
    		'confirmFunction',
    		'showConfirmButton',
    		'showDialog'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PointerzModal> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('confirmTitle' in $$props) $$invalidate(1, confirmTitle = $$props.confirmTitle);
    		if ('cancelTitle' in $$props) $$invalidate(2, cancelTitle = $$props.cancelTitle);
    		if ('color' in $$props) $$invalidate(3, color = $$props.color);
    		if ('canCancel' in $$props) $$invalidate(4, canCancel = $$props.canCancel);
    		if ('cancelFunction' in $$props) $$invalidate(8, cancelFunction = $$props.cancelFunction);
    		if ('confirmFunction' in $$props) $$invalidate(9, confirmFunction = $$props.confirmFunction);
    		if ('showConfirmButton' in $$props) $$invalidate(5, showConfirmButton = $$props.showConfirmButton);
    		if ('showDialog' in $$props) $$invalidate(0, showDialog = $$props.showDialog);
    		if ('$$scope' in $$props) $$invalidate(10, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		fly,
    		fade,
    		confirmTitle,
    		cancelTitle,
    		color,
    		canCancel,
    		cancelFunction,
    		confirmFunction,
    		showConfirmButton,
    		showDialog,
    		callConfirmFunction,
    		callCancelFunction
    	});

    	$$self.$inject_state = $$props => {
    		if ('confirmTitle' in $$props) $$invalidate(1, confirmTitle = $$props.confirmTitle);
    		if ('cancelTitle' in $$props) $$invalidate(2, cancelTitle = $$props.cancelTitle);
    		if ('color' in $$props) $$invalidate(3, color = $$props.color);
    		if ('canCancel' in $$props) $$invalidate(4, canCancel = $$props.canCancel);
    		if ('cancelFunction' in $$props) $$invalidate(8, cancelFunction = $$props.cancelFunction);
    		if ('confirmFunction' in $$props) $$invalidate(9, confirmFunction = $$props.confirmFunction);
    		if ('showConfirmButton' in $$props) $$invalidate(5, showConfirmButton = $$props.showConfirmButton);
    		if ('showDialog' in $$props) $$invalidate(0, showDialog = $$props.showDialog);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		showDialog,
    		confirmTitle,
    		cancelTitle,
    		color,
    		canCancel,
    		showConfirmButton,
    		callConfirmFunction,
    		callCancelFunction,
    		cancelFunction,
    		confirmFunction,
    		$$scope,
    		slots
    	];
    }

    class PointerzModal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$F, create_fragment$F, safe_not_equal, {
    			confirmTitle: 1,
    			cancelTitle: 2,
    			color: 3,
    			canCancel: 4,
    			cancelFunction: 8,
    			confirmFunction: 9,
    			showConfirmButton: 5,
    			showDialog: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PointerzModal",
    			options,
    			id: create_fragment$F.name
    		});
    	}

    	get confirmTitle() {
    		throw new Error("<PointerzModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set confirmTitle(value) {
    		throw new Error("<PointerzModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cancelTitle() {
    		throw new Error("<PointerzModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cancelTitle(value) {
    		throw new Error("<PointerzModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<PointerzModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<PointerzModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get canCancel() {
    		throw new Error("<PointerzModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set canCancel(value) {
    		throw new Error("<PointerzModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cancelFunction() {
    		throw new Error("<PointerzModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cancelFunction(value) {
    		throw new Error("<PointerzModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get confirmFunction() {
    		throw new Error("<PointerzModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set confirmFunction(value) {
    		throw new Error("<PointerzModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showConfirmButton() {
    		throw new Error("<PointerzModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showConfirmButton(value) {
    		throw new Error("<PointerzModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showDialog() {
    		throw new Error("<PointerzModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showDialog(value) {
    		throw new Error("<PointerzModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\client\svelte\components\ui\PointerzConfirm.svelte generated by Svelte v3.50.1 */
    const file$C = "src\\client\\svelte\\components\\ui\\PointerzConfirm.svelte";
    const get_cancel_slot_changes = dirty => ({});
    const get_cancel_slot_context = ctx => ({ confirm: /*confirm*/ ctx[6] });
    const get_confirm_slot_changes = dirty => ({});
    const get_confirm_slot_context = ctx => ({ confirm: /*confirm*/ ctx[6] });
    const get_description_slot_changes = dirty => ({});
    const get_description_slot_context = ctx => ({ confirm: /*confirm*/ ctx[6] });
    const get_title_slot_changes = dirty => ({});
    const get_title_slot_context = ctx => ({ confirm: /*confirm*/ ctx[6] });
    const get_default_slot_changes$1 = dirty => ({});
    const get_default_slot_context$1 = ctx => ({ confirm: /*confirm*/ ctx[6] });

    // (42:0) {#if showDialog}
    function create_if_block$o(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let span0;
    	let t0;
    	let span1;
    	let t1;
    	let div1;
    	let button0;
    	let t2;
    	let button1;
    	let div2_class_value;
    	let div2_intro;
    	let div2_outro;
    	let div3_intro;
    	let div3_outro;
    	let current;
    	let mounted;
    	let dispose;
    	const title_slot_template = /*#slots*/ ctx[10].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[9], get_title_slot_context);
    	const title_slot_or_fallback = title_slot || fallback_block_2(ctx);
    	const description_slot_template = /*#slots*/ ctx[10].description;
    	const description_slot = create_slot(description_slot_template, ctx, /*$$scope*/ ctx[9], get_description_slot_context);
    	const confirm_slot_template = /*#slots*/ ctx[10].confirm;
    	const confirm_slot = create_slot(confirm_slot_template, ctx, /*$$scope*/ ctx[9], get_confirm_slot_context);
    	const confirm_slot_or_fallback = confirm_slot || fallback_block_1(ctx);
    	const cancel_slot_template = /*#slots*/ ctx[10].cancel;
    	const cancel_slot = create_slot(cancel_slot_template, ctx, /*$$scope*/ ctx[9], get_cancel_slot_context);
    	const cancel_slot_or_fallback = cancel_slot || fallback_block$1(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			span0 = element("span");
    			if (title_slot_or_fallback) title_slot_or_fallback.c();
    			t0 = space();
    			span1 = element("span");
    			if (description_slot) description_slot.c();
    			t1 = space();
    			div1 = element("div");
    			button0 = element("button");
    			if (confirm_slot_or_fallback) confirm_slot_or_fallback.c();
    			t2 = space();
    			button1 = element("button");
    			if (cancel_slot_or_fallback) cancel_slot_or_fallback.c();
    			attr_dev(span0, "class", "message-title svelte-1gc8w21");
    			add_location(span0, file$C, 58, 8, 1415);
    			attr_dev(span1, "class", "message-description svelte-1gc8w21");
    			add_location(span1, file$C, 62, 8, 1567);
    			attr_dev(div0, "class", "message-section");
    			add_location(div0, file$C, 57, 6, 1376);
    			attr_dev(button0, "class", "modal-button svelte-1gc8w21");
    			add_location(button0, file$C, 67, 8, 1710);
    			attr_dev(button1, "class", "modal-button cancel-button svelte-1gc8w21");
    			add_location(button1, file$C, 72, 8, 1876);
    			attr_dev(div1, "class", "actions svelte-1gc8w21");
    			add_location(div1, file$C, 66, 6, 1679);
    			attr_dev(div2, "class", div2_class_value = "" + (null_to_empty("confirm-dialog " + /*color*/ ctx[2]) + " svelte-1gc8w21"));
    			add_location(div2, file$C, 46, 4, 1164);
    			attr_dev(div3, "class", "overlay svelte-1gc8w21");
    			add_location(div3, file$C, 42, 2, 1053);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div0, span0);

    			if (title_slot_or_fallback) {
    				title_slot_or_fallback.m(span0, null);
    			}

    			append_dev(div0, t0);
    			append_dev(div0, span1);

    			if (description_slot) {
    				description_slot.m(span1, null);
    			}

    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, button0);

    			if (confirm_slot_or_fallback) {
    				confirm_slot_or_fallback.m(button0, null);
    			}

    			append_dev(div1, t2);
    			append_dev(div1, button1);

    			if (cancel_slot_or_fallback) {
    				cancel_slot_or_fallback.m(button1, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "mousedown", /*callFunction*/ ctx[4], false, false, false),
    					listen_dev(button1, "mousedown", /*callCancelFunction*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (title_slot) {
    				if (title_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[9], dirty, get_title_slot_changes),
    						get_title_slot_context
    					);
    				}
    			}

    			if (description_slot) {
    				if (description_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						description_slot,
    						description_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(description_slot_template, /*$$scope*/ ctx[9], dirty, get_description_slot_changes),
    						get_description_slot_context
    					);
    				}
    			}

    			if (confirm_slot) {
    				if (confirm_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						confirm_slot,
    						confirm_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(confirm_slot_template, /*$$scope*/ ctx[9], dirty, get_confirm_slot_changes),
    						get_confirm_slot_context
    					);
    				}
    			} else {
    				if (confirm_slot_or_fallback && confirm_slot_or_fallback.p && (!current || dirty & /*confirmTitle*/ 1)) {
    					confirm_slot_or_fallback.p(ctx, !current ? -1 : dirty);
    				}
    			}

    			if (cancel_slot) {
    				if (cancel_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						cancel_slot,
    						cancel_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(cancel_slot_template, /*$$scope*/ ctx[9], dirty, get_cancel_slot_changes),
    						get_cancel_slot_context
    					);
    				}
    			} else {
    				if (cancel_slot_or_fallback && cancel_slot_or_fallback.p && (!current || dirty & /*cancelTitle*/ 2)) {
    					cancel_slot_or_fallback.p(ctx, !current ? -1 : dirty);
    				}
    			}

    			if (!current || dirty & /*color*/ 4 && div2_class_value !== (div2_class_value = "" + (null_to_empty("confirm-dialog " + /*color*/ ctx[2]) + " svelte-1gc8w21"))) {
    				attr_dev(div2, "class", div2_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot_or_fallback, local);
    			transition_in(description_slot, local);
    			transition_in(confirm_slot_or_fallback, local);
    			transition_in(cancel_slot_or_fallback, local);

    			add_render_callback(() => {
    				if (div2_outro) div2_outro.end(1);
    				div2_intro = create_in_transition(div2, fly, { y: -10, delay: 200, duration: 200 });
    				div2_intro.start();
    			});

    			add_render_callback(() => {
    				if (div3_outro) div3_outro.end(1);
    				div3_intro = create_in_transition(div3, fade, { duration: 200 });
    				div3_intro.start();
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot_or_fallback, local);
    			transition_out(description_slot, local);
    			transition_out(confirm_slot_or_fallback, local);
    			transition_out(cancel_slot_or_fallback, local);
    			if (div2_intro) div2_intro.invalidate();
    			div2_outro = create_out_transition(div2, fly, { y: -10, duration: 200 });
    			if (div3_intro) div3_intro.invalidate();
    			div3_outro = create_out_transition(div3, fade, { delay: 200, duration: 200 });
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (title_slot_or_fallback) title_slot_or_fallback.d(detaching);
    			if (description_slot) description_slot.d(detaching);
    			if (confirm_slot_or_fallback) confirm_slot_or_fallback.d(detaching);
    			if (cancel_slot_or_fallback) cancel_slot_or_fallback.d(detaching);
    			if (detaching && div2_outro) div2_outro.end();
    			if (detaching && div3_outro) div3_outro.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$o.name,
    		type: "if",
    		source: "(42:0) {#if showDialog}",
    		ctx
    	});

    	return block;
    }

    // (61:13) Are you sure you want to perform this action?
    function fallback_block_2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Are you sure you want to perform this action?");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_2.name,
    		type: "fallback",
    		source: "(61:13) Are you sure you want to perform this action?",
    		ctx
    	});

    	return block;
    }

    // (69:31)               
    function fallback_block_1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*confirmTitle*/ ctx[0]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*confirmTitle*/ 1) set_data_dev(t, /*confirmTitle*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_1.name,
    		type: "fallback",
    		source: "(69:31)               ",
    		ctx
    	});

    	return block;
    }

    // (76:30)               
    function fallback_block$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*cancelTitle*/ ctx[1]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*cancelTitle*/ 2) set_data_dev(t, /*cancelTitle*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$1.name,
    		type: "fallback",
    		source: "(76:30)               ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$E(ctx) {
    	let t;
    	let if_block_anchor;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], get_default_slot_context$1);
    	let if_block = /*showDialog*/ ctx[3] && create_if_block$o(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, get_default_slot_changes$1),
    						get_default_slot_context$1
    					);
    				}
    			}

    			if (/*showDialog*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*showDialog*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$o(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PointerzConfirm', slots, ['default','title','description','confirm','cancel']);
    	let { confirmTitle = "Confirm" } = $$props;
    	let { cancelTitle = "Cancel" } = $$props;
    	let { color = "red" } = $$props;

    	let { cancelFunction = () => {
    		
    	} } = $$props;

    	let { showConfirm = true } = $$props;
    	let showDialog = false;
    	let functionToCall = { func: null, args: null };

    	function callFunction() {
    		Client$1.phaser.playSound("buttonClick");
    		$$invalidate(3, showDialog = false);
    		functionToCall["func"](...functionToCall["args"]);
    	}

    	function callCancelFunction() {
    		showConfirm && Client$1.phaser.playSound("cancelClick");
    		$$invalidate(3, showDialog = false);
    		cancelFunction();
    	}

    	function confirm(func, ...args) {
    		functionToCall = { func, args };
    		$$invalidate(3, showDialog = showConfirm);
    		!showConfirm && callCancelFunction();
    	}

    	const writable_props = ['confirmTitle', 'cancelTitle', 'color', 'cancelFunction', 'showConfirm'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PointerzConfirm> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('confirmTitle' in $$props) $$invalidate(0, confirmTitle = $$props.confirmTitle);
    		if ('cancelTitle' in $$props) $$invalidate(1, cancelTitle = $$props.cancelTitle);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('cancelFunction' in $$props) $$invalidate(7, cancelFunction = $$props.cancelFunction);
    		if ('showConfirm' in $$props) $$invalidate(8, showConfirm = $$props.showConfirm);
    		if ('$$scope' in $$props) $$invalidate(9, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		fly,
    		fade,
    		Client: Client$1,
    		confirmTitle,
    		cancelTitle,
    		color,
    		cancelFunction,
    		showConfirm,
    		showDialog,
    		functionToCall,
    		callFunction,
    		callCancelFunction,
    		confirm
    	});

    	$$self.$inject_state = $$props => {
    		if ('confirmTitle' in $$props) $$invalidate(0, confirmTitle = $$props.confirmTitle);
    		if ('cancelTitle' in $$props) $$invalidate(1, cancelTitle = $$props.cancelTitle);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('cancelFunction' in $$props) $$invalidate(7, cancelFunction = $$props.cancelFunction);
    		if ('showConfirm' in $$props) $$invalidate(8, showConfirm = $$props.showConfirm);
    		if ('showDialog' in $$props) $$invalidate(3, showDialog = $$props.showDialog);
    		if ('functionToCall' in $$props) functionToCall = $$props.functionToCall;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*showDialog*/ 8) {
    			// Play the warning window sound when the confirm dialog is shown
    			if (showDialog) {
    				Client$1.phaser.playSound("warningWindow");
    			}
    		}
    	};

    	return [
    		confirmTitle,
    		cancelTitle,
    		color,
    		showDialog,
    		callFunction,
    		callCancelFunction,
    		confirm,
    		cancelFunction,
    		showConfirm,
    		$$scope,
    		slots
    	];
    }

    class PointerzConfirm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$E, create_fragment$E, safe_not_equal, {
    			confirmTitle: 0,
    			cancelTitle: 1,
    			color: 2,
    			cancelFunction: 7,
    			showConfirm: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PointerzConfirm",
    			options,
    			id: create_fragment$E.name
    		});
    	}

    	get confirmTitle() {
    		throw new Error("<PointerzConfirm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set confirmTitle(value) {
    		throw new Error("<PointerzConfirm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cancelTitle() {
    		throw new Error("<PointerzConfirm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cancelTitle(value) {
    		throw new Error("<PointerzConfirm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<PointerzConfirm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<PointerzConfirm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cancelFunction() {
    		throw new Error("<PointerzConfirm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cancelFunction(value) {
    		throw new Error("<PointerzConfirm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showConfirm() {
    		throw new Error("<PointerzConfirm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showConfirm(value) {
    		throw new Error("<PointerzConfirm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\client\svelte\components\ui\Label.svelte generated by Svelte v3.50.1 */
    const file$B = "src\\client\\svelte\\components\\ui\\Label.svelte";

    // (7:2) {#if label}
    function create_if_block$n(ctx) {
    	let div1;
    	let div0;
    	let t;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t = text(/*label*/ ctx[0]);
    			attr_dev(div0, "class", "panelLabel svelte-1jxn9rj");
    			add_location(div0, file$B, 8, 6, 213);
    			set_style(div1, "margin-bottom", css.default.margin + "px");
    			add_location(div1, file$B, 7, 4, 154);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 1) set_data_dev(t, /*label*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$n.name,
    		type: "if",
    		source: "(7:2) {#if label}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$D(ctx) {
    	let div;
    	let t;
    	let div_class_value;
    	let current;
    	let if_block = /*label*/ ctx[0] && create_if_block$n(ctx);
    	const default_slot_template = /*#slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*label*/ ctx[0] ? "inputLabelContainer" : "") + " svelte-1jxn9rj"));
    			add_location(div, file$B, 5, 0, 85);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*label*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$n(ctx);
    					if_block.c();
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[1],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*label*/ 1 && div_class_value !== (div_class_value = "" + (null_to_empty(/*label*/ ctx[0] ? "inputLabelContainer" : "") + " svelte-1jxn9rj"))) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Label', slots, ['default']);
    	let { label } = $$props;
    	const writable_props = ['label'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Label> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('label' in $$props) $$invalidate(0, label = $$props.label);
    		if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ css, label });

    	$$self.$inject_state = $$props => {
    		if ('label' in $$props) $$invalidate(0, label = $$props.label);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [label, $$scope, slots];
    }

    class Label extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$D, create_fragment$D, safe_not_equal, { label: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Label",
    			options,
    			id: create_fragment$D.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*label*/ ctx[0] === undefined && !('label' in props)) {
    			console.warn("<Label> was created without expected prop 'label'");
    		}
    	}

    	get label() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\client\svelte\components\ui\PointerzInput.svelte generated by Svelte v3.50.1 */
    const file$A = "src\\client\\svelte\\components\\ui\\PointerzInput.svelte";

    // (38:27) 
    function create_if_block_2$7(ctx) {
    	let input;
    	let input_class_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "type", "mail");
    			attr_dev(input, "placeholder", /*placeholder*/ ctx[2]);
    			attr_dev(input, "maxlength", /*maxlength*/ ctx[1]);
    			attr_dev(input, "class", input_class_value = "pointerzInput " + (/*editorInput*/ ctx[4] && 'editorInput') + " svelte-14d4crg");
    			set_style(input, "margin-bottom", css.default.margin + "px");
    			add_location(input, file$A, 38, 4, 1082);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*value*/ ctx[0]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler_2*/ ctx[9]),
    					listen_dev(input, "change", /*forwardChangeEvent*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*placeholder*/ 4) {
    				attr_dev(input, "placeholder", /*placeholder*/ ctx[2]);
    			}

    			if (dirty & /*maxlength*/ 2) {
    				attr_dev(input, "maxlength", /*maxlength*/ ctx[1]);
    			}

    			if (dirty & /*editorInput*/ 16 && input_class_value !== (input_class_value = "pointerzInput " + (/*editorInput*/ ctx[4] && 'editorInput') + " svelte-14d4crg")) {
    				attr_dev(input, "class", input_class_value);
    			}

    			if (dirty & /*value*/ 1) {
    				set_input_value(input, /*value*/ ctx[0]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(38:27) ",
    		ctx
    	});

    	return block;
    }

    // (29:31) 
    function create_if_block_1$c(ctx) {
    	let input;
    	let input_class_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "type", "password");
    			attr_dev(input, "placeholder", /*placeholder*/ ctx[2]);
    			attr_dev(input, "maxlength", /*maxlength*/ ctx[1]);
    			attr_dev(input, "class", input_class_value = "pointerzInput " + (/*editorInput*/ ctx[4] && 'editorInput') + " svelte-14d4crg");
    			set_style(input, "margin-bottom", css.default.margin + "px");
    			add_location(input, file$A, 29, 4, 806);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*value*/ ctx[0]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler_1*/ ctx[8]),
    					listen_dev(input, "change", /*forwardChangeEvent*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*placeholder*/ 4) {
    				attr_dev(input, "placeholder", /*placeholder*/ ctx[2]);
    			}

    			if (dirty & /*maxlength*/ 2) {
    				attr_dev(input, "maxlength", /*maxlength*/ ctx[1]);
    			}

    			if (dirty & /*editorInput*/ 16 && input_class_value !== (input_class_value = "pointerzInput " + (/*editorInput*/ ctx[4] && 'editorInput') + " svelte-14d4crg")) {
    				attr_dev(input, "class", input_class_value);
    			}

    			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
    				set_input_value(input, /*value*/ ctx[0]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$c.name,
    		type: "if",
    		source: "(29:31) ",
    		ctx
    	});

    	return block;
    }

    // (20:2) {#if type == "text"}
    function create_if_block$m(ctx) {
    	let input;
    	let input_class_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "placeholder", /*placeholder*/ ctx[2]);
    			attr_dev(input, "maxlength", /*maxlength*/ ctx[1]);
    			attr_dev(input, "class", input_class_value = "pointerzInput " + (/*editorInput*/ ctx[4] && 'editorInput') + " svelte-14d4crg");
    			set_style(input, "margin-bottom", css.default.margin + "px");
    			add_location(input, file$A, 20, 4, 530);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*value*/ ctx[0]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(input, "change", /*forwardChangeEvent*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*placeholder*/ 4) {
    				attr_dev(input, "placeholder", /*placeholder*/ ctx[2]);
    			}

    			if (dirty & /*maxlength*/ 2) {
    				attr_dev(input, "maxlength", /*maxlength*/ ctx[1]);
    			}

    			if (dirty & /*editorInput*/ 16 && input_class_value !== (input_class_value = "pointerzInput " + (/*editorInput*/ ctx[4] && 'editorInput') + " svelte-14d4crg")) {
    				attr_dev(input, "class", input_class_value);
    			}

    			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
    				set_input_value(input, /*value*/ ctx[0]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$m.name,
    		type: "if",
    		source: "(20:2) {#if type == \\\"text\\\"}",
    		ctx
    	});

    	return block;
    }

    // (19:0) <Label {label}>
    function create_default_slot$c(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*type*/ ctx[3] == "text") return create_if_block$m;
    		if (/*type*/ ctx[3] == "password") return create_if_block_1$c;
    		if (/*type*/ ctx[3] == "mail") return create_if_block_2$7;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type && current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) {
    				if_block.d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$c.name,
    		type: "slot",
    		source: "(19:0) <Label {label}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$C(ctx) {
    	let label_1;
    	let current;

    	label_1 = new Label({
    			props: {
    				label: /*label*/ ctx[5],
    				$$slots: { default: [create_default_slot$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(label_1.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(label_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const label_1_changes = {};
    			if (dirty & /*label*/ 32) label_1_changes.label = /*label*/ ctx[5];

    			if (dirty & /*$$scope, placeholder, maxlength, editorInput, value, type*/ 2079) {
    				label_1_changes.$$scope = { dirty, ctx };
    			}

    			label_1.$set(label_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(label_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PointerzInput', slots, []);
    	const dispatch = createEventDispatcher();

    	function forwardChangeEvent(event) {
    		dispatch("change", { value: event.target.value });
    	}

    	let { value = "" } = $$props;
    	let { maxlength = 100 } = $$props;
    	let { placeholder = undefined } = $$props;
    	let { type = "text" } = $$props;
    	let { editorInput = false } = $$props;
    	let { label } = $$props;
    	const writable_props = ['value', 'maxlength', 'placeholder', 'type', 'editorInput', 'label'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PointerzInput> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		value = this.value;
    		$$invalidate(0, value);
    	}

    	function input_input_handler_1() {
    		value = this.value;
    		$$invalidate(0, value);
    	}

    	function input_input_handler_2() {
    		value = this.value;
    		$$invalidate(0, value);
    	}

    	$$self.$$set = $$props => {
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    		if ('maxlength' in $$props) $$invalidate(1, maxlength = $$props.maxlength);
    		if ('placeholder' in $$props) $$invalidate(2, placeholder = $$props.placeholder);
    		if ('type' in $$props) $$invalidate(3, type = $$props.type);
    		if ('editorInput' in $$props) $$invalidate(4, editorInput = $$props.editorInput);
    		if ('label' in $$props) $$invalidate(5, label = $$props.label);
    	};

    	$$self.$capture_state = () => ({
    		css,
    		createEventDispatcher,
    		Label,
    		dispatch,
    		forwardChangeEvent,
    		value,
    		maxlength,
    		placeholder,
    		type,
    		editorInput,
    		label
    	});

    	$$self.$inject_state = $$props => {
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    		if ('maxlength' in $$props) $$invalidate(1, maxlength = $$props.maxlength);
    		if ('placeholder' in $$props) $$invalidate(2, placeholder = $$props.placeholder);
    		if ('type' in $$props) $$invalidate(3, type = $$props.type);
    		if ('editorInput' in $$props) $$invalidate(4, editorInput = $$props.editorInput);
    		if ('label' in $$props) $$invalidate(5, label = $$props.label);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		value,
    		maxlength,
    		placeholder,
    		type,
    		editorInput,
    		label,
    		forwardChangeEvent,
    		input_input_handler,
    		input_input_handler_1,
    		input_input_handler_2
    	];
    }

    class PointerzInput extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$C, create_fragment$C, safe_not_equal, {
    			value: 0,
    			maxlength: 1,
    			placeholder: 2,
    			type: 3,
    			editorInput: 4,
    			label: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PointerzInput",
    			options,
    			id: create_fragment$C.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*label*/ ctx[5] === undefined && !('label' in props)) {
    			console.warn("<PointerzInput> was created without expected prop 'label'");
    		}
    	}

    	get value() {
    		throw new Error("<PointerzInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<PointerzInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get maxlength() {
    		throw new Error("<PointerzInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set maxlength(value) {
    		throw new Error("<PointerzInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<PointerzInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<PointerzInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<PointerzInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<PointerzInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get editorInput() {
    		throw new Error("<PointerzInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set editorInput(value) {
    		throw new Error("<PointerzInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<PointerzInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<PointerzInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, basedir, module) {
    	return module = {
    	  path: basedir,
    	  exports: {},
    	  require: function (path, base) {
          return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
        }
    	}, fn(module, module.exports), module.exports;
    }

    function getCjsExportFromNamespace (n) {
    	return n && n['default'] || n;
    }

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
    }

    var Messenger_1 = createCommonjsModule(function (module, exports) {
    /* eslint-disable no-undef */
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Messenger = void 0;
    function getError(e) {
        if (typeof e !== "object")
            return e;
        if (e.message)
            return e.message;
        // console.debug("unknown kondor error");
        // console.debug(e);
        return "unknown kondor error";
    }
    async function sleep(ms) {
        return new Promise((r) => setTimeout(r, ms));
    }
    class Messenger {
        constructor(opts) {
            this.listeners = [];
            this.onExtensionRequest = () => Promise.resolve();
            this.onDomRequest = () => Promise.resolve();
            if (!opts)
                return;
            if (opts.onExtensionRequest) {
                this.onExtensionRequest = opts.onExtensionRequest;
                const listener = async (data, sender, res) => {
                    res();
                    const { id, command } = data;
                    // check if it is a MessageRequest
                    if (!command)
                        return;
                    const message = { id };
                    // console.debug("incoming request", id, ":", command);
                    // console.debug((data as MessageRequest).args);
                    try {
                        const result = await this.onExtensionRequest(data, id, sender);
                        // check if other process will send the response
                        if (typeof result === "object" &&
                            result !== null &&
                            result._derived) {
                            // console.debug("response", id, "derived");
                            return;
                        }
                        message.result = result;
                    }
                    catch (error) {
                        message.error = error.message;
                    }
                    if (typeof message.result === "undefined" && !message.error)
                        return;
                    this.sendResponse("extension", message, sender);
                };
                this.listeners.push({ type: "extension", id: "onRequest", listener });
                chrome.runtime.onMessage.addListener(listener);
            }
            if (opts.onDomRequest) {
                this.onDomRequest = opts.onDomRequest;
                const listener = async (event) => {
                    const { id, command } = event.data;
                    // check if it is a MessageRequest
                    if (!command)
                        return;
                    const message = { id };
                    // console.debug("incoming request", id, ":", command);
                    // console.debug((event.data as MessageRequest).args);
                    try {
                        const result = await this.onDomRequest(event, id);
                        // check if other process will send the response
                        if (typeof result === "object" &&
                            result !== null &&
                            result._derived) {
                            // console.debug("response", id, "derived");
                            return;
                        }
                        message.result = result;
                    }
                    catch (error) {
                        message.error = error.message;
                    }
                    if (typeof message.result === "undefined" && !message.error)
                        return;
                    this.sendResponse("dom", message);
                };
                this.listeners.push({ type: "dom", id: "onRequest", listener });
                window.addEventListener("message", listener);
            }
        }
        sendResponse(type, message, sender) {
            // console.debug("outgoing response", message.id, ":");
            // console.debug(message);
            if (type === "dom")
                window.postMessage(message, "*");
            else {
                if (sender && sender.tab)
                    chrome.tabs.sendMessage(sender.tab.id, message);
                else
                    chrome.runtime.sendMessage(message);
            }
        }
        async sendDomMessage(to, command, args) {
            const reqId = crypto.randomUUID();
            return new Promise((resolve, reject) => {
                // prepare the listener
                const listener = (event) => {
                    // ignore requests
                    if (event.data.command)
                        return;
                    const { id, result, error } = event.data;
                    // ignore different ids
                    if (id !== reqId)
                        return;
                    // send response
                    if (error) {
                        // console.debug("error received", id, ":");
                        // console.debug(getError(error));
                        reject(new Error(getError(error)));
                    }
                    else {
                        // console.debug("response received", id, ":");
                        // console.debug(result);
                        resolve(result);
                    }
                    this.removeListener(reqId);
                };
                // listen
                this.listeners.push({ type: "dom", id: reqId, listener });
                window.addEventListener("message", listener);
                // send request
                window.postMessage({
                    id: reqId,
                    command,
                    args: args ? JSON.parse(JSON.stringify(args)) : args,
                    to,
                }, "*");
                // console.debug("sending message", reqId, command, "to dom");
                // console.debug(args);
            });
        }
        async sendExtensionMessage(to, command, args, opts) {
            const reqId = crypto.randomUUID();
            return new Promise((resolve, reject) => {
                // prepare the listener
                const listener = (data, _sender, res) => {
                    res();
                    // ignore requests
                    if (data.command)
                        return;
                    const { id, result, error } = data;
                    // ignore different ids
                    if (id !== reqId)
                        return;
                    // send response
                    if (error) {
                        // console.debug("error received", id, ":");
                        // console.debug(getError(error));
                        reject(new Error(getError(error)));
                    }
                    else {
                        // console.debug("response received", id, ":");
                        // console.debug(result);
                        resolve(result);
                    }
                    this.removeListener(reqId);
                };
                // listen
                this.listeners.push({ type: "extension", id: reqId, listener });
                chrome.runtime.onMessage.addListener(listener);
                // send request
                const sendMessage = () => {
                    if (["popup", "background"].includes(to)) {
                        chrome.runtime.sendMessage({
                            id: reqId,
                            command,
                            args: args ? JSON.parse(JSON.stringify(args)) : args,
                            to,
                        });
                    }
                    else {
                        // 'to' is tab.id
                        chrome.tabs.sendMessage(to, {
                            id: reqId,
                            command,
                            args: args ? JSON.parse(JSON.stringify(args)) : args,
                            to,
                        });
                    }
                    // console.debug("sending message", reqId, command, "to", to);
                    // console.debug(args);
                };
                sendMessage();
                // define timeout
                if (opts && opts.timeout) {
                    setTimeout(() => {
                        reject(new Error("Connection lost"));
                        this.removeListener(reqId);
                    }, opts.timeout);
                }
                // ping
                if (opts && opts.ping) {
                    (async () => {
                        let retries = (opts === null || opts === void 0 ? void 0 : opts.retries) || 0;
                        await sleep(1000);
                        while (this.listeners.find((l) => l.id === reqId)) {
                            try {
                                await this.sendExtensionMessage(to, "ping", { id: reqId, to }, { timeout: (opts === null || opts === void 0 ? void 0 : opts.pingTimeout) || 80 });
                                await sleep(1000);
                            }
                            catch (error) {
                                if (retries <= 0) {
                                    reject(error);
                                    this.removeListener(reqId);
                                    break;
                                }
                                retries -= 1;
                                console.log(`retrying ${reqId}. remaining retries: ${retries}`);
                                sendMessage();
                                await sleep(100);
                            }
                        }
                    })()
                        .then(() => { })
                        .catch((e) => {
                        console.log("ping error:");
                        console.log(e);
                    });
                }
            });
        }
        removeListener(id) {
            const index = this.listeners.findIndex((l) => l.id === id);
            if (index < 0)
                return;
            const removed = this.listeners.splice(index, 1);
            const { listener, type } = removed[0];
            if (type === "dom") {
                window.removeEventListener("message", listener);
            }
            else {
                chrome.runtime.onMessage.removeListener(listener);
            }
        }
        removeListeners() {
            this.listeners.forEach((l) => {
                const { type, listener } = l;
                if (type === "dom") {
                    window.removeEventListener("message", listener);
                }
                else {
                    chrome.runtime.onMessage.removeListener(listener);
                }
            });
            this.listeners = [];
        }
    }
    exports.default = Messenger;
    exports.Messenger = Messenger;

    });

    var name = "kondor-js";
    var version = "1.1.0";
    var description = "Kondor Library";
    var author = "Julian Gonzalez";
    var repository = {
    	url: "https://github.com/joticajulian/kondor-js.git"
    };
    var homepage = "https://github.com/joticajulian/kondor-js.git";
    var bugs = {
    	url: "https://github.com/joticajulian/kondor-js/issues"
    };
    var files = [
    	"lib",
    	"dist",
    	"src"
    ];
    var main = "./lib/browser/src/index.js";
    var types = "./lib/browser/src/index.d.ts";
    var browser = "./lib/browser/src/index.js";
    var scripts = {
    	build: "rimraf lib/browser && tsc -p tsconfig.browser.json",
    	bundle: "yarn bundle:no-min && yarn bundle:min && yarn testfiles",
    	"bundle:min": "webpack --mode=production --config webpack.prod.config.js",
    	"bundle:no-min": "webpack --mode=production --config webpack.dev.config.js",
    	lint: "yarn lint:prettier && yarn lint:eslint && yarn lint:tsc",
    	"lint:prettier": "prettier . --check",
    	"lint:eslint": "eslint . --ext .js,.ts",
    	"lint:tsc": "tsc --noEmit --incremental false",
    	prerelease: "yarn bundle && yarn build",
    	serve: "node test/server.js",
    	testfiles: "copyfiles -u 3 node_modules/koilib/dist/koinos.min.js test/js && copyfiles -u 1 dist/kondor.min.js test/js"
    };
    var exports$1 = {
    	"./package.json": "./package.json",
    	".": "./lib/browser/src/index.js"
    };
    var dependencies = {
    	multibase: "^4.0.6"
    };
    var devDependencies = {
    	"@tsconfig/node12": "^1.0.11",
    	"@types/chrome": "^0.0.195",
    	"@typescript-eslint/eslint-plugin": "^5.35.1",
    	"@typescript-eslint/parser": "^5.35.1",
    	copyfiles: "^2.4.1",
    	eslint: "^8.22.0",
    	"eslint-config-airbnb-typescript": "^17.0.0",
    	"eslint-config-prettier": "^8.3.0",
    	"eslint-plugin-import": "^2.25.4",
    	"eslint-plugin-prettier": "^4.2.1",
    	"eslint-plugin-tsdoc": "^0.2.16",
    	fastify: "^3.26.0",
    	"fastify-static": "^4.5.0",
    	koilib: "^7.0.0",
    	prettier: "^2.7.1",
    	rimraf: "^3.0.2",
    	"ts-loader": "~8.2.0",
    	typescript: "4.5.4",
    	webpack: "^5.88.2",
    	"webpack-cli": "^5.1.4"
    };
    var _package = {
    	name: name,
    	version: version,
    	description: description,
    	author: author,
    	repository: repository,
    	homepage: homepage,
    	bugs: bugs,
    	files: files,
    	main: main,
    	types: types,
    	browser: browser,
    	scripts: scripts,
    	exports: exports$1,
    	dependencies: dependencies,
    	devDependencies: devDependencies
    };

    var _package$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        name: name,
        version: version,
        description: description,
        author: author,
        repository: repository,
        homepage: homepage,
        bugs: bugs,
        files: files,
        main: main,
        types: types,
        browser: browser,
        scripts: scripts,
        exports: exports$1,
        dependencies: dependencies,
        devDependencies: devDependencies,
        'default': _package
    });

    var require$$0 = getCjsExportFromNamespace(_package$1);

    var constants$1 = createCommonjsModule(function (module, exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    });
    var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.kondorVersion = void 0;
    const packageJson = __importStar(require$$0);
    exports.kondorVersion = packageJson.version;

    });

    var provider = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.provider = exports.getProvider = void 0;


    const messenger = new Messenger_1.Messenger({});
    function getProvider(network) {
        return {
            rpcNodes: [],
            onError: () => true,
            currentNodeId: 0,
            async call(method, params) {
                return messenger.sendDomMessage("background", "provider:call", {
                    network,
                    method,
                    params,
                    kondorVersion: constants$1.kondorVersion,
                });
            },
            async getNonce(account) {
                return messenger.sendDomMessage("background", "provider:getNonce", {
                    network,
                    account,
                    kondorVersion: constants$1.kondorVersion,
                });
            },
            async getNextNonce(account) {
                return messenger.sendDomMessage("background", "provider:getNextNonce", {
                    network,
                    account,
                    kondorVersion: constants$1.kondorVersion,
                });
            },
            async getAccountRc(account) {
                return messenger.sendDomMessage("background", "provider:getAccountRc", {
                    network,
                    account,
                    kondorVersion: constants$1.kondorVersion,
                });
            },
            async getTransactionsById(transactionIds) {
                return messenger.sendDomMessage("background", "provider:getTransactionsById", {
                    network,
                    transactionIds,
                    kondorVersion: constants$1.kondorVersion,
                });
            },
            async getBlocksById(blockIds, opts) {
                return messenger.sendDomMessage("background", "provider:getBlocksById", {
                    network,
                    blockIds,
                    opts,
                    kondorVersion: constants$1.kondorVersion,
                });
            },
            async getHeadInfo() {
                return messenger.sendDomMessage("background", "provider:getHeadInfo", {
                    network,
                    kondorVersion: constants$1.kondorVersion,
                });
            },
            async getChainId() {
                return messenger.sendDomMessage("background", "provider:getChainId", {
                    network,
                    kondorVersion: constants$1.kondorVersion,
                });
            },
            async getBlocks(height, numBlocks, idRef, opts) {
                return messenger.sendDomMessage("background", "provider:getBlocks", {
                    network,
                    height,
                    numBlocks,
                    idRef,
                    opts,
                    kondorVersion: constants$1.kondorVersion,
                });
            },
            getBlock(height, opts) {
                return messenger.sendDomMessage("background", "provider:getBlock", {
                    network,
                    height,
                    opts,
                    kondorVersion: constants$1.kondorVersion,
                });
            },
            async wait(txId, type, timeout) {
                return messenger.sendDomMessage("background", "provider:wait", {
                    network,
                    txId,
                    type,
                    timeout,
                    kondorVersion: constants$1.kondorVersion,
                });
            },
            async sendTransaction(transaction, broadcast) {
                const response = await messenger.sendDomMessage("background", "provider:sendTransaction", {
                    network,
                    transaction,
                    broadcast,
                    kondorVersion: constants$1.kondorVersion,
                });
                transaction.id = response.transaction.id;
                transaction.header = response.transaction.header;
                transaction.operations = response.transaction.operations;
                transaction.signatures = response.transaction.signatures;
                transaction.wait = async (type = "byBlock", timeout = 60000) => {
                    return messenger.sendDomMessage("background", "provider:wait", {
                        network,
                        txId: transaction.id,
                        type,
                        timeout,
                        kondorVersion: constants$1.kondorVersion,
                    });
                };
                return {
                    transaction: transaction,
                    receipt: response.receipt,
                };
            },
            async submitBlock(block) {
                return messenger.sendDomMessage("background", "provider:submitBlock", {
                    network,
                    block,
                    kondorVersion: constants$1.kondorVersion,
                });
            },
            async readContract(operation) {
                return messenger.sendDomMessage("background", "provider:readContract", {
                    network,
                    operation,
                    kondorVersion: constants$1.kondorVersion,
                });
            },
            async getForkHeads() {
                return messenger.sendDomMessage("background", "provider:getForkHeads", {
                    network,
                    kondorVersion: constants$1.kondorVersion,
                });
            },
            async getResourceLimits() {
                return messenger.sendDomMessage("background", "provider:getResourceLimits", {
                    network,
                    kondorVersion: constants$1.kondorVersion,
                });
            },
            async invokeSystemCall(serializer, nameOrId, args, callerData) {
                return messenger.sendDomMessage("background", "provider:invokeSystemCall", {
                    network,
                    serializer,
                    nameOrId,
                    args,
                    callerData,
                    kondorVersion: constants$1.kondorVersion,
                });
            },
            async invokeGetContractMetadata(contractId) {
                return messenger.sendDomMessage("background", "provider:getResourceLimits", {
                    network,
                    contractId,
                    kondorVersion: constants$1.kondorVersion,
                });
            },
        };
    }
    exports.getProvider = getProvider;
    exports.provider = getProvider();
    exports.default = exports.provider;

    });

    // base-x encoding / decoding
    // Copyright (c) 2018 base-x contributors
    // Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
    // Distributed under the MIT software license, see the accompanying
    // file LICENSE or http://www.opensource.org/licenses/mit-license.php.
    function base$2 (ALPHABET) {
      if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
      var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
      function encode (source) {
        if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }
        if (source.length === 0) { return '' }
            // Skip & count leading zeroes.
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
            // Allocate enough space in big-endian base58 representation.
        var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
        var b58 = new Uint8Array(size);
            // Process the bytes.
        while (pbegin !== pend) {
          var carry = source[pbegin];
                // Apply "b58 = b58 * 256 + ch".
          var i = 0;
          for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
            carry += (256 * b58[it1]) >>> 0;
            b58[it1] = (carry % BASE) >>> 0;
            carry = (carry / BASE) >>> 0;
          }
          if (carry !== 0) { throw new Error('Non-zero carry') }
          length = i;
          pbegin++;
        }
            // Skip leading zeroes in base58 result.
        var it2 = size - length;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
            // Translate the result into a string.
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }
        return str
      }
      function decodeUnsafe (source) {
        if (typeof source !== 'string') { throw new TypeError('Expected String') }
        if (source.length === 0) { return new Uint8Array() }
        var psz = 0;
            // Skip leading spaces.
        if (source[psz] === ' ') { return }
            // Skip and count leading '1's.
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
            // Allocate enough space in big-endian base256 representation.
        var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.
        var b256 = new Uint8Array(size);
            // Process the characters.
        while (source[psz]) {
                // Decode character
          var carry = BASE_MAP[source.charCodeAt(psz)];
                // Invalid character
          if (carry === 255) { return }
          var i = 0;
          for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
            carry += (BASE * b256[it3]) >>> 0;
            b256[it3] = (carry % 256) >>> 0;
            carry = (carry / 256) >>> 0;
          }
          if (carry !== 0) { throw new Error('Non-zero carry') }
          length = i;
          psz++;
        }
            // Skip trailing spaces.
        if (source[psz] === ' ') { return }
            // Skip leading zeroes in b256.
        var it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j = zeroes;
        while (it4 !== size) {
          vch[j++] = b256[it4++];
        }
        return vch
      }
      function decode (string) {
        var buffer = decodeUnsafe(string);
        if (buffer) { return buffer }
        throw new Error('Non-base' + BASE + ' character')
      }
      return {
        encode: encode,
        decodeUnsafe: decodeUnsafe,
        decode: decode
      }
    }
    var src$2 = base$2;

    const textDecoder = new TextDecoder();
    /**
     * @param {ArrayBufferView|ArrayBuffer} bytes
     * @returns {string}
     */
    const decodeText$1 = (bytes) => textDecoder.decode(bytes);

    const textEncoder = new TextEncoder();
    /**
     * @param {string} text
     * @returns {Uint8Array}
     */
    const encodeText$2 = (text) => textEncoder.encode(text);

    /**
     * Returns a new Uint8Array created by concatenating the passed Arrays
     *
     * @param {Array<ArrayLike<number>>} arrs
     * @param {number} length
     * @returns {Uint8Array}
     */
    function concat (arrs, length) {
      const output = new Uint8Array(length);
      let offset = 0;

      for (const arr of arrs) {
        output.set(arr, offset);
        offset += arr.length;
      }

      return output
    }

    var util = { decodeText: decodeText$1, encodeText: encodeText$2, concat };

    const { encodeText: encodeText$1 } = util;

    /** @typedef {import('./types').CodecFactory} CodecFactory */
    /** @typedef {import("./types").BaseName} BaseName */
    /** @typedef {import("./types").BaseCode} BaseCode */

    /**
     * Class to encode/decode in the supported Bases
     *
     */
    class Base {
      /**
       * @param {BaseName} name
       * @param {BaseCode} code
       * @param {CodecFactory} factory
       * @param {string} alphabet
       */
      constructor (name, code, factory, alphabet) {
        this.name = name;
        this.code = code;
        this.codeBuf = encodeText$1(this.code);
        this.alphabet = alphabet;
        this.codec = factory(alphabet);
      }

      /**
       * @param {Uint8Array} buf
       * @returns {string}
       */
      encode (buf) {
        return this.codec.encode(buf)
      }

      /**
       * @param {string} string
       * @returns {Uint8Array}
       */
      decode (string) {
        for (const char of string) {
          if (this.alphabet && this.alphabet.indexOf(char) < 0) {
            throw new Error(`invalid character '${char}' in '${string}'`)
          }
        }
        return this.codec.decode(string)
      }
    }

    var base$1 = Base;

    /** @typedef {import('./types').CodecFactory} CodecFactory */

    /**
     * @param {string} string
     * @param {string} alphabet
     * @param {number} bitsPerChar
     * @returns {Uint8Array}
     */
    const decode$1 = (string, alphabet, bitsPerChar) => {
      // Build the character lookup table:
      /** @type {Record<string, number>} */
      const codes = {};
      for (let i = 0; i < alphabet.length; ++i) {
        codes[alphabet[i]] = i;
      }

      // Count the padding bytes:
      let end = string.length;
      while (string[end - 1] === '=') {
        --end;
      }

      // Allocate the output:
      const out = new Uint8Array((end * bitsPerChar / 8) | 0);

      // Parse the data:
      let bits = 0; // Number of bits currently in the buffer
      let buffer = 0; // Bits waiting to be written out, MSB first
      let written = 0; // Next byte to write
      for (let i = 0; i < end; ++i) {
        // Read one character from the string:
        const value = codes[string[i]];
        if (value === undefined) {
          throw new SyntaxError('Invalid character ' + string[i])
        }

        // Append the bits to the buffer:
        buffer = (buffer << bitsPerChar) | value;
        bits += bitsPerChar;

        // Write out some bits if the buffer has a byte's worth:
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 0xff & (buffer >> bits);
        }
      }

      // Verify that we have received just enough bits:
      if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {
        throw new SyntaxError('Unexpected end of data')
      }

      return out
    };

    /**
     * @param {Uint8Array} data
     * @param {string} alphabet
     * @param {number} bitsPerChar
     * @returns {string}
     */
    const encode$1 = (data, alphabet, bitsPerChar) => {
      const pad = alphabet[alphabet.length - 1] === '=';
      const mask = (1 << bitsPerChar) - 1;
      let out = '';

      let bits = 0; // Number of bits currently in the buffer
      let buffer = 0; // Bits waiting to be written out, MSB first
      for (let i = 0; i < data.length; ++i) {
        // Slurp data into the buffer:
        buffer = (buffer << 8) | data[i];
        bits += 8;

        // Write out as much as we can:
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet[mask & (buffer >> bits)];
        }
      }

      // Partial character:
      if (bits) {
        out += alphabet[mask & (buffer << (bitsPerChar - bits))];
      }

      // Add padding characters until we hit a byte boundary:
      if (pad) {
        while ((out.length * bitsPerChar) & 7) {
          out += '=';
        }
      }

      return out
    };

    /**
     * RFC4648 Factory
     *
     * @param {number} bitsPerChar
     * @returns {CodecFactory}
     */
    const rfc4648$1 = (bitsPerChar) => (alphabet) => {
      return {
        /**
         * @param {Uint8Array} input
         * @returns {string}
         */
        encode (input) {
          return encode$1(input, alphabet, bitsPerChar)
        },
        /**
         * @param {string} input
         * @returns {Uint8Array}
         */
        decode (input) {
          return decode$1(input, alphabet, bitsPerChar)
        }
      }
    };

    var rfc4648_1 = { rfc4648: rfc4648$1 };

    const { rfc4648 } = rfc4648_1;
    const { decodeText, encodeText } = util;

    /** @typedef {import('./types').CodecFactory} CodecFactory */
    /** @typedef {import('./types').Codec} Codec */
    /** @typedef {import('./types').BaseName} BaseName */
    /** @typedef {import('./types').BaseCode} BaseCode */

    /** @type {CodecFactory} */
    const identity = () => {
      return {
        encode: decodeText,
        decode: encodeText
      }
    };

    /**
     *
     * name, code, implementation, alphabet
     *
     * @type {Array<[BaseName, BaseCode, CodecFactory, string]>}
     */
    const constants = [
      ['identity', '\x00', identity, ''],
      ['base2', '0', rfc4648(1), '01'],
      ['base8', '7', rfc4648(3), '01234567'],
      ['base10', '9', src$2, '0123456789'],
      ['base16', 'f', rfc4648(4), '0123456789abcdef'],
      ['base16upper', 'F', rfc4648(4), '0123456789ABCDEF'],
      ['base32hex', 'v', rfc4648(5), '0123456789abcdefghijklmnopqrstuv'],
      ['base32hexupper', 'V', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV'],
      ['base32hexpad', 't', rfc4648(5), '0123456789abcdefghijklmnopqrstuv='],
      ['base32hexpadupper', 'T', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV='],
      ['base32', 'b', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567'],
      ['base32upper', 'B', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'],
      ['base32pad', 'c', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567='],
      ['base32padupper', 'C', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567='],
      ['base32z', 'h', rfc4648(5), 'ybndrfg8ejkmcpqxot1uwisza345h769'],
      ['base36', 'k', src$2, '0123456789abcdefghijklmnopqrstuvwxyz'],
      ['base36upper', 'K', src$2, '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'],
      ['base58btc', 'z', src$2, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],
      ['base58flickr', 'Z', src$2, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],
      ['base64', 'm', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],
      ['base64pad', 'M', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],
      ['base64url', 'u', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],
      ['base64urlpad', 'U', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']
    ];

    /** @type {Record<BaseName,Base>} */
    const names = constants.reduce((prev, tupple) => {
      prev[tupple[0]] = new base$1(tupple[0], tupple[1], tupple[2], tupple[3]);
      return prev
    }, /** @type {Record<BaseName,Base>} */({}));

    /** @type {Record<BaseCode,Base>} */
    const codes = constants.reduce((prev, tupple) => {
      prev[tupple[1]] = names[tupple[0]];
      return prev
    }, /** @type {Record<BaseCode,Base>} */({}));

    var constants_1 = {
      names,
      codes
    };

    var src$1 = createCommonjsModule(function (module, exports) {


    const { encodeText, decodeText, concat } = util;

    /** @typedef {import('./base')} Base */
    /** @typedef {import("./types").BaseNameOrCode} BaseNameOrCode */
    /** @typedef {import("./types").BaseCode} BaseCode */
    /** @typedef {import("./types").BaseName} BaseName */

    /**
     * Create a new Uint8Array with the multibase varint+code.
     *
     * @param {BaseNameOrCode} nameOrCode - The multibase name or code number.
     * @param {Uint8Array} buf - The data to be prefixed with multibase.
     * @returns {Uint8Array}
     * @throws {Error} Will throw if the encoding is not supported
     */
    function multibase (nameOrCode, buf) {
      if (!buf) {
        throw new Error('requires an encoded Uint8Array')
      }
      const { name, codeBuf } = encoding(nameOrCode);
      validEncode(name, buf);

      return concat([codeBuf, buf], codeBuf.length + buf.length)
    }

    /**
     * Encode data with the specified base and add the multibase prefix.
     *
     * @param {BaseNameOrCode} nameOrCode - The multibase name or code number.
     * @param {Uint8Array} buf - The data to be encoded.
     * @returns {Uint8Array}
     * @throws {Error} Will throw if the encoding is not supported
     *
     */
    function encode (nameOrCode, buf) {
      const enc = encoding(nameOrCode);
      const data = encodeText(enc.encode(buf));

      return concat([enc.codeBuf, data], enc.codeBuf.length + data.length)
    }

    /**
     * Takes a Uint8Array or string encoded with multibase header, decodes it and
     * returns the decoded buffer
     *
     * @param {Uint8Array|string} data
     * @returns {Uint8Array}
     * @throws {Error} Will throw if the encoding is not supported
     *
     */
    function decode (data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      const prefix = data[0];

      // Make all encodings case-insensitive except the ones that include upper and lower chars in the alphabet
      if (['f', 'F', 'v', 'V', 't', 'T', 'b', 'B', 'c', 'C', 'h', 'k', 'K'].includes(prefix)) {
        data = data.toLowerCase();
      }
      const enc = encoding(/** @type {BaseCode} */(data[0]));
      return enc.decode(data.substring(1))
    }

    /**
     * Is the given data multibase encoded?
     *
     * @param {Uint8Array|string} data
     */
    function isEncoded (data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }

      // Ensure bufOrString is a string
      if (Object.prototype.toString.call(data) !== '[object String]') {
        return false
      }

      try {
        const enc = encoding(/** @type {BaseCode} */(data[0]));
        return enc.name
      } catch (err) {
        return false
      }
    }

    /**
     * Validate encoded data
     *
     * @param {BaseNameOrCode} name
     * @param {Uint8Array} buf
     * @returns {void}
     * @throws {Error} Will throw if the encoding is not supported
     */
    function validEncode (name, buf) {
      const enc = encoding(name);
      enc.decode(decodeText(buf));
    }

    /**
     * Get the encoding by name or code
     *
     * @param {BaseNameOrCode} nameOrCode
     * @returns {Base}
     * @throws {Error} Will throw if the encoding is not supported
     */
    function encoding (nameOrCode) {
      if (Object.prototype.hasOwnProperty.call(constants_1.names, /** @type {BaseName} */(nameOrCode))) {
        return constants_1.names[/** @type {BaseName} */(nameOrCode)]
      } else if (Object.prototype.hasOwnProperty.call(constants_1.codes, /** @type {BaseCode} */(nameOrCode))) {
        return constants_1.codes[/** @type {BaseCode} */(nameOrCode)]
      } else {
        throw new Error(`Unsupported encoding: ${nameOrCode}`)
      }
    }

    /**
     * Get encoding from data
     *
     * @param {string|Uint8Array} data
     * @returns {Base}
     * @throws {Error} Will throw if the encoding is not supported
     */
    function encodingFromData (data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }

      return encoding(/** @type {BaseCode} */(data[0]))
    }

    exports = module.exports = multibase;
    exports.encode = encode;
    exports.decode = decode;
    exports.isEncoded = isEncoded;
    exports.encoding = encoding;
    exports.encodingFromData = encodingFromData;
    const names = Object.freeze(constants_1.names);
    const codes = Object.freeze(constants_1.codes);
    exports.names = names;
    exports.codes = codes;
    });

    var utils$1 = createCommonjsModule(function (module, exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    });
    var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeBase64url = void 0;
    const multibase = __importStar(src$1);
    /**
     * Decodes a buffer formatted in base64url
     */
    function decodeBase64url(bs64url) {
        return multibase.decode(`U${bs64url}`);
    }
    exports.decodeBase64url = decodeBase64url;

    });

    var signer = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSigner = void 0;



    const messenger = new Messenger_1.Messenger({});
    function getSigner(signerAddress, options) {
        if (!signerAddress)
            throw new Error("no signerAddress defined");
        return {
            getAddress: () => signerAddress,
            signHash: (hash) => {
                return messenger.sendDomMessage("popup", "signer:signHash", {
                    signerAddress,
                    hash,
                    kondorVersion: constants$1.kondorVersion,
                });
            },
            signMessage: async (message) => {
                const signatureBase64url = await messenger.sendDomMessage("popup", "signer:signMessage", {
                    signerAddress,
                    message,
                    kondorVersion: constants$1.kondorVersion,
                });
                return (0, utils$1.decodeBase64url)(signatureBase64url);
            },
            signTransaction: async (transaction, abis) => {
                const tx = await messenger.sendDomMessage("popup", "signer:signTransaction", {
                    signerAddress,
                    transaction,
                    abis,
                    kondorVersion: constants$1.kondorVersion,
                });
                transaction.id = tx.id;
                transaction.header = tx.header;
                transaction.operations = tx.operations;
                transaction.signatures = tx.signatures;
                return transaction;
            },
            sendTransaction: async (transaction, optsSend) => {
                if (optsSend === null || optsSend === void 0 ? void 0 : optsSend.beforeSend) {
                    throw new Error("beforeSend option is not supported in kondor");
                }
                const response = await messenger.sendDomMessage("popup", "signer:sendTransaction", {
                    signerAddress,
                    transaction,
                    optsSend,
                    kondorVersion: constants$1.kondorVersion,
                });
                transaction.id = response.transaction.id;
                transaction.header = response.transaction.header;
                transaction.operations = response.transaction.operations;
                transaction.signatures = response.transaction.signatures;
                transaction.wait = async (type = "byBlock", timeout = 60000) => {
                    return messenger.sendDomMessage("background", "provider:wait", {
                        network: options ? options.network : "",
                        txId: transaction.id,
                        type,
                        timeout,
                        kondorVersion: constants$1.kondorVersion,
                    });
                };
                return {
                    transaction: transaction,
                    receipt: response.receipt,
                };
            },
            prepareBlock: () => {
                throw new Error("prepareBlock is not available");
            },
            signBlock: () => {
                throw new Error("signBlock is not available");
            },
        };
    }
    exports.getSigner = getSigner;
    exports.default = getSigner;

    });

    var account = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAccounts = void 0;


    const messenger = new Messenger_1.Messenger();
    async function getAccounts() {
        return messenger.sendDomMessage("popup", "getAccounts", { kondorVersion: constants$1.kondorVersion });
    }
    exports.getAccounts = getAccounts;
    exports.default = getAccounts;

    });

    var src = createCommonjsModule(function (module, exports) {
    /*! kondor - MIT License (c) Julian Gonzalez (joticajulian@gmail.com) */
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(provider, exports);
    __exportStar(signer, exports);
    __exportStar(account, exports);
    __exportStar(Messenger_1, exports);

    });

    var kondor = /*#__PURE__*/_mergeNamespaces({
        __proto__: null,
        'default': src,
        __moduleExports: src
    }, [src]);

    var _assert = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBytes = isBytes;
    exports.number = number;
    exports.bool = bool;
    exports.bytes = bytes;
    exports.hash = hash;
    exports.exists = exists;
    exports.output = output;
    function number(n) {
        if (!Number.isSafeInteger(n) || n < 0)
            throw new Error(`positive integer expected, not ${n}`);
    }
    function bool(b) {
        if (typeof b !== 'boolean')
            throw new Error(`boolean expected, not ${b}`);
    }
    // copied from utils
    function isBytes(a) {
        return (a instanceof Uint8Array ||
            (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
    }
    function bytes(b, ...lengths) {
        if (!isBytes(b))
            throw new Error('Uint8Array expected');
        if (lengths.length > 0 && !lengths.includes(b.length))
            throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
    }
    function hash(h) {
        if (typeof h !== 'function' || typeof h.create !== 'function')
            throw new Error('Hash should be wrapped by utils.wrapConstructor');
        number(h.outputLen);
        number(h.blockLen);
    }
    function exists(instance, checkFinished = true) {
        if (instance.destroyed)
            throw new Error('Hash instance has been destroyed');
        if (checkFinished && instance.finished)
            throw new Error('Hash#digest() has already been called');
    }
    function output(out, instance) {
        bytes(out);
        const min = instance.outputLen;
        if (out.length < min) {
            throw new Error(`digestInto() expects output buffer of length at least ${min}`);
        }
    }
    const assert = { number, bool, bytes, hash, exists, output };
    exports.default = assert;

    });

    var crypto$1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;

    });

    var crypto_1 = crypto$1;

    var _assert_js_1 = _assert;

    var utils = createCommonjsModule(function (module, exports) {
    /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hash = exports.nextTick = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
    exports.isBytes = isBytes;
    exports.byteSwap32 = byteSwap32;
    exports.bytesToHex = bytesToHex;
    exports.hexToBytes = hexToBytes;
    exports.asyncLoop = asyncLoop;
    exports.utf8ToBytes = utf8ToBytes;
    exports.toBytes = toBytes;
    exports.concatBytes = concatBytes;
    exports.checkOpts = checkOpts;
    exports.wrapConstructor = wrapConstructor;
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    exports.randomBytes = randomBytes;
    // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
    // node.js versions earlier than v19 don't declare it in global scope.
    // For node.js, package.json#exports field mapping rewrites import
    // from `crypto` to `cryptoNode`, which imports native module.
    // Makes the utils un-importable in browsers without a bundler.
    // Once node.js 18 is deprecated (2025-04-30), we can just drop the import.


    // export { isBytes } from './_assert.js';
    // We can't reuse isBytes from _assert, because somehow this causes huge perf issues
    function isBytes(a) {
        return (a instanceof Uint8Array ||
            (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
    }
    // Cast array to different type
    const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u32;
    // Cast array to view
    const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    // The rotate right (circular right shift) operation for uint32
    const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
    exports.rotr = rotr;
    // The rotate left (circular left shift) operation for uint32
    const rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);
    exports.rotl = rotl;
    exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
    // The byte swap operation for uint32
    const byteSwap = (word) => ((word << 24) & 0xff000000) |
        ((word << 8) & 0xff0000) |
        ((word >>> 8) & 0xff00) |
        ((word >>> 24) & 0xff);
    exports.byteSwap = byteSwap;
    // Conditionally byte swap if on a big-endian platform
    exports.byteSwapIfBE = exports.isLE ? (n) => n : (n) => (0, exports.byteSwap)(n);
    // In place byte swap for Uint32Array
    function byteSwap32(arr) {
        for (let i = 0; i < arr.length; i++) {
            arr[i] = (0, exports.byteSwap)(arr[i]);
        }
    }
    // Array where index 0xf0 (240) is mapped to string 'f0'
    const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
    /**
     * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
     */
    function bytesToHex(bytes) {
        (0, _assert_js_1.bytes)(bytes);
        // pre-caching improves the speed 6x
        let hex = '';
        for (let i = 0; i < bytes.length; i++) {
            hex += hexes[bytes[i]];
        }
        return hex;
    }
    // We use optimized technique to convert hex string to byte array
    const asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
        if (char >= asciis._0 && char <= asciis._9)
            return char - asciis._0;
        if (char >= asciis._A && char <= asciis._F)
            return char - (asciis._A - 10);
        if (char >= asciis._a && char <= asciis._f)
            return char - (asciis._a - 10);
        return;
    }
    /**
     * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
     */
    function hexToBytes(hex) {
        if (typeof hex !== 'string')
            throw new Error('hex string expected, got ' + typeof hex);
        const hl = hex.length;
        const al = hl / 2;
        if (hl % 2)
            throw new Error('padded hex string expected, got unpadded hex of length ' + hl);
        const array = new Uint8Array(al);
        for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
            const n1 = asciiToBase16(hex.charCodeAt(hi));
            const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
            if (n1 === undefined || n2 === undefined) {
                const char = hex[hi] + hex[hi + 1];
                throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
            }
            array[ai] = n1 * 16 + n2;
        }
        return array;
    }
    // There is no setImmediate in browser and setTimeout is slow.
    // call of async fn will return Promise, which will be fullfiled only on
    // next scheduler queue processing step and this is exactly what we need.
    const nextTick = async () => { };
    exports.nextTick = nextTick;
    // Returns control to thread each 'tick' ms to avoid blocking
    async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
            cb(i);
            // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
            const diff = Date.now() - ts;
            if (diff >= 0 && diff < tick)
                continue;
            await (0, exports.nextTick)();
            ts += diff;
        }
    }
    /**
     * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
     */
    function utf8ToBytes(str) {
        if (typeof str !== 'string')
            throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
    }
    /**
     * Normalizes (non-hex) string or Uint8Array to Uint8Array.
     * Warning: when Uint8Array is passed, it would NOT get copied.
     * Keep in mind for future mutable operations.
     */
    function toBytes(data) {
        if (typeof data === 'string')
            data = utf8ToBytes(data);
        (0, _assert_js_1.bytes)(data);
        return data;
    }
    /**
     * Copies several Uint8Arrays into one.
     */
    function concatBytes(...arrays) {
        let sum = 0;
        for (let i = 0; i < arrays.length; i++) {
            const a = arrays[i];
            (0, _assert_js_1.bytes)(a);
            sum += a.length;
        }
        const res = new Uint8Array(sum);
        for (let i = 0, pad = 0; i < arrays.length; i++) {
            const a = arrays[i];
            res.set(a, pad);
            pad += a.length;
        }
        return res;
    }
    // For runtime check if class implements interface
    class Hash {
        // Safe version that clones internal state
        clone() {
            return this._cloneInto();
        }
    }
    exports.Hash = Hash;
    const toStr = {}.toString;
    function checkOpts(defaults, opts) {
        if (opts !== undefined && toStr.call(opts) !== '[object Object]')
            throw new Error('Options should be object or undefined');
        const merged = Object.assign(defaults, opts);
        return merged;
    }
    function wrapConstructor(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
    }
    function wrapConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
    }
    function wrapXOFConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
    }
    /**
     * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
     */
    function randomBytes(bytesLength = 32) {
        if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
            return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
        }
        // Legacy Node.js compatibility
        if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {
            return crypto_1.crypto.randomBytes(bytesLength);
        }
        throw new Error('crypto.getRandomValues must be defined');
    }

    });

    var utils_js_1 = utils;

    var _md = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HashMD = exports.Maj = exports.Chi = void 0;


    /**
     * Polyfill for Safari 14
     */
    function setBigUint64(view, byteOffset, value, isLE) {
        if (typeof view.setBigUint64 === 'function')
            return view.setBigUint64(byteOffset, value, isLE);
        const _32n = BigInt(32);
        const _u32_max = BigInt(0xffffffff);
        const wh = Number((value >> _32n) & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE ? 4 : 0;
        const l = isLE ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE);
        view.setUint32(byteOffset + l, wl, isLE);
    }
    /**
     * Choice: a ? b : c
     */
    const Chi = (a, b, c) => (a & b) ^ (~a & c);
    exports.Chi = Chi;
    /**
     * Majority function, true if any two inputs is true
     */
    const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
    exports.Maj = Maj;
    /**
     * Merkle-Damgard hash construction base class.
     * Could be used to create MD5, RIPEMD, SHA1, SHA2.
     */
    class HashMD extends utils_js_1.Hash {
        constructor(blockLen, outputLen, padOffset, isLE) {
            super();
            this.blockLen = blockLen;
            this.outputLen = outputLen;
            this.padOffset = padOffset;
            this.isLE = isLE;
            this.finished = false;
            this.length = 0;
            this.pos = 0;
            this.destroyed = false;
            this.buffer = new Uint8Array(blockLen);
            this.view = (0, utils_js_1.createView)(this.buffer);
        }
        update(data) {
            (0, _assert_js_1.exists)(this);
            const { view, buffer, blockLen } = this;
            data = (0, utils_js_1.toBytes)(data);
            const len = data.length;
            for (let pos = 0; pos < len;) {
                const take = Math.min(blockLen - this.pos, len - pos);
                // Fast path: we have at least one block in input, cast it to view and process
                if (take === blockLen) {
                    const dataView = (0, utils_js_1.createView)(data);
                    for (; blockLen <= len - pos; pos += blockLen)
                        this.process(dataView, pos);
                    continue;
                }
                buffer.set(data.subarray(pos, pos + take), this.pos);
                this.pos += take;
                pos += take;
                if (this.pos === blockLen) {
                    this.process(view, 0);
                    this.pos = 0;
                }
            }
            this.length += data.length;
            this.roundClean();
            return this;
        }
        digestInto(out) {
            (0, _assert_js_1.exists)(this);
            (0, _assert_js_1.output)(out, this);
            this.finished = true;
            // Padding
            // We can avoid allocation of buffer for padding completely if it
            // was previously not allocated here. But it won't change performance.
            const { buffer, view, blockLen, isLE } = this;
            let { pos } = this;
            // append the bit '1' to the message
            buffer[pos++] = 0b10000000;
            this.buffer.subarray(pos).fill(0);
            // we have less than padOffset left in buffer, so we cannot put length in
            // current block, need process it and pad again
            if (this.padOffset > blockLen - pos) {
                this.process(view, 0);
                pos = 0;
            }
            // Pad until full block byte with zeros
            for (let i = pos; i < blockLen; i++)
                buffer[i] = 0;
            // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
            // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
            // So we just write lowest 64 bits of that value.
            setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
            this.process(view, 0);
            const oview = (0, utils_js_1.createView)(out);
            const len = this.outputLen;
            // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
            if (len % 4)
                throw new Error('_sha2: outputLen should be aligned to 32bit');
            const outLen = len / 4;
            const state = this.get();
            if (outLen > state.length)
                throw new Error('_sha2: outputLen bigger than state');
            for (let i = 0; i < outLen; i++)
                oview.setUint32(4 * i, state[i], isLE);
        }
        digest() {
            const { buffer, outputLen } = this;
            this.digestInto(buffer);
            const res = buffer.slice(0, outputLen);
            this.destroy();
            return res;
        }
        _cloneInto(to) {
            to || (to = new this.constructor());
            to.set(...this.get());
            const { blockLen, buffer, length, finished, destroyed, pos } = this;
            to.length = length;
            to.pos = pos;
            to.finished = finished;
            to.destroyed = destroyed;
            if (length % blockLen)
                to.buffer.set(buffer);
            return to;
        }
    }
    exports.HashMD = HashMD;

    });

    var _md_js_1 = _md;

    var sha256 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = exports.SHA256 = void 0;


    // SHA2-256 need to try 2^128 hashes to execute birthday attack.
    // BTC network is doing 2^67 hashes/sec as per early 2023.
    // Round constants:
    // first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
    // prettier-ignore
    const SHA256_K = /* @__PURE__ */ new Uint32Array([
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
    ]);
    // Initial state:
    // first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19
    // prettier-ignore
    const SHA256_IV = /* @__PURE__ */ new Uint32Array([
        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
    ]);
    // Temporary buffer, not used to store anything between runs
    // Named this way because it matches specification.
    const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
    class SHA256 extends _md_js_1.HashMD {
        constructor() {
            super(64, 32, 8, false);
            // We cannot use array here since array allows indexing by variable
            // which means optimizer/compiler cannot use registers.
            this.A = SHA256_IV[0] | 0;
            this.B = SHA256_IV[1] | 0;
            this.C = SHA256_IV[2] | 0;
            this.D = SHA256_IV[3] | 0;
            this.E = SHA256_IV[4] | 0;
            this.F = SHA256_IV[5] | 0;
            this.G = SHA256_IV[6] | 0;
            this.H = SHA256_IV[7] | 0;
        }
        get() {
            const { A, B, C, D, E, F, G, H } = this;
            return [A, B, C, D, E, F, G, H];
        }
        // prettier-ignore
        set(A, B, C, D, E, F, G, H) {
            this.A = A | 0;
            this.B = B | 0;
            this.C = C | 0;
            this.D = D | 0;
            this.E = E | 0;
            this.F = F | 0;
            this.G = G | 0;
            this.H = H | 0;
        }
        process(view, offset) {
            // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
            for (let i = 0; i < 16; i++, offset += 4)
                SHA256_W[i] = view.getUint32(offset, false);
            for (let i = 16; i < 64; i++) {
                const W15 = SHA256_W[i - 15];
                const W2 = SHA256_W[i - 2];
                const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);
                const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);
                SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
            }
            // Compression function main loop, 64 rounds
            let { A, B, C, D, E, F, G, H } = this;
            for (let i = 0; i < 64; i++) {
                const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
                const T1 = (H + sigma1 + (0, _md_js_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
                const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
                const T2 = (sigma0 + (0, _md_js_1.Maj)(A, B, C)) | 0;
                H = G;
                G = F;
                F = E;
                E = (D + T1) | 0;
                D = C;
                C = B;
                B = A;
                A = (T1 + T2) | 0;
            }
            // Add the compressed chunk to the current hash value
            A = (A + this.A) | 0;
            B = (B + this.B) | 0;
            C = (C + this.C) | 0;
            D = (D + this.D) | 0;
            E = (E + this.E) | 0;
            F = (F + this.F) | 0;
            G = (G + this.G) | 0;
            H = (H + this.H) | 0;
            this.set(A, B, C, D, E, F, G, H);
        }
        roundClean() {
            SHA256_W.fill(0);
        }
        destroy() {
            this.set(0, 0, 0, 0, 0, 0, 0, 0);
            this.buffer.fill(0);
        }
    }
    exports.SHA256 = SHA256;
    // Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
    class SHA224 extends SHA256 {
        constructor() {
            super();
            this.A = 0xc1059ed8 | 0;
            this.B = 0x367cd507 | 0;
            this.C = 0x3070dd17 | 0;
            this.D = 0xf70e5939 | 0;
            this.E = 0xffc00b31 | 0;
            this.F = 0x68581511 | 0;
            this.G = 0x64f98fa7 | 0;
            this.H = 0xbefa4fa4 | 0;
            this.outputLen = 28;
        }
    }
    /**
     * SHA2-256 hash function
     * @param message - data that would be hashed
     */
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    /**
     * SHA2-224 hash function
     */
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());

    });

    var sha256$1 = sha256;

    // base-x encoding / decoding
    // Copyright (c) 2018 base-x contributors
    // Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
    // Distributed under the MIT software license, see the accompanying
    // file LICENSE or http://www.opensource.org/licenses/mit-license.php.
    function base (ALPHABET) {
      if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
      const BASE_MAP = new Uint8Array(256);
      for (let j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (let i = 0; i < ALPHABET.length; i++) {
        const x = ALPHABET.charAt(i);
        const xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
        BASE_MAP[xc] = i;
      }
      const BASE = ALPHABET.length;
      const LEADER = ALPHABET.charAt(0);
      const FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
      const iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
      function encode (source) {
        // eslint-disable-next-line no-empty
        if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }
        if (source.length === 0) { return '' }
        // Skip & count leading zeroes.
        let zeroes = 0;
        let length = 0;
        let pbegin = 0;
        const pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        // Allocate enough space in big-endian base58 representation.
        const size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
        const b58 = new Uint8Array(size);
        // Process the bytes.
        while (pbegin !== pend) {
          let carry = source[pbegin];
          // Apply "b58 = b58 * 256 + ch".
          let i = 0;
          for (let it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
            carry += (256 * b58[it1]) >>> 0;
            b58[it1] = (carry % BASE) >>> 0;
            carry = (carry / BASE) >>> 0;
          }
          if (carry !== 0) { throw new Error('Non-zero carry') }
          length = i;
          pbegin++;
        }
        // Skip leading zeroes in base58 result.
        let it2 = size - length;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        // Translate the result into a string.
        let str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }
        return str
      }
      function decodeUnsafe (source) {
        if (typeof source !== 'string') { throw new TypeError('Expected String') }
        if (source.length === 0) { return new Uint8Array() }
        let psz = 0;
        // Skip and count leading '1's.
        let zeroes = 0;
        let length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        // Allocate enough space in big-endian base256 representation.
        const size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.
        const b256 = new Uint8Array(size);
        // Process the characters.
        while (source[psz]) {
          // Decode character
          let carry = BASE_MAP[source.charCodeAt(psz)];
          // Invalid character
          if (carry === 255) { return }
          let i = 0;
          for (let it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
            carry += (BASE * b256[it3]) >>> 0;
            b256[it3] = (carry % 256) >>> 0;
            carry = (carry / 256) >>> 0;
          }
          if (carry !== 0) { throw new Error('Non-zero carry') }
          length = i;
          psz++;
        }
        // Skip leading zeroes in b256.
        let it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        const vch = new Uint8Array(zeroes + (size - it4));
        let j = zeroes;
        while (it4 !== size) {
          vch[j++] = b256[it4++];
        }
        return vch
      }
      function decode (string) {
        const buffer = decodeUnsafe(string);
        if (buffer) { return buffer }
        throw new Error('Non-base' + BASE + ' character')
      }
      return {
        encode,
        decodeUnsafe,
        decode
      }
    }

    var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
    var base58 = base(ALPHABET);

    function bs58checkBase (checksumFn) {
        // Encode a buffer as a base58-check encoded string
        function encode(payload) {
            var payloadU8 = Uint8Array.from(payload);
            var checksum = checksumFn(payloadU8);
            var length = payloadU8.length + 4;
            var both = new Uint8Array(length);
            both.set(payloadU8, 0);
            both.set(checksum.subarray(0, 4), payloadU8.length);
            return base58.encode(both);
        }
        function decodeRaw(buffer) {
            var payload = buffer.slice(0, -4);
            var checksum = buffer.slice(-4);
            var newChecksum = checksumFn(payload);
            // eslint-disable-next-line
            if (checksum[0] ^ newChecksum[0] |
                checksum[1] ^ newChecksum[1] |
                checksum[2] ^ newChecksum[2] |
                checksum[3] ^ newChecksum[3])
                return;
            return payload;
        }
        // Decode a base58-check encoded string to a buffer, no result if checksum is wrong
        function decodeUnsafe(str) {
            var buffer = base58.decodeUnsafe(str);
            if (buffer == null)
                return;
            return decodeRaw(buffer);
        }
        function decode(str) {
            var buffer = base58.decode(str);
            var payload = decodeRaw(buffer);
            if (payload == null)
                throw new Error('Invalid checksum');
            return payload;
        }
        return {
            encode: encode,
            decode: decode,
            decodeUnsafe: decodeUnsafe
        };
    }

    // SHA256(SHA256(buffer))
    function sha256x2(buffer) {
        return sha256$1.sha256(sha256$1.sha256(buffer));
    }
    var bs58Check = bs58checkBase(sha256x2);

    function decodeRaw(buffer, version) {
        // check version only if defined
        if (version !== undefined && buffer[0] !== version)
            throw new Error('Invalid network version');
        // uncompressed
        if (buffer.length === 33) {
            return {
                version: buffer[0],
                privateKey: buffer.slice(1, 33),
                compressed: false
            };
        }
        // invalid length
        if (buffer.length !== 34)
            throw new Error('Invalid WIF length');
        // invalid compression flag
        if (buffer[33] !== 0x01)
            throw new Error('Invalid compression flag');
        return {
            version: buffer[0],
            privateKey: buffer.slice(1, 33),
            compressed: true
        };
    }
    function encodeRaw(version, privateKey, compressed) {
        if (privateKey.length !== 32)
            throw new TypeError('Invalid privateKey length');
        var result = new Uint8Array(compressed ? 34 : 33);
        var view = new DataView(result.buffer);
        view.setUint8(0, version);
        result.set(privateKey, 1);
        if (compressed) {
            result[33] = 0x01;
        }
        return result;
    }
    function decode(str, version) {
        return decodeRaw(bs58Check.decode(str), version);
    }
    function encode(wif) {
        return bs58Check.encode(encodeRaw(wif.version, wif.privateKey, wif.compressed));
    }

    var wif = /*#__PURE__*/Object.freeze({
        __proto__: null,
        decodeRaw: decodeRaw,
        encodeRaw: encodeRaw,
        decode: decode,
        encode: encode
    });

    /* src\client\svelte\components\ui\KoinosWallet.svelte generated by Svelte v3.50.1 */
    const file$z = "src\\client\\svelte\\components\\ui\\KoinosWallet.svelte";

    // (151:2) {:else}
    function create_else_block$8(ctx) {
    	let pointerzbutton;
    	let t;
    	let pointerzmodal;
    	let updating_showDialog;
    	let current;

    	pointerzbutton = new PointerzButton({
    			props: {
    				buttonColor: "darkGrey",
    				important: true,
    				$$slots: { default: [create_default_slot_3$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pointerzbutton.$on("click", /*tryToConnectKondorAccount*/ ctx[5]);

    	function pointerzmodal_showDialog_binding(value) {
    		/*pointerzmodal_showDialog_binding*/ ctx[15](value);
    	}

    	let pointerzmodal_props = {
    		color: "darkGrey",
    		confirmTitle: "Link account",
    		confirmFunction: /*tryToLinkPKAccount*/ ctx[7],
    		canCancel: false,
    		$$slots: {
    			description: [create_description_slot_1],
    			title: [create_title_slot_1$1]
    		},
    		$$scope: { ctx }
    	};

    	if (/*openGenerateWalletModal*/ ctx[0] !== void 0) {
    		pointerzmodal_props.showDialog = /*openGenerateWalletModal*/ ctx[0];
    	}

    	pointerzmodal = new PointerzModal({
    			props: pointerzmodal_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(pointerzmodal, 'showDialog', pointerzmodal_showDialog_binding));

    	const block = {
    		c: function create() {
    			create_component(pointerzbutton.$$.fragment);
    			t = space();
    			create_component(pointerzmodal.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pointerzbutton, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(pointerzmodal, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pointerzbutton_changes = {};

    			if (dirty & /*$$scope*/ 2097152) {
    				pointerzbutton_changes.$$scope = { dirty, ctx };
    			}

    			pointerzbutton.$set(pointerzbutton_changes);
    			const pointerzmodal_changes = {};

    			if (dirty & /*$$scope, pastedPrivateKey, privatekeyGenerated, privateKey*/ 2097166) {
    				pointerzmodal_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_showDialog && dirty & /*openGenerateWalletModal*/ 1) {
    				updating_showDialog = true;
    				pointerzmodal_changes.showDialog = /*openGenerateWalletModal*/ ctx[0];
    				add_flush_callback(() => updating_showDialog = false);
    			}

    			pointerzmodal.$set(pointerzmodal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerzbutton.$$.fragment, local);
    			transition_in(pointerzmodal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerzbutton.$$.fragment, local);
    			transition_out(pointerzmodal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pointerzbutton, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(pointerzmodal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(151:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (126:2) {#if connectedKoinosAccount}
    function create_if_block$l(ctx) {
    	let pointerzbutton0;
    	let t0;
    	let pointerzconfirm;
    	let t1;
    	let pointerzbutton1;
    	let current;

    	pointerzbutton0 = new PointerzButton({
    			props: {
    				buttonColor: "darkGrey",
    				imagePath: "assets/images/menu/copy.png",
    				imageOnly: true,
    				noSound: true
    			},
    			$$inline: true
    		});

    	pointerzbutton0.$on("click", /*copyAddressFromUserModel*/ ctx[9]);

    	pointerzconfirm = new PointerzConfirm({
    			props: {
    				confirmTitle: "Unlink",
    				cancelTitle: "Cancel",
    				$$slots: {
    					description: [
    						create_description_slot$2,
    						({ confirm: confirmThis }) => ({ 20: confirmThis }),
    						({ confirm: confirmThis }) => confirmThis ? 1048576 : 0
    					],
    					title: [
    						create_title_slot$2,
    						({ confirm: confirmThis }) => ({ 20: confirmThis }),
    						({ confirm: confirmThis }) => confirmThis ? 1048576 : 0
    					],
    					default: [
    						create_default_slot_1$7,
    						({ confirm: confirmThis }) => ({ 20: confirmThis }),
    						({ confirm: confirmThis }) => confirmThis ? 1048576 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pointerzbutton1 = new PointerzButton({
    			props: {
    				buttonColor: "darkGrey",
    				important: true,
    				clickable: false,
    				$$slots: { default: [create_default_slot$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pointerzbutton0.$$.fragment);
    			t0 = space();
    			create_component(pointerzconfirm.$$.fragment);
    			t1 = space();
    			create_component(pointerzbutton1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pointerzbutton0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(pointerzconfirm, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(pointerzbutton1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pointerzconfirm_changes = {};

    			if (dirty & /*$$scope, confirmThis*/ 3145728) {
    				pointerzconfirm_changes.$$scope = { dirty, ctx };
    			}

    			pointerzconfirm.$set(pointerzconfirm_changes);
    			const pointerzbutton1_changes = {};

    			if (dirty & /*$$scope, connectedKoinosAccount*/ 2097168) {
    				pointerzbutton1_changes.$$scope = { dirty, ctx };
    			}

    			pointerzbutton1.$set(pointerzbutton1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerzbutton0.$$.fragment, local);
    			transition_in(pointerzconfirm.$$.fragment, local);
    			transition_in(pointerzbutton1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerzbutton0.$$.fragment, local);
    			transition_out(pointerzconfirm.$$.fragment, local);
    			transition_out(pointerzbutton1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pointerzbutton0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(pointerzconfirm, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(pointerzbutton1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$l.name,
    		type: "if",
    		source: "(126:2) {#if connectedKoinosAccount}",
    		ctx
    	});

    	return block;
    }

    // (152:4) <PointerzButton        buttonColor="darkGrey"        important        on:click={tryToConnectKondorAccount}>
    function create_default_slot_3$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Connect Koinos");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$6.name,
    		type: "slot",
    		source: "(152:4) <PointerzButton        buttonColor=\\\"darkGrey\\\"        important        on:click={tryToConnectKondorAccount}>",
    		ctx
    	});

    	return block;
    }

    // (162:6) 
    function create_title_slot_1$1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Generate a Koinos account";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$z, 161, 6, 5276);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot_1$1.name,
    		type: "slot",
    		source: "(162:6) ",
    		ctx
    	});

    	return block;
    }

    // (209:8) {:else}
    function create_else_block_1$2(ctx) {
    	let div;
    	let t1;
    	let pointerzbutton;
    	let current;

    	pointerzbutton = new PointerzButton({
    			props: {
    				buttonColor: "darkBlue",
    				important: true,
    				$$slots: { default: [create_default_slot_2$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pointerzbutton.$on("click", /*generatePrivateKey*/ ctx[10]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "You can generate a Koinos account using the button down below or\r\n            paste your own private key.";
    			t1 = space();
    			create_component(pointerzbutton.$$.fragment);
    			attr_dev(div, "class", "paragraph svelte-kshkrh");
    			add_location(div, file$z, 209, 10, 7547);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(pointerzbutton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pointerzbutton_changes = {};

    			if (dirty & /*$$scope*/ 2097152) {
    				pointerzbutton_changes.$$scope = { dirty, ctx };
    			}

    			pointerzbutton.$set(pointerzbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerzbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerzbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t1);
    			destroy_component(pointerzbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$2.name,
    		type: "else",
    		source: "(209:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (199:8) {#if privatekeyGenerated}
    function create_if_block_1$b(ctx) {
    	let div;
    	let t1;
    	let pointerzinput;
    	let updating_value;
    	let current;

    	function pointerzinput_value_binding_1(value) {
    		/*pointerzinput_value_binding_1*/ ctx[14](value);
    	}

    	let pointerzinput_props = {
    		type: "text",
    		placeholder: "Paste your generated private key to verify!"
    	};

    	if (/*pastedPrivateKey*/ ctx[3] !== void 0) {
    		pointerzinput_props.value = /*pastedPrivateKey*/ ctx[3];
    	}

    	pointerzinput = new PointerzInput({
    			props: pointerzinput_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(pointerzinput, 'value', pointerzinput_value_binding_1));

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "⚠️ You have generated a new private key for a Koinos account! Make\r\n            sure to write it somewhere safe! We won't be able to recover it for\r\n            you since we don't store it on our servers.";
    			t1 = space();
    			create_component(pointerzinput.$$.fragment);
    			attr_dev(div, "class", "paragraph svelte-kshkrh");
    			add_location(div, file$z, 199, 10, 7091);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(pointerzinput, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pointerzinput_changes = {};

    			if (!updating_value && dirty & /*pastedPrivateKey*/ 8) {
    				updating_value = true;
    				pointerzinput_changes.value = /*pastedPrivateKey*/ ctx[3];
    				add_flush_callback(() => updating_value = false);
    			}

    			pointerzinput.$set(pointerzinput_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerzinput.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerzinput.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t1);
    			destroy_component(pointerzinput, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(199:8) {#if privatekeyGenerated}",
    		ctx
    	});

    	return block;
    }

    // (214:10) <PointerzButton              buttonColor="darkBlue"              important              on:click={generatePrivateKey}>
    function create_default_slot_2$6(ctx) {
    	let svg;
    	let g0;
    	let g1;
    	let g2;
    	let path0;
    	let path1;
    	let polyline0;
    	let polyline1;
    	let t;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g0 = svg_element("g");
    			g1 = svg_element("g");
    			g2 = svg_element("g");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			polyline0 = svg_element("polyline");
    			polyline1 = svg_element("polyline");
    			t = text("Generate a new account");
    			attr_dev(g0, "id", "SVGRepo_bgCarrier");
    			attr_dev(g0, "stroke-width", "0");
    			add_location(g0, file$z, 222, 14, 8078);
    			attr_dev(g1, "id", "SVGRepo_tracerCarrier");
    			attr_dev(g1, "stroke-linecap", "round");
    			attr_dev(g1, "stroke-linejoin", "round");
    			add_location(g1, file$z, 223, 14, 8141);
    			attr_dev(path0, "id", "primary");
    			attr_dev(path0, "d", "M4,12A8,8,0,0,1,18.93,8");
    			set_style(path0, "fill", "none");
    			set_style(path0, "stroke", "#dddbdb");
    			set_style(path0, "stroke-linecap", "round");
    			set_style(path0, "stroke-linejoin", "round");
    			set_style(path0, "stroke-width", "2");
    			add_location(path0, file$z, 228, 16, 8335);
    			attr_dev(path1, "id", "primary-2");
    			attr_dev(path1, "data-name", "primary");
    			attr_dev(path1, "d", "M20,12A8,8,0,0,1,5.07,16");
    			set_style(path1, "fill", "none");
    			set_style(path1, "stroke", "#dddbdb");
    			set_style(path1, "stroke-linecap", "round");
    			set_style(path1, "stroke-linejoin", "round");
    			set_style(path1, "stroke-width", "2");
    			add_location(path1, file$z, 238, 16, 8643);
    			attr_dev(polyline0, "id", "primary-3");
    			attr_dev(polyline0, "data-name", "primary");
    			attr_dev(polyline0, "points", "14 8 19 8 19 3");
    			set_style(polyline0, "fill", "none");
    			set_style(polyline0, "stroke", "#dddbdb");
    			set_style(polyline0, "stroke-linecap", "round");
    			set_style(polyline0, "stroke-linejoin", "round");
    			set_style(polyline0, "stroke-width", "2");
    			add_location(polyline0, file$z, 249, 16, 8993);
    			attr_dev(polyline1, "id", "primary-4");
    			attr_dev(polyline1, "data-name", "primary");
    			attr_dev(polyline1, "points", "10 16 5 16 5 21");
    			set_style(polyline1, "fill", "none");
    			set_style(polyline1, "stroke", "#dddbdb");
    			set_style(polyline1, "stroke-linecap", "round");
    			set_style(polyline1, "stroke-linejoin", "round");
    			set_style(polyline1, "stroke-width", "2");
    			add_location(polyline1, file$z, 260, 16, 9346);
    			attr_dev(g2, "id", "SVGRepo_iconCarrier");
    			add_location(g2, file$z, 227, 14, 8289);
    			attr_dev(svg, "fill", "#dddbdb");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			set_style(svg, "width", "28px");
    			set_style(svg, "height", "28px");
    			set_style(svg, "vertical-align", "middle");
    			set_style(svg, "margin-right", "8px");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$z, 217, 12, 7851);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g0);
    			append_dev(svg, g1);
    			append_dev(svg, g2);
    			append_dev(g2, path0);
    			append_dev(g2, path1);
    			append_dev(g2, polyline0);
    			append_dev(g2, polyline1);
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$6.name,
    		type: "slot",
    		source: "(214:10) <PointerzButton              buttonColor=\\\"darkBlue\\\"              important              on:click={generatePrivateKey}>",
    		ctx
    	});

    	return block;
    }

    // (163:6) 
    function create_description_slot_1(ctx) {
    	let span1;
    	let div0;
    	let t1;
    	let div2;
    	let div1;
    	let pointerzinput;
    	let updating_value;
    	let t2;
    	let span0;
    	let svg;
    	let path0;
    	let path1;
    	let t3;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	let mounted;
    	let dispose;

    	function pointerzinput_value_binding(value) {
    		/*pointerzinput_value_binding*/ ctx[13](value);
    	}

    	let pointerzinput_props = { type: "text", placeholder: "Private key" };

    	if (/*privateKey*/ ctx[2] !== void 0) {
    		pointerzinput_props.value = /*privateKey*/ ctx[2];
    	}

    	pointerzinput = new PointerzInput({
    			props: pointerzinput_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(pointerzinput, 'value', pointerzinput_value_binding));
    	const if_block_creators = [create_if_block_1$b, create_else_block_1$2];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*privatekeyGenerated*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			span1 = element("span");
    			div0 = element("div");
    			div0.textContent = "ℹ️ You can generate a Koinos account using the button down below or\r\n          paste your own private key.";
    			t1 = space();
    			div2 = element("div");
    			div1 = element("div");
    			create_component(pointerzinput.$$.fragment);
    			t2 = space();
    			span0 = element("span");
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			t3 = space();
    			if_block.c();
    			attr_dev(div0, "class", "paragraph svelte-kshkrh");
    			add_location(div0, file$z, 163, 8, 5370);
    			attr_dev(div1, "class", "flex-auto svelte-kshkrh");
    			add_location(div1, file$z, 168, 10, 5578);
    			attr_dev(path0, "fill-rule", "evenodd");
    			attr_dev(path0, "clip-rule", "evenodd");
    			attr_dev(path0, "d", "M8.94605 4.99995L13.2541 4.99995C14.173 5.00498 15.0524 5.37487 15.6986 6.02825C16.3449 6.68163 16.7051 7.56497 16.7001 8.48395V12.716C16.7051 13.6349 16.3449 14.5183 15.6986 15.1717C15.0524 15.825 14.173 16.1949 13.2541 16.2H8.94605C8.02707 16.1949 7.14773 15.825 6.50148 15.1717C5.85522 14.5183 5.495 13.6349 5.50005 12.716L5.50005 8.48495C5.49473 7.5658 5.85484 6.6822 6.50112 6.0286C7.1474 5.375 8.0269 5.00498 8.94605 4.99995Z");
    			attr_dev(path0, "stroke", "currentColor");
    			attr_dev(path0, "stroke-width", "1.5");
    			attr_dev(path0, "stroke-linecap", "round");
    			attr_dev(path0, "stroke-linejoin", "round");
    			add_location(path0, file$z, 181, 14, 6024);
    			attr_dev(path1, "d", "M10.1671 19H14.9371C17.4857 18.9709 19.5284 16.8816 19.5001 14.333V9.666");
    			attr_dev(path1, "stroke", "currentColor");
    			attr_dev(path1, "stroke-width", "1.5");
    			attr_dev(path1, "stroke-linecap", "round");
    			attr_dev(path1, "stroke-linejoin", "round");
    			add_location(path1, file$z, 189, 14, 6731);
    			attr_dev(svg, "width", "48px");
    			attr_dev(svg, "height", "48px");
    			attr_dev(svg, "viewBox", "0 -0.5 25 25");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$z, 175, 12, 5831);
    			attr_dev(span0, "class", "copyKey svelte-kshkrh");
    			add_location(span0, file$z, 174, 10, 5769);
    			attr_dev(div2, "class", "flex margin-top svelte-kshkrh");
    			add_location(div2, file$z, 167, 8, 5537);
    			attr_dev(span1, "slot", "description");
    			add_location(span1, file$z, 162, 6, 5335);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span1, anchor);
    			append_dev(span1, div0);
    			append_dev(span1, t1);
    			append_dev(span1, div2);
    			append_dev(div2, div1);
    			mount_component(pointerzinput, div1, null);
    			append_dev(div2, t2);
    			append_dev(div2, span0);
    			append_dev(span0, svg);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			append_dev(span1, t3);
    			if_blocks[current_block_type_index].m(span1, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(span0, "click", /*copyPrivateKey*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const pointerzinput_changes = {};

    			if (!updating_value && dirty & /*privateKey*/ 4) {
    				updating_value = true;
    				pointerzinput_changes.value = /*privateKey*/ ctx[2];
    				add_flush_callback(() => updating_value = false);
    			}

    			pointerzinput.$set(pointerzinput_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(span1, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerzinput.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerzinput.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span1);
    			destroy_component(pointerzinput);
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_description_slot_1.name,
    		type: "slot",
    		source: "(163:6) ",
    		ctx
    	});

    	return block;
    }

    // (133:4) <PointerzConfirm        let:confirm={confirmThis}        confirmTitle="Unlink"        cancelTitle="Cancel">
    function create_default_slot_1$7(ctx) {
    	let pointerzbutton;
    	let current;

    	function click_handler() {
    		return /*click_handler*/ ctx[12](/*confirmThis*/ ctx[20]);
    	}

    	pointerzbutton = new PointerzButton({
    			props: {
    				buttonColor: "darkGrey",
    				imagePath: "assets/images/menu/unlink.png",
    				imageOnly: true,
    				noSound: true
    			},
    			$$inline: true
    		});

    	pointerzbutton.$on("click", click_handler);

    	const block = {
    		c: function create() {
    			create_component(pointerzbutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pointerzbutton, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerzbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerzbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pointerzbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$7.name,
    		type: "slot",
    		source: "(133:4) <PointerzConfirm        let:confirm={confirmThis}        confirmTitle=\\\"Unlink\\\"        cancelTitle=\\\"Cancel\\\">",
    		ctx
    	});

    	return block;
    }

    // (143:6) 
    function create_title_slot$2(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Unlink your Koinos account?";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$z, 142, 6, 4436);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$2.name,
    		type: "slot",
    		source: "(143:6) ",
    		ctx
    	});

    	return block;
    }

    // (144:6) 
    function create_description_slot$2(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Do you really want to unlink your Koinos account ? Please make sure you\r\n        have your private key stored somewhere safe! We won't be able to recover\r\n        it for you since we don't store it on our servers.";
    			attr_dev(span, "slot", "description");
    			add_location(span, file$z, 143, 6, 4499);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_description_slot$2.name,
    		type: "slot",
    		source: "(144:6) ",
    		ctx
    	});

    	return block;
    }

    // (149:4) <PointerzButton buttonColor="darkGrey" important clickable={false}        >
    function create_default_slot$b(ctx) {
    	let t_value = reduceAddress(/*connectedKoinosAccount*/ ctx[4]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*connectedKoinosAccount*/ 16 && t_value !== (t_value = reduceAddress(/*connectedKoinosAccount*/ ctx[4]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$b.name,
    		type: "slot",
    		source: "(149:4) <PointerzButton buttonColor=\\\"darkGrey\\\" important clickable={false}        >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$B(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$l, create_else_block$8];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*connectedKoinosAccount*/ ctx[4]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "pointerzButtonCointainer svelte-kshkrh");
    			add_location(div, file$z, 124, 0, 3851);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function reduceAddress(address) {
    	return address.slice(0, 6) + "..." + address.slice(-6);
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let connectedKoinosAccount;
    	let $infoInfo;
    	let $userModel;
    	let $infoError;
    	validate_store(infoInfo, 'infoInfo');
    	component_subscribe($$self, infoInfo, $$value => $$invalidate(16, $infoInfo = $$value));
    	validate_store(userModel, 'userModel');
    	component_subscribe($$self, userModel, $$value => $$invalidate(11, $userModel = $$value));
    	validate_store(infoError, 'infoError');
    	component_subscribe($$self, infoError, $$value => $$invalidate(17, $infoError = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('KoinosWallet', slots, []);
    	let openGenerateWalletModal;
    	let privatekeyGenerated;
    	let privateKey;
    	let pastedPrivateKey;

    	function resetModal() {
    		$$invalidate(0, openGenerateWalletModal = false);
    		$$invalidate(1, privatekeyGenerated = false);
    		$$invalidate(3, pastedPrivateKey = "");
    		$$invalidate(2, privateKey = "");
    	}

    	resetModal();

    	async function tryToConnectKondorAccount() {
    		let hasKondor = await Client$1.tryToOpenKondor();

    		if (!hasKondor) {
    			$$invalidate(0, openGenerateWalletModal = true);
    			return;
    		}

    		let accounts = await src.getAccounts();

    		if (!accounts || accounts.length == 0) {
    			set_store_value(infoError, $infoError = "No Koinos account selected", $infoError);
    			return;
    		}

    		let accountToLink = accounts[0];

    		try {
    			let tempContractWithSigner = Client$1.getPointerzNFTContractWithSigner({
    				koinosAccountType: "Kondor",
    				koinosAccount: accountToLink.address
    			});

    			await Client$1.signAndSendLinkAccountTransaction(accountToLink.address, $userModel.username, tempContractWithSigner);
    			Client$1.socket.emitLinkKoinosAccount(accountToLink.address, "Kondor"); // Send the address to the server for it to listen to the transactions
    			set_store_value(infoInfo, $infoInfo = "Transaction sent to link your Koinos account, please wait a few seconds for it to be confirmed!", $infoInfo);
    		} catch(e) {
    			set_store_value(infoError, $infoError = e, $infoError);
    		}
    	}

    	async function unlinkKoinosAccount() {
    		Client$1.unlinkCryptoAccount($userModel);
    		Client$1.socket.emitLinkKoinosAccount(null);
    	}

    	async function tryToLinkPKAccount() {
    		if (!privateKey) {
    			set_store_value(infoError, $infoError = "Please paste your private key", $infoError);
    			return false;
    		}

    		if (privatekeyGenerated && privateKey != pastedPrivateKey) {
    			set_store_value(infoError, $infoError = "Private keys don't match. Please store your private key somewhere safe!", $infoError);
    			return false;
    		}

    		try {
    			let address = getPublicKeyFromPrivateKey(privateKey);

    			let tempContractWithSigner = Client$1.getPointerzNFTContractWithSigner({
    				koinosAccountType: "PK",
    				koinosAccount: address,
    				username: $userModel.username,
    				password: $userModel.password,
    				privateKey
    			});

    			await Client$1.signAndSendLinkAccountTransaction(address, $userModel.username, tempContractWithSigner);
    			Client$1.socket.emitLinkKoinosAccount(address, "PK");
    			set_store_value(infoInfo, $infoInfo = "Transaction sent to link your Koinos account, please wait a few seconds for it to be confirmed!", $infoInfo);
    			resetModal();
    			return true;
    		} catch(e) {
    			set_store_value(infoError, $infoError = e, $infoError);
    			return false;
    		}
    	}

    	function copyPrivateKey() {
    		navigator.clipboard.writeText(privateKey);
    		set_store_value(infoInfo, $infoInfo = "Private key copied to clipboard", $infoInfo);
    	}

    	function copyAddressFromUserModel() {
    		navigator.clipboard.writeText($userModel.koinosAccount);
    		set_store_value(infoInfo, $infoInfo = "Address copied to clipboard", $infoInfo);
    	}

    	function generatePrivateKey() {
    		$$invalidate(2, privateKey = Client$1.getRandomPrivateKey());
    		$$invalidate(1, privatekeyGenerated = true);
    	}

    	function getPublicKeyFromPrivateKey(privateKey) {
    		// Private key is in WIF format, convert it to hex
    		privateKey = decode(privateKey).privateKey;

    		const signer = new Signer({ privateKey });
    		return signer.address;
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<KoinosWallet> was created with unknown prop '${key}'`);
    	});

    	const click_handler = confirmThis => confirmThis(unlinkKoinosAccount);

    	function pointerzinput_value_binding(value) {
    		privateKey = value;
    		$$invalidate(2, privateKey);
    	}

    	function pointerzinput_value_binding_1(value) {
    		pastedPrivateKey = value;
    		$$invalidate(3, pastedPrivateKey);
    	}

    	function pointerzmodal_showDialog_binding(value) {
    		openGenerateWalletModal = value;
    		$$invalidate(0, openGenerateWalletModal);
    	}

    	$$self.$capture_state = () => ({
    		infoError,
    		infoInfo,
    		userModel,
    		Client: Client$1,
    		PointerzButton,
    		PointerzModal,
    		PointerzConfirm,
    		PointerzInput,
    		kondor,
    		wif,
    		openGenerateWalletModal,
    		privatekeyGenerated,
    		privateKey,
    		pastedPrivateKey,
    		resetModal,
    		tryToConnectKondorAccount,
    		unlinkKoinosAccount,
    		tryToLinkPKAccount,
    		reduceAddress,
    		copyPrivateKey,
    		copyAddressFromUserModel,
    		generatePrivateKey,
    		getPublicKeyFromPrivateKey,
    		connectedKoinosAccount,
    		$infoInfo,
    		$userModel,
    		$infoError
    	});

    	$$self.$inject_state = $$props => {
    		if ('openGenerateWalletModal' in $$props) $$invalidate(0, openGenerateWalletModal = $$props.openGenerateWalletModal);
    		if ('privatekeyGenerated' in $$props) $$invalidate(1, privatekeyGenerated = $$props.privatekeyGenerated);
    		if ('privateKey' in $$props) $$invalidate(2, privateKey = $$props.privateKey);
    		if ('pastedPrivateKey' in $$props) $$invalidate(3, pastedPrivateKey = $$props.pastedPrivateKey);
    		if ('connectedKoinosAccount' in $$props) $$invalidate(4, connectedKoinosAccount = $$props.connectedKoinosAccount);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$userModel*/ 2048) {
    			$$invalidate(4, connectedKoinosAccount = $userModel.koinosAccount);
    		}
    	};

    	return [
    		openGenerateWalletModal,
    		privatekeyGenerated,
    		privateKey,
    		pastedPrivateKey,
    		connectedKoinosAccount,
    		tryToConnectKondorAccount,
    		unlinkKoinosAccount,
    		tryToLinkPKAccount,
    		copyPrivateKey,
    		copyAddressFromUserModel,
    		generatePrivateKey,
    		$userModel,
    		click_handler,
    		pointerzinput_value_binding,
    		pointerzinput_value_binding_1,
    		pointerzmodal_showDialog_binding
    	];
    }

    class KoinosWallet extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$B, create_fragment$B, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "KoinosWallet",
    			options,
    			id: create_fragment$B.name
    		});
    	}
    }

    /* src\client\svelte\pages\AppLayout.svelte generated by Svelte v3.50.1 */
    const file$y = "src\\client\\svelte\\pages\\AppLayout.svelte";

    // (21:2) {#if $loggedIn}
    function create_if_block$k(ctx) {
    	let koinoswallet;
    	let current;
    	koinoswallet = new KoinosWallet({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(koinoswallet.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(koinoswallet, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(koinoswallet.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(koinoswallet.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(koinoswallet, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(21:2) {#if $loggedIn}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$A(ctx) {
    	let main;
    	let t0;
    	let div3;
    	let div1;
    	let div0;
    	let span0;
    	let t2;
    	let span1;
    	let t4;
    	let span2;
    	let t6;
    	let span3;
    	let t8;
    	let span4;
    	let t10;
    	let span5;
    	let t12;
    	let span6;
    	let t14;
    	let span7;
    	let t16;
    	let span8;
    	let t18;
    	let span9;
    	let t20;
    	let span10;
    	let t22;
    	let div2;
    	let div3_intro;
    	let div3_outro;
    	let current;
    	let if_block = /*$loggedIn*/ ctx[0] && create_if_block$k(ctx);
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			main = element("main");
    			if (if_block) if_block.c();
    			t0 = space();
    			div3 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			span0 = element("span");
    			span0.textContent = "P";
    			t2 = space();
    			span1 = element("span");
    			span1.textContent = "o";
    			t4 = space();
    			span2 = element("span");
    			span2.textContent = "i";
    			t6 = space();
    			span3 = element("span");
    			span3.textContent = "n";
    			t8 = space();
    			span4 = element("span");
    			span4.textContent = "t";
    			t10 = space();
    			span5 = element("span");
    			span5.textContent = "e";
    			t12 = space();
    			span6 = element("span");
    			span6.textContent = "r";
    			t14 = space();
    			span7 = element("span");
    			span7.textContent = "z";
    			t16 = space();
    			span8 = element("span");
    			span8.textContent = ".";
    			t18 = space();
    			span9 = element("span");
    			span9.textContent = "i";
    			t20 = space();
    			span10 = element("span");
    			span10.textContent = "o";
    			t22 = space();
    			div2 = element("div");
    			if (default_slot) default_slot.c();
    			set_style(span0, "color", "hsl(0,65%,40%)");
    			attr_dev(span0, "class", "svelte-2wncxx");
    			add_location(span0, file$y, 31, 8, 976);
    			set_style(span1, "color", "hsl(34,65%,40%)");
    			attr_dev(span1, "class", "svelte-2wncxx");
    			add_location(span1, file$y, 32, 8, 1029);
    			set_style(span2, "color", "hsl(68,65%,40%)");
    			attr_dev(span2, "class", "svelte-2wncxx");
    			add_location(span2, file$y, 33, 8, 1083);
    			set_style(span3, "color", "hsl(102,65%,40%)");
    			attr_dev(span3, "class", "svelte-2wncxx");
    			add_location(span3, file$y, 34, 8, 1137);
    			set_style(span4, "color", "hsl(136,65%,40%)");
    			attr_dev(span4, "class", "svelte-2wncxx");
    			add_location(span4, file$y, 35, 8, 1192);
    			set_style(span5, "color", "hsl(170,65%,40%)");
    			attr_dev(span5, "class", "svelte-2wncxx");
    			add_location(span5, file$y, 36, 8, 1247);
    			set_style(span6, "color", "hsl(204,65%,40%)");
    			attr_dev(span6, "class", "svelte-2wncxx");
    			add_location(span6, file$y, 37, 8, 1302);
    			set_style(span7, "color", "hsl(238,65%,40%)");
    			attr_dev(span7, "class", "svelte-2wncxx");
    			add_location(span7, file$y, 38, 8, 1357);
    			set_style(span8, "color", "hsl(272,65%,40%)");
    			attr_dev(span8, "class", "svelte-2wncxx");
    			add_location(span8, file$y, 39, 8, 1412);
    			set_style(span9, "color", "hsl(306,65%,40%)");
    			attr_dev(span9, "class", "svelte-2wncxx");
    			add_location(span9, file$y, 40, 8, 1467);
    			set_style(span10, "color", "hsl(340,65%,40%)");
    			attr_dev(span10, "class", "svelte-2wncxx");
    			add_location(span10, file$y, 41, 8, 1522);
    			attr_dev(div0, "id", "title");
    			set_style(div0, "font-size", Math.min(window.innerWidth * 30 / 350, 46) + "px");
    			attr_dev(div0, "class", "svelte-2wncxx");
    			add_location(div0, file$y, 28, 6, 865);
    			attr_dev(div1, "id", "titleContainer");
    			attr_dev(div1, "class", "svelte-2wncxx");
    			add_location(div1, file$y, 27, 4, 832);
    			attr_dev(div2, "id", "totalContainer");
    			set_style(div2, "margin-left", /*appMargin*/ ctx[1] + "px");
    			set_style(div2, "margin-right", /*appMargin*/ ctx[1] + "px");
    			attr_dev(div2, "class", "svelte-2wncxx");
    			add_location(div2, file$y, 44, 4, 1599);
    			attr_dev(div3, "id", "uiContainer");
    			attr_dev(div3, "class", "svelte-2wncxx");
    			add_location(div3, file$y, 23, 2, 720);
    			attr_dev(main, "class", "svelte-2wncxx");
    			add_location(main, file$y, 19, 0, 660);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			if (if_block) if_block.m(main, null);
    			append_dev(main, t0);
    			append_dev(main, div3);
    			append_dev(div3, div1);
    			append_dev(div1, div0);
    			append_dev(div0, span0);
    			append_dev(div0, t2);
    			append_dev(div0, span1);
    			append_dev(div0, t4);
    			append_dev(div0, span2);
    			append_dev(div0, t6);
    			append_dev(div0, span3);
    			append_dev(div0, t8);
    			append_dev(div0, span4);
    			append_dev(div0, t10);
    			append_dev(div0, span5);
    			append_dev(div0, t12);
    			append_dev(div0, span6);
    			append_dev(div0, t14);
    			append_dev(div0, span7);
    			append_dev(div0, t16);
    			append_dev(div0, span8);
    			append_dev(div0, t18);
    			append_dev(div0, span9);
    			append_dev(div0, t20);
    			append_dev(div0, span10);
    			append_dev(div3, t22);
    			append_dev(div3, div2);

    			if (default_slot) {
    				default_slot.m(div2, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$loggedIn*/ ctx[0]) {
    				if (if_block) {
    					if (dirty & /*$loggedIn*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$k(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(main, t0);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(default_slot, local);

    			add_render_callback(() => {
    				if (div3_outro) div3_outro.end(1);
    				div3_intro = create_in_transition(div3, fade, { delay: 400, duration: 400 });
    				div3_intro.start();
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(default_slot, local);
    			if (div3_intro) div3_intro.invalidate();
    			div3_outro = create_out_transition(div3, fade, { duration: 400 });
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (if_block) if_block.d();
    			if (default_slot) default_slot.d(detaching);
    			if (detaching && div3_outro) div3_outro.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let $loggedIn;
    	validate_store(loggedIn, 'loggedIn');
    	component_subscribe($$self, loggedIn, $$value => $$invalidate(0, $loggedIn = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AppLayout', slots, ['default']);
    	let appMargin = Math.max(css.uiContainer.minMargin, Math.min(css.uiContainer.maxMargin, (window.innerWidth - css.publicMenu.minWidth) / (css.publicMenu.maxWidth - css.publicMenu.minWidth) * (css.uiContainer.maxMargin - css.uiContainer.minMargin) + css.uiContainer.minMargin));
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AppLayout> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		infoInfo,
    		infoError,
    		loggedIn,
    		css,
    		fade,
    		ClosableDislay: ClosableDisplay,
    		KoinosWallet,
    		appMargin,
    		$loggedIn
    	});

    	$$self.$inject_state = $$props => {
    		if ('appMargin' in $$props) $$invalidate(1, appMargin = $$props.appMargin);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [$loggedIn, appMargin, $$scope, slots];
    }

    class AppLayout extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$A, create_fragment$A, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AppLayout",
    			options,
    			id: create_fragment$A.name
    		});
    	}
    }

    /* src\client\svelte\components\ui\FlexContainer.svelte generated by Svelte v3.50.1 */

    const file$x = "src\\client\\svelte\\components\\ui\\FlexContainer.svelte";

    function create_fragment$z(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "flexContainer svelte-aypz5n");
    			attr_dev(div, "style", /*computedStyle*/ ctx[0]);
    			add_location(div, file$x, 17, 0, 435);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*computedStyle*/ 1) {
    				attr_dev(div, "style", /*computedStyle*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FlexContainer', slots, ['default']);
    	let { flexWrap = undefined } = $$props;
    	let { justifyContent = undefined } = $$props;
    	let { flexFlow = undefined } = $$props;
    	let computedStyle = flexWrap ? "flex-wrap:" + flexWrap + ";" : "";

    	computedStyle += justifyContent
    	? "justify-content:" + justifyContent + ";"
    	: "";

    	computedStyle += flexFlow ? "flex-flow:" + flexFlow + ";" : "";
    	const writable_props = ['flexWrap', 'justifyContent', 'flexFlow'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FlexContainer> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('flexWrap' in $$props) $$invalidate(1, flexWrap = $$props.flexWrap);
    		if ('justifyContent' in $$props) $$invalidate(2, justifyContent = $$props.justifyContent);
    		if ('flexFlow' in $$props) $$invalidate(3, flexFlow = $$props.flexFlow);
    		if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		flexWrap,
    		justifyContent,
    		flexFlow,
    		computedStyle
    	});

    	$$self.$inject_state = $$props => {
    		if ('flexWrap' in $$props) $$invalidate(1, flexWrap = $$props.flexWrap);
    		if ('justifyContent' in $$props) $$invalidate(2, justifyContent = $$props.justifyContent);
    		if ('flexFlow' in $$props) $$invalidate(3, flexFlow = $$props.flexFlow);
    		if ('computedStyle' in $$props) $$invalidate(0, computedStyle = $$props.computedStyle);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [computedStyle, flexWrap, justifyContent, flexFlow, $$scope, slots];
    }

    class FlexContainer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$z, create_fragment$z, safe_not_equal, {
    			flexWrap: 1,
    			justifyContent: 2,
    			flexFlow: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FlexContainer",
    			options,
    			id: create_fragment$z.name
    		});
    	}

    	get flexWrap() {
    		throw new Error("<FlexContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flexWrap(value) {
    		throw new Error("<FlexContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get justifyContent() {
    		throw new Error("<FlexContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set justifyContent(value) {
    		throw new Error("<FlexContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get flexFlow() {
    		throw new Error("<FlexContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flexFlow(value) {
    		throw new Error("<FlexContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\client\svelte\components\ui\PointerzTable.svelte generated by Svelte v3.50.1 */

    const file$w = "src\\client\\svelte\\components\\ui\\PointerzTable.svelte";

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	return child_ctx;
    }

    // (19:2) {:else}
    function create_else_block$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("There is no ranking");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(19:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (9:2) {#if values.length > 0}
    function create_if_block$j(ctx) {
    	let each_1_anchor;
    	let each_value = /*values*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*values, highlightedStyle, columns*/ 7) {
    				each_value = /*values*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$b(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$b(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(9:2) {#if values.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (12:8) {#each columns as column}
    function create_each_block_1$2(ctx) {
    	let td;
    	let raw_value = /*val*/ ctx[3][/*column*/ ctx[6].name] + "";
    	let td_style_value;

    	const block = {
    		c: function create() {
    			td = element("td");
    			attr_dev(td, "style", td_style_value = /*column*/ ctx[6].style);
    			attr_dev(td, "class", "svelte-uyghes");
    			add_location(td, file$w, 12, 10, 361);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			td.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*values, columns*/ 3 && raw_value !== (raw_value = /*val*/ ctx[3][/*column*/ ctx[6].name] + "")) td.innerHTML = raw_value;
    			if (dirty & /*columns*/ 1 && td_style_value !== (td_style_value = /*column*/ ctx[6].style)) {
    				attr_dev(td, "style", td_style_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(12:8) {#each columns as column}",
    		ctx
    	});

    	return block;
    }

    // (10:4) {#each values as val}
    function create_each_block$b(ctx) {
    	let tr;
    	let t;
    	let tr_style_value;
    	let each_value_1 = /*columns*/ ctx[0];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();

    			attr_dev(tr, "style", tr_style_value = /*val*/ ctx[3].highlighted
    			? /*highlightedStyle*/ ctx[2]
    			: "");

    			attr_dev(tr, "class", "svelte-uyghes");
    			add_location(tr, file$w, 10, 6, 262);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*columns, values*/ 3) {
    				each_value_1 = /*columns*/ ctx[0];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (dirty & /*values, highlightedStyle*/ 6 && tr_style_value !== (tr_style_value = /*val*/ ctx[3].highlighted
    			? /*highlightedStyle*/ ctx[2]
    			: "")) {
    				attr_dev(tr, "style", tr_style_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$b.name,
    		type: "each",
    		source: "(10:4) {#each values as val}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$y(ctx) {
    	let table;

    	function select_block_type(ctx, dirty) {
    		if (/*values*/ ctx[1].length > 0) return create_if_block$j;
    		return create_else_block$7;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			table = element("table");
    			if_block.c();
    			attr_dev(table, "class", "svelte-uyghes");
    			add_location(table, file$w, 7, 0, 193);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			if_block.m(table, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(table, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PointerzTable', slots, []);
    	let { columns = [] } = $$props;
    	let { values = [] } = $$props;
    	let { highlightedStyle = "background:var(--dark-blue-shadow-color);color:var(--almost-white-color);" } = $$props;
    	const writable_props = ['columns', 'values', 'highlightedStyle'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PointerzTable> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('columns' in $$props) $$invalidate(0, columns = $$props.columns);
    		if ('values' in $$props) $$invalidate(1, values = $$props.values);
    		if ('highlightedStyle' in $$props) $$invalidate(2, highlightedStyle = $$props.highlightedStyle);
    	};

    	$$self.$capture_state = () => ({ columns, values, highlightedStyle });

    	$$self.$inject_state = $$props => {
    		if ('columns' in $$props) $$invalidate(0, columns = $$props.columns);
    		if ('values' in $$props) $$invalidate(1, values = $$props.values);
    		if ('highlightedStyle' in $$props) $$invalidate(2, highlightedStyle = $$props.highlightedStyle);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [columns, values, highlightedStyle];
    }

    class PointerzTable extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$y, create_fragment$y, safe_not_equal, {
    			columns: 0,
    			values: 1,
    			highlightedStyle: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PointerzTable",
    			options,
    			id: create_fragment$y.name
    		});
    	}

    	get columns() {
    		throw new Error("<PointerzTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set columns(value) {
    		throw new Error("<PointerzTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get values() {
    		throw new Error("<PointerzTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set values(value) {
    		throw new Error("<PointerzTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get highlightedStyle() {
    		throw new Error("<PointerzTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set highlightedStyle(value) {
    		throw new Error("<PointerzTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\client\svelte\components\ui\BackButton.svelte generated by Svelte v3.50.1 */
    const file$v = "src\\client\\svelte\\components\\ui\\BackButton.svelte";

    function create_fragment$x(ctx) {
    	let div1;
    	let div0;
    	let img;
    	let img_src_value;
    	let div1_intro;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			img = element("img");
    			attr_dev(img, "class", "actionImage svelte-18shs4b");
    			attr_dev(img, "alt", "actionImage");
    			if (!src_url_equal(img.src, img_src_value = "../../../assets/images/editorCircuitActions/back.png")) attr_dev(img, "src", img_src_value);
    			add_location(img, file$v, 21, 4, 509);
    			attr_dev(div0, "class", "actionContainer svelte-18shs4b");
    			add_location(div0, file$v, 20, 2, 474);
    			attr_dev(div1, "class", "actionsMenuContainer svelte-18shs4b");
    			add_location(div1, file$v, 16, 0, 360);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, img);

    			if (!mounted) {
    				dispose = listen_dev(div1, "click", /*goBackWithSound*/ ctx[0], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (!div1_intro) {
    				add_render_callback(() => {
    					div1_intro = create_in_transition(div1, fade, { delay: 800, duration: 100 });
    					div1_intro.start();
    				});
    			}
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('BackButton', slots, []);
    	let { backHref = undefined } = $$props;

    	let { goBack = function () {
    		push(backHref);
    	} } = $$props;

    	function goBackWithSound() {
    		Client$1.phaser.playSound("cancelClick");
    		goBack();
    	}

    	const writable_props = ['backHref', 'goBack'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BackButton> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('backHref' in $$props) $$invalidate(1, backHref = $$props.backHref);
    		if ('goBack' in $$props) $$invalidate(2, goBack = $$props.goBack);
    	};

    	$$self.$capture_state = () => ({
    		backHref,
    		push,
    		fade,
    		Client: Client$1,
    		goBack,
    		goBackWithSound
    	});

    	$$self.$inject_state = $$props => {
    		if ('backHref' in $$props) $$invalidate(1, backHref = $$props.backHref);
    		if ('goBack' in $$props) $$invalidate(2, goBack = $$props.goBack);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [goBackWithSound, backHref, goBack];
    }

    class BackButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$x, create_fragment$x, safe_not_equal, { backHref: 1, goBack: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BackButton",
    			options,
    			id: create_fragment$x.name
    		});
    	}

    	get backHref() {
    		throw new Error("<BackButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backHref(value) {
    		throw new Error("<BackButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get goBack() {
    		throw new Error("<BackButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set goBack(value) {
    		throw new Error("<BackButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\client\svelte\components\ui\OfflineRedirect.svelte generated by Svelte v3.50.1 */

    function create_fragment$w(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let $userModel;
    	validate_store(userModel, 'userModel');
    	component_subscribe($$self, userModel, $$value => $$invalidate(2, $userModel = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('OfflineRedirect', slots, ['default']);

    	function isLoggedIn() {
    		return $userModel;
    	}

    	if (!isLoggedIn()) {
    		// Redirect to main page if not logged in
    		window.location.href = "/";
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<OfflineRedirect> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		userModel,
    		isLoggedIn,
    		$userModel
    	});

    	return [$$scope, slots];
    }

    class OfflineRedirect extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$w, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "OfflineRedirect",
    			options,
    			id: create_fragment$w.name
    		});
    	}
    }

    /* src\client\svelte\pages\CampaignMenu.svelte generated by Svelte v3.50.1 */
    const file$u = "src\\client\\svelte\\pages\\CampaignMenu.svelte";

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	child_ctx[15] = i;
    	return child_ctx;
    }

    // (127:4) {#if $loggedIn}
    function create_if_block_1$a(ctx) {
    	let backbutton;
    	let current;

    	backbutton = new BackButton({
    			props: { backHref: "/privatemenu" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(backbutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(backbutton, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(backbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(backbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(backbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(127:4) {#if $loggedIn}",
    		ctx
    	});

    	return block;
    }

    // (137:10) <TextBlock              clickable              color={selectedCircuitIndex === i ? "darkOrange" : "grey"}              on:click={() => selectCircuit(i)}              elementsPerRow={columnsNumber}              lastElementOfRow={(i + 1) % columnsNumber == 0}              lastRow={$loadedCircuits.length - (i + 1) < columnsNumber}>
    function create_default_slot_7$3(ctx) {
    	let span0;
    	let t0_value = /*i*/ ctx[15] + 1 + "";
    	let t0;
    	let t1;
    	let span1;

    	let raw_value = (/*circuit*/ ctx[13].userRecord
    	? "TOP " + (/*circuit*/ ctx[13].userRecord.ranking + 1)
    	: 'TOP <span style="font-size: 150%;margin-top:-12px;display:inline-block;">∞</span>') + "";

    	let t2;

    	const block = {
    		c: function create() {
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			span1 = element("span");
    			t2 = space();
    			attr_dev(span0, "class", "circuitNumber svelte-8rqk53");
    			add_location(span0, file$u, 143, 12, 5104);
    			attr_dev(span1, "class", "circuitTop svelte-8rqk53");
    			add_location(span1, file$u, 144, 12, 5160);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span0, anchor);
    			append_dev(span0, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, span1, anchor);
    			span1.innerHTML = raw_value;
    			insert_dev(target, t2, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$loadedCircuits*/ 2 && raw_value !== (raw_value = (/*circuit*/ ctx[13].userRecord
    			? "TOP " + (/*circuit*/ ctx[13].userRecord.ranking + 1)
    			: 'TOP <span style="font-size: 150%;margin-top:-12px;display:inline-block;">∞</span>') + "")) span1.innerHTML = raw_value;		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(span1);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$3.name,
    		type: "slot",
    		source: "(137:10) <TextBlock              clickable              color={selectedCircuitIndex === i ? \\\"darkOrange\\\" : \\\"grey\\\"}              on:click={() => selectCircuit(i)}              elementsPerRow={columnsNumber}              lastElementOfRow={(i + 1) % columnsNumber == 0}              lastRow={$loadedCircuits.length - (i + 1) < columnsNumber}>",
    		ctx
    	});

    	return block;
    }

    // (136:8) {#each $loadedCircuits as circuit, i}
    function create_each_block$a(ctx) {
    	let textblock;
    	let current;

    	function click_handler() {
    		return /*click_handler*/ ctx[8](/*i*/ ctx[15]);
    	}

    	textblock = new TextBlock({
    			props: {
    				clickable: true,
    				color: /*selectedCircuitIndex*/ ctx[0] === /*i*/ ctx[15]
    				? "darkOrange"
    				: "grey",
    				elementsPerRow: /*columnsNumber*/ ctx[4],
    				lastElementOfRow: (/*i*/ ctx[15] + 1) % /*columnsNumber*/ ctx[4] == 0,
    				lastRow: /*$loadedCircuits*/ ctx[1].length - (/*i*/ ctx[15] + 1) < /*columnsNumber*/ ctx[4],
    				$$slots: { default: [create_default_slot_7$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	textblock.$on("click", click_handler);

    	const block = {
    		c: function create() {
    			create_component(textblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(textblock, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const textblock_changes = {};

    			if (dirty & /*selectedCircuitIndex*/ 1) textblock_changes.color = /*selectedCircuitIndex*/ ctx[0] === /*i*/ ctx[15]
    			? "darkOrange"
    			: "grey";

    			if (dirty & /*$loadedCircuits*/ 2) textblock_changes.lastRow = /*$loadedCircuits*/ ctx[1].length - (/*i*/ ctx[15] + 1) < /*columnsNumber*/ ctx[4];

    			if (dirty & /*$$scope, $loadedCircuits*/ 65538) {
    				textblock_changes.$$scope = { dirty, ctx };
    			}

    			textblock.$set(textblock_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(textblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$a.name,
    		type: "each",
    		source: "(136:8) {#each $loadedCircuits as circuit, i}",
    		ctx
    	});

    	return block;
    }

    // (131:6) <Cell          title="Circuits"          style="width:{totalColumnsSize + 2 * css.default.margin}px;"          color="orange"          titleImagePath="assets/images/menu/circuit.png">
    function create_default_slot_6$4(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*$loadedCircuits*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*selectedCircuitIndex, columnsNumber, $loadedCircuits, selectCircuit*/ 83) {
    				each_value = /*$loadedCircuits*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$a(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$a(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$4.name,
    		type: "slot",
    		source: "(131:6) <Cell          title=\\\"Circuits\\\"          style=\\\"width:{totalColumnsSize + 2 * css.default.margin}px;\\\"          color=\\\"orange\\\"          titleImagePath=\\\"assets/images/menu/circuit.png\\\">",
    		ctx
    	});

    	return block;
    }

    // (159:8) {#if selectedCircuitIndex >= 0}
    function create_if_block$i(ctx) {
    	let div;
    	let flexcontainer;
    	let div_transition;
    	let current;

    	flexcontainer = new FlexContainer({
    			props: {
    				flexFlow: "column",
    				$$slots: { default: [create_default_slot_3$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(flexcontainer.$$.fragment);
    			add_location(div, file$u, 159, 10, 5726);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(flexcontainer, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const flexcontainer_changes = {};

    			if (dirty & /*$$scope, $loadedCircuits, selectedCircuitIndex*/ 65539) {
    				flexcontainer_changes.$$scope = { dirty, ctx };
    			}

    			flexcontainer.$set(flexcontainer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(flexcontainer.$$.fragment, local);

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {}, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(flexcontainer.$$.fragment, local);
    			if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {}, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(flexcontainer);
    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(159:8) {#if selectedCircuitIndex >= 0}",
    		ctx
    	});

    	return block;
    }

    // (162:14) <TextBlock elementsPerRow="1" color="darkBlue">
    function create_default_slot_5$4(ctx) {
    	let pointerztable;
    	let updating_values;
    	let current;

    	function pointerztable_values_binding(value) {
    		/*pointerztable_values_binding*/ ctx[9](value);
    	}

    	let pointerztable_props = { columns: /*recordsTableColumns*/ ctx[3] };

    	if (/*$loadedCircuits*/ ctx[1][/*selectedCircuitIndex*/ ctx[0]].runs !== void 0) {
    		pointerztable_props.values = /*$loadedCircuits*/ ctx[1][/*selectedCircuitIndex*/ ctx[0]].runs;
    	}

    	pointerztable = new PointerzTable({
    			props: pointerztable_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(pointerztable, 'values', pointerztable_values_binding));

    	const block = {
    		c: function create() {
    			create_component(pointerztable.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pointerztable, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pointerztable_changes = {};

    			if (!updating_values && dirty & /*$loadedCircuits, selectedCircuitIndex*/ 3) {
    				updating_values = true;
    				pointerztable_changes.values = /*$loadedCircuits*/ ctx[1][/*selectedCircuitIndex*/ ctx[0]].runs;
    				add_flush_callback(() => updating_values = false);
    			}

    			pointerztable.$set(pointerztable_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerztable.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerztable.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pointerztable, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$4.name,
    		type: "slot",
    		source: "(162:14) <TextBlock elementsPerRow=\\\"1\\\" color=\\\"darkBlue\\\">",
    		ctx
    	});

    	return block;
    }

    // (168:16) <PointerzButton                    buttonColor="darkBlue"                    important                    elementsPerRow="1"                    on:click={joinRace}>
    function create_default_slot_4$4(ctx) {
    	let t;
    	let span;
    	let svg;
    	let g;
    	let path0;
    	let path1;
    	let path2;

    	const block = {
    		c: function create() {
    			t = text("Start\r\n                  ");
    			span = element("span");
    			svg = svg_element("svg");
    			g = svg_element("g");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			attr_dev(path0, "class", "one svelte-8rqk53");
    			attr_dev(path0, "d", "M40.1543933,3.89485454 L43.9763149,0.139296592 C44.1708311,-0.0518420739 44.4826329,-0.0518571125 44.6771675,0.139262789 L65.6916134,20.7848311 C66.0855801,21.1718824 66.0911863,21.8050225 65.704135,22.1989893 C65.7000188,22.2031791 65.6958657,22.2073326 65.6916762,22.2114492 L44.677098,42.8607841 C44.4825957,43.0519059 44.1708242,43.0519358 43.9762853,42.8608513 L40.1545186,39.1069479 C39.9575152,38.9134427 39.9546793,38.5968729 40.1481845,38.3998695 C40.1502893,38.3977268 40.1524132,38.395603 40.1545562,38.3934985 L56.9937789,21.8567812 C57.1908028,21.6632968 57.193672,21.3467273 57.0001876,21.1497035 C56.9980647,21.1475418 56.9959223,21.1453995 56.9937605,21.1432767 L40.1545208,4.60825197 C39.9574869,4.41477773 39.9546013,4.09820839 40.1480756,3.90117456 C40.1501626,3.89904911 40.1522686,3.89694235 40.1543933,3.89485454 Z");
    			attr_dev(path0, "fill", "var(--almost-white-color)");
    			add_location(path0, file$u, 187, 24, 6903);
    			attr_dev(path1, "class", "two svelte-8rqk53");
    			attr_dev(path1, "d", "M20.1543933,3.89485454 L23.9763149,0.139296592 C24.1708311,-0.0518420739 24.4826329,-0.0518571125 24.6771675,0.139262789 L45.6916134,20.7848311 C46.0855801,21.1718824 46.0911863,21.8050225 45.704135,22.1989893 C45.7000188,22.2031791 45.6958657,22.2073326 45.6916762,22.2114492 L24.677098,42.8607841 C24.4825957,43.0519059 24.1708242,43.0519358 23.9762853,42.8608513 L20.1545186,39.1069479 C19.9575152,38.9134427 19.9546793,38.5968729 20.1481845,38.3998695 C20.1502893,38.3977268 20.1524132,38.395603 20.1545562,38.3934985 L36.9937789,21.8567812 C37.1908028,21.6632968 37.193672,21.3467273 37.0001876,21.1497035 C36.9980647,21.1475418 36.9959223,21.1453995 36.9937605,21.1432767 L20.1545208,4.60825197 C19.9574869,4.41477773 19.9546013,4.09820839 20.1480756,3.90117456 C20.1501626,3.89904911 20.1522686,3.89694235 20.1543933,3.89485454 Z");
    			attr_dev(path1, "fill", "var(--almost-white-color)");
    			add_location(path1, file$u, 191, 24, 7904);
    			attr_dev(path2, "class", "three svelte-8rqk53");
    			attr_dev(path2, "d", "M0.154393339,3.89485454 L3.97631488,0.139296592 C4.17083111,-0.0518420739 4.48263286,-0.0518571125 4.67716753,0.139262789 L25.6916134,20.7848311 C26.0855801,21.1718824 26.0911863,21.8050225 25.704135,22.1989893 C25.7000188,22.2031791 25.6958657,22.2073326 25.6916762,22.2114492 L4.67709797,42.8607841 C4.48259567,43.0519059 4.17082418,43.0519358 3.97628526,42.8608513 L0.154518591,39.1069479 C-0.0424848215,38.9134427 -0.0453206733,38.5968729 0.148184538,38.3998695 C0.150289256,38.3977268 0.152413239,38.395603 0.154556228,38.3934985 L16.9937789,21.8567812 C17.1908028,21.6632968 17.193672,21.3467273 17.0001876,21.1497035 C16.9980647,21.1475418 16.9959223,21.1453995 16.9937605,21.1432767 L0.15452076,4.60825197 C-0.0425130651,4.41477773 -0.0453986756,4.09820839 0.148075568,3.90117456 C0.150162624,3.89904911 0.152268631,3.89694235 0.154393339,3.89485454 Z");
    			attr_dev(path2, "fill", "var(--almost-white-color)");
    			add_location(path2, file$u, 195, 24, 8905);
    			attr_dev(g, "id", "arrow");
    			attr_dev(g, "stroke", "none");
    			attr_dev(g, "stroke-width", "1");
    			attr_dev(g, "fill", "none");
    			attr_dev(g, "fill-rule", "evenodd");
    			add_location(g, file$u, 181, 22, 6675);
    			attr_dev(svg, "width", "32px");
    			attr_dev(svg, "height", "43px");
    			attr_dev(svg, "viewBox", "0 0 66 43");
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			add_location(svg, file$u, 174, 20, 6369);
    			attr_dev(span, "class", "arrowContainer svelte-8rqk53");
    			add_location(span, file$u, 173, 18, 6318);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			insert_dev(target, span, anchor);
    			append_dev(span, svg);
    			append_dev(svg, g);
    			append_dev(g, path0);
    			append_dev(g, path1);
    			append_dev(g, path2);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$4.name,
    		type: "slot",
    		source: "(168:16) <PointerzButton                    buttonColor=\\\"darkBlue\\\"                    important                    elementsPerRow=\\\"1\\\"                    on:click={joinRace}>",
    		ctx
    	});

    	return block;
    }

    // (161:12) <FlexContainer flexFlow="column">
    function create_default_slot_3$5(ctx) {
    	let textblock;
    	let t;
    	let div;
    	let pointerzbutton;
    	let current;

    	textblock = new TextBlock({
    			props: {
    				elementsPerRow: "1",
    				color: "darkBlue",
    				$$slots: { default: [create_default_slot_5$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pointerzbutton = new PointerzButton({
    			props: {
    				buttonColor: "darkBlue",
    				important: true,
    				elementsPerRow: "1",
    				$$slots: { default: [create_default_slot_4$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pointerzbutton.$on("click", /*joinRace*/ ctx[7]);

    	const block = {
    		c: function create() {
    			create_component(textblock.$$.fragment);
    			t = space();
    			div = element("div");
    			create_component(pointerzbutton.$$.fragment);
    			attr_dev(div, "class", "buttonContainer svelte-8rqk53");
    			add_location(div, file$u, 166, 14, 6062);
    		},
    		m: function mount(target, anchor) {
    			mount_component(textblock, target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(pointerzbutton, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const textblock_changes = {};

    			if (dirty & /*$$scope, $loadedCircuits, selectedCircuitIndex*/ 65539) {
    				textblock_changes.$$scope = { dirty, ctx };
    			}

    			textblock.$set(textblock_changes);
    			const pointerzbutton_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				pointerzbutton_changes.$$scope = { dirty, ctx };
    			}

    			pointerzbutton.$set(pointerzbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textblock.$$.fragment, local);
    			transition_in(pointerzbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textblock.$$.fragment, local);
    			transition_out(pointerzbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(textblock, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    			destroy_component(pointerzbutton);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$5.name,
    		type: "slot",
    		source: "(161:12) <FlexContainer flexFlow=\\\"column\\\">",
    		ctx
    	});

    	return block;
    }

    // (152:6) <Cell          style="              width:{css.default.blockWidth + 2 * css.default.margin}px;            "          title="Ranking"          titleImagePath="assets/images/menu/trophy.png"          color="blue">
    function create_default_slot_2$5(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*selectedCircuitIndex*/ ctx[0] >= 0 && create_if_block$i(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*selectedCircuitIndex*/ ctx[0] >= 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*selectedCircuitIndex*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$i(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$5.name,
    		type: "slot",
    		source: "(152:6) <Cell          style=\\\"              width:{css.default.blockWidth + 2 * css.default.margin}px;            \\\"          title=\\\"Ranking\\\"          titleImagePath=\\\"assets/images/menu/trophy.png\\\"          color=\\\"blue\\\">",
    		ctx
    	});

    	return block;
    }

    // (130:4) <FlexContainer flexWrap="wrap" justifyContent="center">
    function create_default_slot_1$6(ctx) {
    	let cell0;
    	let t;
    	let cell1;
    	let current;

    	cell0 = new Cell({
    			props: {
    				title: "Circuits",
    				style: "width:" + (/*totalColumnsSize*/ ctx[5] + 2 * css.default.margin) + "px;",
    				color: "orange",
    				titleImagePath: "assets/images/menu/circuit.png",
    				$$slots: { default: [create_default_slot_6$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	cell1 = new Cell({
    			props: {
    				style: "\r\n            width:" + (css.default.blockWidth + 2 * css.default.margin) + "px;\r\n          ",
    				title: "Ranking",
    				titleImagePath: "assets/images/menu/trophy.png",
    				color: "blue",
    				$$slots: { default: [create_default_slot_2$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(cell0.$$.fragment);
    			t = space();
    			create_component(cell1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(cell0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(cell1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const cell0_changes = {};

    			if (dirty & /*$$scope, $loadedCircuits, selectedCircuitIndex*/ 65539) {
    				cell0_changes.$$scope = { dirty, ctx };
    			}

    			cell0.$set(cell0_changes);
    			const cell1_changes = {};

    			if (dirty & /*$$scope, $loadedCircuits, selectedCircuitIndex*/ 65539) {
    				cell1_changes.$$scope = { dirty, ctx };
    			}

    			cell1.$set(cell1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cell0.$$.fragment, local);
    			transition_in(cell1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cell0.$$.fragment, local);
    			transition_out(cell1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cell0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(cell1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$6.name,
    		type: "slot",
    		source: "(130:4) <FlexContainer flexWrap=\\\"wrap\\\" justifyContent=\\\"center\\\">",
    		ctx
    	});

    	return block;
    }

    // (124:0) <AppLayout>
    function create_default_slot$a(ctx) {
    	let offlineredirect;
    	let t0;
    	let div;
    	let t1;
    	let flexcontainer;
    	let div_intro;
    	let div_outro;
    	let current;
    	offlineredirect = new OfflineRedirect({ $$inline: true });
    	let if_block = /*$loggedIn*/ ctx[2] && create_if_block_1$a(ctx);

    	flexcontainer = new FlexContainer({
    			props: {
    				flexWrap: "wrap",
    				justifyContent: "center",
    				$$slots: { default: [create_default_slot_1$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(offlineredirect.$$.fragment);
    			t0 = space();
    			div = element("div");
    			if (if_block) if_block.c();
    			t1 = space();
    			create_component(flexcontainer.$$.fragment);
    			add_location(div, file$u, 125, 2, 4298);
    		},
    		m: function mount(target, anchor) {
    			mount_component(offlineredirect, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t1);
    			mount_component(flexcontainer, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$loggedIn*/ ctx[2]) {
    				if (if_block) {
    					if (dirty & /*$loggedIn*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$a(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, t1);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const flexcontainer_changes = {};

    			if (dirty & /*$$scope, $loadedCircuits, selectedCircuitIndex*/ 65539) {
    				flexcontainer_changes.$$scope = { dirty, ctx };
    			}

    			flexcontainer.$set(flexcontainer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(offlineredirect.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(flexcontainer.$$.fragment, local);

    			add_render_callback(() => {
    				if (div_outro) div_outro.end(1);
    				div_intro = create_in_transition(div, fly, { delay: 400, duration: 400 });
    				div_intro.start();
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(offlineredirect.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(flexcontainer.$$.fragment, local);
    			if (div_intro) div_intro.invalidate();
    			div_outro = create_out_transition(div, fade, { duration: 400 });
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(offlineredirect, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			destroy_component(flexcontainer);
    			if (detaching && div_outro) div_outro.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$a.name,
    		type: "slot",
    		source: "(124:0) <AppLayout>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$v(ctx) {
    	let applayout;
    	let current;

    	applayout = new AppLayout({
    			props: {
    				$$slots: { default: [create_default_slot$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(applayout.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(applayout, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const applayout_changes = {};

    			if (dirty & /*$$scope, $loadedCircuits, selectedCircuitIndex, $loggedIn*/ 65543) {
    				applayout_changes.$$scope = { dirty, ctx };
    			}

    			applayout.$set(applayout_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(applayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(applayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(applayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let $passedData;
    	let $userModel;
    	let $loadedCircuits;
    	let $loggedIn;
    	validate_store(passedData, 'passedData');
    	component_subscribe($$self, passedData, $$value => $$invalidate(11, $passedData = $$value));
    	validate_store(userModel, 'userModel');
    	component_subscribe($$self, userModel, $$value => $$invalidate(12, $userModel = $$value));
    	validate_store(loadedCircuits, 'loadedCircuits');
    	component_subscribe($$self, loadedCircuits, $$value => $$invalidate(1, $loadedCircuits = $$value));
    	validate_store(loggedIn, 'loggedIn');
    	component_subscribe($$self, loggedIn, $$value => $$invalidate(2, $loggedIn = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CampaignMenu', slots, []);
    	let selectedCircuitIndex; // The selected circuit

    	let recordsTableColumns = [
    		{
    			name: "formattedRanking",
    			style: "font-size: 14px;width: fit-content;padding:4px;width:34px;padding-left:8px;"
    		},
    		{
    			name: "nickname",
    			style: "font-size: 18px;font-family: 'Nunito Bold';padding:4px;"
    		},
    		{
    			name: "formattedRunTime",
    			style: "text-align: right;font-style: italic;font-size: 16px;width: 84px; vertical-align: bottom;padding:4px;padding-right:8px;"
    		}
    	];

    	let columnsNumber = Math.min(3, Math.max(1, Math.floor((window.innerWidth - 2 * css.default.margin - 2 * css.uiContainer.maxMargin) / (css.default.blockWidth + css.default.margin)) - 1));
    	let totalColumnsSize = columnsNumber * (css.default.blockWidth + css.default.margin) - css.default.margin;

    	// Update the selected circuit index
    	function selectCircuit(i) {
    		Client$1.phaser.playSound("buttonSelection");
    		$$invalidate(0, selectedCircuitIndex = i);
    	}

    	// Join the selected circuit
    	function joinRace() {
    		if (Client$1.race.user) {
    			// If there is already a current race going on, it is not possible
    			return;
    		}

    		Client$1.pushRoute("/race");

    		// Ask to the server the race data
    		Client$1.socket.emitJoinNewRoom($loadedCircuits[selectedCircuitIndex]._id);
    	}

    	// Update the display according to the new records, triggered when logged in and when asked for updating records
    	Client$1.svelte.updateRecordsDisplay = function (circuits, records) {
    		if (!records || !circuits) {
    			return;
    		}

    		set_store_value(loadedCircuits, $loadedCircuits = [...circuits], $loadedCircuits);

    		// Add the records to the circuits
    		$loadedCircuits.forEach((circuit, i) => {
    			let recordForCircuit = i < records.length && records[i].run
    			? records[i]
    			: undefined;

    			if (recordForCircuit) {
    				// If there is a record by the user
    				circuit.userRecord = recordForCircuit; // Add the user record to the circuit object for easier understanding

    				if (!circuit.runs.filter(run => run._userId == $userModel._id).length) {
    					// If there is no record by this user in the five best times, add it to the table
    					recordForCircuit.run.formattedRanking = recordForCircuit.ranking + 1;

    					circuit.runs.push(recordForCircuit.run);
    				}
    			}

    			if (circuit.rankingFormatted) return;
    			circuit.rankingFormatted = true;

    			circuit.runs.forEach((globalRecord, j) => {
    				if (globalRecord._userId == $userModel._id) {
    					// Highlight the user record in the list
    					globalRecord.highlighted = true;
    				}

    				if (!globalRecord.formattedRanking) {
    					// Add the ranking
    					globalRecord.formattedRanking = j + 1;
    				}

    				// Format the whole for displaying
    				globalRecord.formattedRanking = globalRecord.formattedRanking + "<sup>" + Client$1.getSupFromNumber(globalRecord.formattedRanking) + "</sup>";

    				globalRecord.formattedRunTime = Client$1.race.Functions.msToTime(globalRecord.runTime, 3);
    			});
    		});
    	};

    	Client$1.svelte.updateRecordsDisplay($passedData.circuits, $passedData.records); // Update the records according to tge data sent during the logging in
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CampaignMenu> was created with unknown prop '${key}'`);
    	});

    	const click_handler = i => selectCircuit(i);

    	function pointerztable_values_binding(value) {
    		if ($$self.$$.not_equal($loadedCircuits[selectedCircuitIndex].runs, value)) {
    			$loadedCircuits[selectedCircuitIndex].runs = value;
    			loadedCircuits.set($loadedCircuits);
    		}
    	}

    	$$self.$capture_state = () => ({
    		slide,
    		fly,
    		fade,
    		Client: Client$1,
    		loadedCircuits,
    		userModel,
    		passedData,
    		loggedIn,
    		css,
    		AppLayout,
    		PointerzButton,
    		FlexContainer,
    		Cell,
    		TextBlock,
    		PointerzTable,
    		BackButton,
    		OfflineRedirect,
    		selectedCircuitIndex,
    		recordsTableColumns,
    		columnsNumber,
    		totalColumnsSize,
    		selectCircuit,
    		joinRace,
    		$passedData,
    		$userModel,
    		$loadedCircuits,
    		$loggedIn
    	});

    	$$self.$inject_state = $$props => {
    		if ('selectedCircuitIndex' in $$props) $$invalidate(0, selectedCircuitIndex = $$props.selectedCircuitIndex);
    		if ('recordsTableColumns' in $$props) $$invalidate(3, recordsTableColumns = $$props.recordsTableColumns);
    		if ('columnsNumber' in $$props) $$invalidate(4, columnsNumber = $$props.columnsNumber);
    		if ('totalColumnsSize' in $$props) $$invalidate(5, totalColumnsSize = $$props.totalColumnsSize);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		selectedCircuitIndex,
    		$loadedCircuits,
    		$loggedIn,
    		recordsTableColumns,
    		columnsNumber,
    		totalColumnsSize,
    		selectCircuit,
    		joinRace,
    		click_handler,
    		pointerztable_values_binding
    	];
    }

    class CampaignMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$v, create_fragment$v, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CampaignMenu",
    			options,
    			id: create_fragment$v.name
    		});
    	}
    }

    /* src\client\svelte\pages\PrivateMenu.svelte generated by Svelte v3.50.1 */

    const { Object: Object_1$1 } = globals;
    const file$t = "src\\client\\svelte\\pages\\PrivateMenu.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[15] = list[i][0];
    	child_ctx[16] = list[i][1];
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[19] = list[i];
    	return child_ctx;
    }

    // (115:2) {#if isModifyingSpaceship}
    function create_if_block_2$6(ctx) {
    	let backbutton;
    	let current;

    	backbutton = new BackButton({
    			props: { goBack: /*goBack*/ ctx[9] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(backbutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(backbutton, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(backbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(backbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(backbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(115:2) {#if isModifyingSpaceship}",
    		ctx
    	});

    	return block;
    }

    // (178:6) {:else}
    function create_else_block$6(ctx) {
    	let div;
    	let div_intro;
    	let div_outro;
    	let current;
    	let each_value = Object.entries(/*groupedNFTs*/ ctx[2]);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "spaceship-elements-container svelte-18vt19h");
    			add_location(div, file$t, 178, 8, 5175);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Object, groupedNFTs, selectNFT, Client*/ 20) {
    				each_value = Object.entries(/*groupedNFTs*/ ctx[2]);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$9(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$9(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (div_outro) div_outro.end(1);
    				div_intro = create_in_transition(div, fade, { delay: 400, duration: 400 });
    				div_intro.start();
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (div_intro) div_intro.invalidate();
    			div_outro = create_out_transition(div, fade, { duration: 400 });
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			if (detaching && div_outro) div_outro.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(178:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (125:6) {#if !isModifyingSpaceship}
    function create_if_block_1$9(ctx) {
    	let div;
    	let pointerzbutton0;
    	let t0;
    	let pointerzbutton1;
    	let t1;
    	let pointerzbutton2;
    	let div_intro;
    	let div_outro;
    	let current;

    	pointerzbutton0 = new PointerzButton({
    			props: {
    				buttonColor: "darkBlue",
    				important: true,
    				noMargins: true,
    				fullHeight: true,
    				animating: true,
    				$$slots: { default: [create_default_slot_3$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pointerzbutton0.$on("click", /*goToCampaignMenu*/ ctx[6]);

    	pointerzbutton1 = new PointerzButton({
    			props: {
    				buttonColor: "darkBlue",
    				important: true,
    				noMargins: true,
    				fullHeight: true,
    				animating: true,
    				$$slots: { default: [create_default_slot_2$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pointerzbutton1.$on("click", /*goToNextCircuitVote*/ ctx[7]);

    	pointerzbutton2 = new PointerzButton({
    			props: {
    				buttonColor: "darkBlue",
    				important: true,
    				noMargins: true,
    				fullHeight: true,
    				animating: true,
    				$$slots: { default: [create_default_slot_1$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pointerzbutton2.$on("click", /*goToCircuitEditor*/ ctx[5]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(pointerzbutton0.$$.fragment);
    			t0 = space();
    			create_component(pointerzbutton1.$$.fragment);
    			t1 = space();
    			create_component(pointerzbutton2.$$.fragment);
    			attr_dev(div, "class", "menu-column svelte-18vt19h");
    			add_location(div, file$t, 125, 8, 3587);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(pointerzbutton0, div, null);
    			append_dev(div, t0);
    			mount_component(pointerzbutton1, div, null);
    			append_dev(div, t1);
    			mount_component(pointerzbutton2, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pointerzbutton0_changes = {};

    			if (dirty & /*$$scope*/ 4194304) {
    				pointerzbutton0_changes.$$scope = { dirty, ctx };
    			}

    			pointerzbutton0.$set(pointerzbutton0_changes);
    			const pointerzbutton1_changes = {};

    			if (dirty & /*$$scope*/ 4194304) {
    				pointerzbutton1_changes.$$scope = { dirty, ctx };
    			}

    			pointerzbutton1.$set(pointerzbutton1_changes);
    			const pointerzbutton2_changes = {};

    			if (dirty & /*$$scope*/ 4194304) {
    				pointerzbutton2_changes.$$scope = { dirty, ctx };
    			}

    			pointerzbutton2.$set(pointerzbutton2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerzbutton0.$$.fragment, local);
    			transition_in(pointerzbutton1.$$.fragment, local);
    			transition_in(pointerzbutton2.$$.fragment, local);

    			add_render_callback(() => {
    				if (div_outro) div_outro.end(1);
    				div_intro = create_in_transition(div, fade, { delay: 400, duration: 400 });
    				div_intro.start();
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerzbutton0.$$.fragment, local);
    			transition_out(pointerzbutton1.$$.fragment, local);
    			transition_out(pointerzbutton2.$$.fragment, local);
    			if (div_intro) div_intro.invalidate();
    			div_outro = create_out_transition(div, fade, { duration: 400 });
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(pointerzbutton0);
    			destroy_component(pointerzbutton1);
    			destroy_component(pointerzbutton2);
    			if (detaching && div_outro) div_outro.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(125:6) {#if !isModifyingSpaceship}",
    		ctx
    	});

    	return block;
    }

    // (187:16) {#each items as item}
    function create_each_block_1$1(ctx) {
    	let div1;
    	let div0;
    	let span0;
    	let t0_value = /*item*/ ctx[19].nftName + "";
    	let t0;
    	let t1;
    	let span1;
    	let t2_value = Client$1.race.Constants.nftRarityInfo[/*item*/ ctx[19].nftRarity].name + "";
    	let t2;
    	let t3;
    	let div1_class_value;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[12](/*item*/ ctx[19]);
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			attr_dev(span0, "class", "item-name svelte-18vt19h");
    			add_location(span0, file$t, 191, 22, 5792);
    			attr_dev(span1, "class", "rarity-badge svelte-18vt19h");
    			set_style(span1, "color", "var(" + Client$1.race.Constants.nftRarityInfo[/*item*/ ctx[19].nftRarity].color + ")");
    			add_location(span1, file$t, 192, 22, 5861);
    			attr_dev(div0, "class", "item-info svelte-18vt19h");
    			add_location(div0, file$t, 190, 20, 5745);
    			attr_dev(div1, "class", div1_class_value = "item-card " + (/*item*/ ctx[19].nftSelected ? 'selected' : '') + " svelte-18vt19h");
    			add_location(div1, file$t, 187, 18, 5588);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, span0);
    			append_dev(span0, t0);
    			append_dev(div0, t1);
    			append_dev(div0, span1);
    			append_dev(span1, t2);
    			append_dev(div1, t3);

    			if (!mounted) {
    				dispose = listen_dev(div1, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*groupedNFTs*/ 4 && t0_value !== (t0_value = /*item*/ ctx[19].nftName + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*groupedNFTs*/ 4 && t2_value !== (t2_value = Client$1.race.Constants.nftRarityInfo[/*item*/ ctx[19].nftRarity].name + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*groupedNFTs*/ 4) {
    				set_style(span1, "color", "var(" + Client$1.race.Constants.nftRarityInfo[/*item*/ ctx[19].nftRarity].color + ")");
    			}

    			if (dirty & /*groupedNFTs*/ 4 && div1_class_value !== (div1_class_value = "item-card " + (/*item*/ ctx[19].nftSelected ? 'selected' : '') + " svelte-18vt19h")) {
    				attr_dev(div1, "class", div1_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(187:16) {#each items as item}",
    		ctx
    	});

    	return block;
    }

    // (183:10) {#each Object.entries(groupedNFTs) as [category, items]}
    function create_each_block$9(ctx) {
    	let div1;
    	let h2;
    	let t0_value = /*category*/ ctx[15] + "";
    	let t0;
    	let t1;
    	let div0;
    	let t2;
    	let each_value_1 = /*items*/ ctx[16];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			attr_dev(h2, "class", "category-title svelte-18vt19h");
    			add_location(h2, file$t, 184, 14, 5447);
    			attr_dev(div0, "class", "items-grid svelte-18vt19h");
    			add_location(div0, file$t, 185, 14, 5505);
    			attr_dev(div1, "class", "category-section svelte-18vt19h");
    			add_location(div1, file$t, 183, 12, 5401);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, h2);
    			append_dev(h2, t0);
    			append_dev(div1, t1);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			append_dev(div1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*groupedNFTs*/ 4 && t0_value !== (t0_value = /*category*/ ctx[15] + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*Object, groupedNFTs, selectNFT, Client*/ 20) {
    				each_value_1 = /*items*/ ctx[16];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(183:10) {#each Object.entries(groupedNFTs) as [category, items]}",
    		ctx
    	});

    	return block;
    }

    // (130:10) <PointerzButton              buttonColor="darkBlue"              important              noMargins              fullHeight              animating              on:click={goToCampaignMenu}>
    function create_default_slot_3$4(ctx) {
    	let div;
    	let span;
    	let t1;
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			span.textContent = "Campaign";
    			t1 = space();
    			img = element("img");
    			add_location(span, file$t, 137, 14, 3970);
    			if (!src_url_equal(img.src, img_src_value = "assets/images/menu/flag.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "Flag");
    			attr_dev(img, "class", "menu-icon svelte-18vt19h");
    			add_location(img, file$t, 138, 14, 4007);
    			attr_dev(div, "class", "button-content svelte-18vt19h");
    			add_location(div, file$t, 136, 12, 3926);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    			append_dev(div, t1);
    			append_dev(div, img);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$4.name,
    		type: "slot",
    		source: "(130:10) <PointerzButton              buttonColor=\\\"darkBlue\\\"              important              noMargins              fullHeight              animating              on:click={goToCampaignMenu}>",
    		ctx
    	});

    	return block;
    }

    // (146:10) <PointerzButton              buttonColor="darkBlue"              important              noMargins              fullHeight              animating              on:click={goToNextCircuitVote}>
    function create_default_slot_2$4(ctx) {
    	let div;
    	let span;
    	let t1;
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			span.textContent = "Next Circuit Vote";
    			t1 = space();
    			img = element("img");
    			add_location(span, file$t, 153, 14, 4438);
    			if (!src_url_equal(img.src, img_src_value = "assets/images/menu/calendar.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "Calendar");
    			attr_dev(img, "class", "menu-icon svelte-18vt19h");
    			add_location(img, file$t, 154, 14, 4484);
    			attr_dev(div, "class", "button-content svelte-18vt19h");
    			add_location(div, file$t, 152, 12, 4394);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    			append_dev(div, t1);
    			append_dev(div, img);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$4.name,
    		type: "slot",
    		source: "(146:10) <PointerzButton              buttonColor=\\\"darkBlue\\\"              important              noMargins              fullHeight              animating              on:click={goToNextCircuitVote}>",
    		ctx
    	});

    	return block;
    }

    // (162:10) <PointerzButton              buttonColor="darkBlue"              important              noMargins              fullHeight              animating              on:click={goToCircuitEditor}>
    function create_default_slot_1$5(ctx) {
    	let div;
    	let span;
    	let t1;
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			span.textContent = "Circuit Editor";
    			t1 = space();
    			img = element("img");
    			add_location(span, file$t, 169, 14, 4921);
    			if (!src_url_equal(img.src, img_src_value = "assets/images/menu/draw.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "Draw");
    			attr_dev(img, "class", "menu-icon svelte-18vt19h");
    			add_location(img, file$t, 170, 14, 4964);
    			attr_dev(div, "class", "button-content svelte-18vt19h");
    			add_location(div, file$t, 168, 12, 4877);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    			append_dev(div, t1);
    			append_dev(div, img);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$5.name,
    		type: "slot",
    		source: "(162:10) <PointerzButton              buttonColor=\\\"darkBlue\\\"              important              noMargins              fullHeight              animating              on:click={goToCircuitEditor}>",
    		ctx
    	});

    	return block;
    }

    // (220:10) {#if !isModifyingSpaceship}
    function create_if_block$h(ctx) {
    	let div1;
    	let div0;
    	let svg;
    	let g;
    	let path;
    	let t;
    	let div1_intro;
    	let div1_outro;
    	let current;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			svg = svg_element("svg");
    			g = svg_element("g");
    			path = svg_element("path");
    			t = text("\r\n                Modify your Pointerz");
    			attr_dev(path, "fill", "currentColor");
    			attr_dev(path, "d", "M119.743,103.298l-29.84-29.84l24.22-24.22c7.864,1.826,16.457-0.269,22.597-6.408\r\n          c6.719-6.713,8.562-16.367,5.74-24.81l-11.403,11.397c-4.034,4.046-10.693,3.92-14.893-0.28\r\n          c-4.183-4.189-4.314-10.848-0.286-14.887l11.397-11.397c-8.425-2.84-18.074-0.985-24.804,5.74\r\n          c-6.128,6.122-8.216,14.714-6.385,22.591l-24.22,24.214L47.657,31.189c1.826-7.87-0.28-16.463-6.402-22.597\r\n          c-6.713-6.719-16.361-8.568-24.804-5.746l11.397,11.403c4.04,4.034,3.92,10.699-0.286,14.893\r\n          c-4.189,4.189-10.836,4.314-14.887,0.286L1.277,18.026c-2.828,8.431-0.979,18.092,5.752,24.81\r\n          c6.116,6.134,14.708,8.216,22.591,6.396l24.208,24.202l-29.834,29.834c-5.43-0.376-10.979,1.426-15.114,5.585\r\n          c-7.626,7.614-7.626,19.965,0,27.591c7.602,7.608,19.959,7.608,27.573,0c4.147-4.147,5.943-9.702,5.597-15.132l29.816-29.828\r\n          l29.84,29.84c-0.37,5.43,1.438,10.985,5.585,15.126c7.608,7.62,19.971,7.62,27.585,0c7.614-7.614,7.614-19.965,0-27.585\r\n          C130.728,104.719,125.173,102.917,119.743,103.298z M25.311,132.56l-9.923-2.649l-2.643-9.923l7.25-7.262l9.923,2.655l2.655,9.917\r\n          L25.311,132.56z M128.335,129.929l-9.917,2.643l-7.262-7.262l2.649-9.917l9.923-2.655l7.268,7.262L128.335,129.929z");
    			add_location(path, file$t, 238, 20, 7487);
    			add_location(g, file$t, 237, 18, 7462);
    			attr_dev(svg, "class", "garage-icon svelte-18vt19h");
    			attr_dev(svg, "height", "30px");
    			attr_dev(svg, "width", "30px");
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "id", "Capa_1");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr_dev(svg, "viewBox", "0 0 143.734 143.734");
    			attr_dev(svg, "xml:space", "preserve");
    			add_location(svg, file$t, 227, 16, 7064);
    			attr_dev(div0, "class", "modifySpaceshipButton svelte-18vt19h");
    			add_location(div0, file$t, 224, 14, 6940);
    			attr_dev(div1, "class", "modifySpaceshipButtonContainer svelte-18vt19h");
    			add_location(div1, file$t, 220, 12, 6775);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, svg);
    			append_dev(svg, g);
    			append_dev(g, path);
    			append_dev(div0, t);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div0, "click", /*goToSpaceshipModification*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (div1_outro) div1_outro.end(1);
    				div1_intro = create_in_transition(div1, slide, { duration: 300 });
    				div1_intro.start();
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (div1_intro) div1_intro.invalidate();
    			div1_outro = create_out_transition(div1, slide, { duration: 1000 });
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (detaching && div1_outro) div1_outro.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(220:10) {#if !isModifyingSpaceship}",
    		ctx
    	});

    	return block;
    }

    // (113:0) <AppLayout>
    function create_default_slot$9(ctx) {
    	let offlineredirect;
    	let t0;
    	let t1;
    	let div9;
    	let div0;
    	let current_block_type_index;
    	let if_block1;
    	let t2;
    	let div8;
    	let div7;
    	let div6;
    	let t3;
    	let div1;
    	let t4;
    	let div5;
    	let div2;
    	let svg0;
    	let path0;
    	let div2_class_value;
    	let t5;
    	let div4;
    	let div3;
    	let svg1;
    	let g;
    	let path1;
    	let div4_class_value;
    	let div9_intro;
    	let div9_outro;
    	let current;
    	let mounted;
    	let dispose;
    	offlineredirect = new OfflineRedirect({ $$inline: true });
    	let if_block0 = /*isModifyingSpaceship*/ ctx[0] && create_if_block_2$6(ctx);
    	const if_block_creators = [create_if_block_1$9, create_else_block$6];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*isModifyingSpaceship*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let if_block2 = !/*isModifyingSpaceship*/ ctx[0] && create_if_block$h(ctx);

    	const block = {
    		c: function create() {
    			create_component(offlineredirect.$$.fragment);
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			div9 = element("div");
    			div0 = element("div");
    			if_block1.c();
    			t2 = space();
    			div8 = element("div");
    			div7 = element("div");
    			div6 = element("div");
    			if (if_block2) if_block2.c();
    			t3 = space();
    			div1 = element("div");
    			t4 = space();
    			div5 = element("div");
    			div2 = element("div");
    			svg0 = svg_element("svg");
    			path0 = svg_element("path");
    			t5 = space();
    			div4 = element("div");
    			div3 = element("div");
    			svg1 = svg_element("svg");
    			g = svg_element("g");
    			path1 = svg_element("path");
    			add_location(div0, file$t, 123, 4, 3537);
    			attr_dev(div1, "id", "spaceshipCanvas");
    			add_location(div1, file$t, 257, 10, 8958);
    			attr_dev(path0, "d", "M5.926 20.574a7.26 7.26 0 0 0 3.039 1.511c.107.035.179-.105.107-.175-2.395-2.285-1.079-4.758-.107-5.873.693-.796 1.68-2.107 1.608-3.865 0-.176.18-.317.322-.211 1.359.703 2.288 2.25 2.538 3.515.394-.386.537-.984.537-1.511 0-.176.214-.317.393-.176 1.287 1.16 3.503 5.097-.072 8.19-.071.071 0 .212.072.177a8.761 8.761 0 0 0 3.003-1.442c5.827-4.5 2.037-12.48-.43-15.116-.321-.317-.893-.106-.893.351-.036.95-.322 2.004-1.072 2.707-.572-2.39-2.478-5.105-5.195-6.441-.357-.176-.786.105-.75.492.07 3.27-2.063 5.352-3.922 8.059-1.645 2.425-2.717 6.89.822 9.808z");
    			attr_dev(path0, "fill", "currentColor");
    			add_location(path0, file$t, 273, 17, 9571);
    			attr_dev(svg0, "width", "64px");
    			attr_dev(svg0, "height", "64px");
    			attr_dev(svg0, "viewBox", "0 0 24 24");
    			attr_dev(svg0, "fill", "none");
    			attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg0, file$t, 267, 14, 9369);

    			attr_dev(div2, "class", div2_class_value = "" + (null_to_empty([
    				/*visualiserEnvironment*/ ctx[1] === /*environments*/ ctx[3].SPACE
    				? "visualiser-button-selected"
    				: "",
    				"visualiser-button"
    			].join(" ")) + " svelte-18vt19h"));

    			add_location(div2, file$t, 259, 12, 9044);
    			attr_dev(path1, "d", "M61.44,21.74c10.96,0,20.89,4.44,28.07,11.63c7.18,7.18,11.63,17.11,11.63,28.07c0,10.96-4.44,20.89-11.63,28.07 c-7.18,7.18-17.11,11.63-28.07,11.63c-10.96,0-20.89-4.44-28.07-11.63c-7.18-7.18-11.63-17.11-11.63-28.07 c0-10.96,4.44-20.89,11.63-28.07C40.55,26.19,50.48,21.74,61.44,21.74L61.44,21.74z M61.44,0c16.97,0,32.33,6.88,43.44,18 c11.12,11.12,18,26.48,18,43.44c0,16.97-6.88,32.33-18,43.44c-11.12,11.12-26.48,18-43.44,18c-16.97,0-32.33-6.88-43.44-18 C6.88,93.77,0,78.41,0,61.44C0,44.47,6.88,29.11,18,18C29.11,6.88,44.47,0,61.44,0L61.44,0z M93.47,29.41 c-8.2-8.2-19.52-13.27-32.03-13.27c-12.51,0-23.83,5.07-32.03,13.27c-8.2,8.2-13.27,19.52-13.27,32.03 c0,12.51,5.07,23.83,13.27,32.03c8.2,8.2,19.52,13.27,32.03,13.27c12.51,0,23.83-5.07,32.03-13.27c8.2-8.2,13.27-19.52,13.27-32.03 C106.74,48.93,101.67,37.61,93.47,29.41L93.47,29.41z M65.45,56.77c-1.02-1.02-2.43-1.65-4.01-1.65c-1.57,0-2.99,0.63-4.01,1.65 l-0.01,0.01c-1.02,1.02-1.65,2.43-1.65,4.01c0,1.57,0.63,2.99,1.65,4.01l0.01,0.01c1.02,1.02,2.43,1.65,4.01,1.65 c1.57,0,2.99-0.63,4.01-1.65l0.01-0.01c1.02-1.02,1.65-2.44,1.65-4.01C67.1,59.21,66.47,57.8,65.45,56.77L65.45,56.77L65.45,56.77z M65.06,50.79c1.47,0.54,2.8,1.39,3.89,2.48l0,0l0,0c0.37,0.37,0.72,0.77,1.03,1.2l0.1-0.03l21.02-5.63 c-1.63-3.83-3.98-7.28-6.88-10.17c-5.03-5.03-11.72-8.41-19.17-9.24v21.12C65.07,50.61,65.07,50.7,65.06,50.79L65.06,50.79z M72.04,61.63c-0.14,1.73-0.69,3.35-1.57,4.76c0.05,0.06,0.09,0.13,0.13,0.2l12.07,19.13c0.54-0.47,1.06-0.96,1.57-1.47 c5.83-5.83,9.44-13.9,9.44-22.8c0-1.87-0.16-3.7-0.47-5.49L72.04,61.63L72.04,61.63z M64.57,70.95c-0.99,0.31-2.04,0.47-3.13,0.47 c-0.98,0-1.93-0.13-2.84-0.38L46.82,90.19c4.39,2.24,9.36,3.5,14.62,3.5c5.46,0,10.6-1.36,15.11-3.75L64.57,70.95L64.57,70.95z M52.57,66.64c-0.92-1.38-1.52-2.99-1.7-4.71l-0.01,0l-21.09-6.6c-0.38,1.98-0.58,4.02-0.58,6.11c0,8.9,3.61,16.97,9.44,22.8 c0.63,0.63,1.29,1.24,1.98,1.82l11.8-19.19C52.47,66.8,52.52,66.72,52.57,66.64L52.57,66.64z M52.72,54.72 c0.36-0.51,0.76-1,1.21-1.44l0,0l0,0c1.05-1.04,2.31-1.87,3.71-2.41c-0.01-0.11-0.02-0.23-0.02-0.34v-21.1 c-7.38,0.87-14,4.23-18.98,9.22c-2.75,2.75-5.01,6-6.63,9.6L52.72,54.72L52.72,54.72z");
    			add_location(path1, file$t, 296, 20, 10962);
    			add_location(g, file$t, 295, 18, 10937);
    			attr_dev(svg1, "fill", "currentColor");
    			attr_dev(svg1, "width", "64px");
    			attr_dev(svg1, "height", "64px");
    			attr_dev(svg1, "viewBox", "0 0 122.88 122.88");
    			attr_dev(svg1, "version", "1.1");
    			attr_dev(svg1, "id", "Layer_1");
    			attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg1, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			add_location(svg1, file$t, 286, 16, 10580);
    			add_location(div3, file$t, 285, 14, 10557);

    			attr_dev(div4, "class", div4_class_value = "" + (null_to_empty([
    				/*visualiserEnvironment*/ ctx[1] === /*environments*/ ctx[3].ROAD
    				? "visualiser-button-selected"
    				: "",
    				"visualiser-button"
    			].join(" ")) + " svelte-18vt19h"));

    			add_location(div4, file$t, 277, 12, 10234);
    			attr_dev(div5, "class", "config-buttons svelte-18vt19h");
    			add_location(div5, file$t, 258, 10, 9002);
    			attr_dev(div6, "class", "canvas-container svelte-18vt19h");

    			attr_dev(div6, "style", {
    				aspectRatio: Client$1.spaceshipVisualiserRatio,
    				width: Client$1.spaceshipVisualiserWidth,
    				height: Client$1.spaceshipVisualiserHeight
    			});

    			add_location(div6, file$t, 212, 8, 6480);
    			attr_dev(div7, "class", "spaceship-viewer svelte-18vt19h");
    			add_location(div7, file$t, 211, 6, 6440);
    			attr_dev(div8, "class", "content-column svelte-18vt19h");
    			add_location(div8, file$t, 210, 4, 6404);
    			attr_dev(div9, "id", "buttonsContainer");
    			attr_dev(div9, "class", "container svelte-18vt19h");
    			add_location(div9, file$t, 118, 2, 3398);
    		},
    		m: function mount(target, anchor) {
    			mount_component(offlineredirect, target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div9, anchor);
    			append_dev(div9, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div9, t2);
    			append_dev(div9, div8);
    			append_dev(div8, div7);
    			append_dev(div7, div6);
    			if (if_block2) if_block2.m(div6, null);
    			append_dev(div6, t3);
    			append_dev(div6, div1);
    			append_dev(div6, t4);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, svg0);
    			append_dev(svg0, path0);
    			append_dev(div5, t5);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, svg1);
    			append_dev(svg1, g);
    			append_dev(g, path1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div2, "click", /*click_handler_1*/ ctx[13], false, false, false),
    					listen_dev(div4, "click", /*click_handler_2*/ ctx[14], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*isModifyingSpaceship*/ ctx[0]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*isModifyingSpaceship*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$6(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				} else {
    					if_block1.p(ctx, dirty);
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(div0, null);
    			}

    			if (!/*isModifyingSpaceship*/ ctx[0]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*isModifyingSpaceship*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$h(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div6, t3);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*visualiserEnvironment*/ 2 && div2_class_value !== (div2_class_value = "" + (null_to_empty([
    				/*visualiserEnvironment*/ ctx[1] === /*environments*/ ctx[3].SPACE
    				? "visualiser-button-selected"
    				: "",
    				"visualiser-button"
    			].join(" ")) + " svelte-18vt19h"))) {
    				attr_dev(div2, "class", div2_class_value);
    			}

    			if (!current || dirty & /*visualiserEnvironment*/ 2 && div4_class_value !== (div4_class_value = "" + (null_to_empty([
    				/*visualiserEnvironment*/ ctx[1] === /*environments*/ ctx[3].ROAD
    				? "visualiser-button-selected"
    				: "",
    				"visualiser-button"
    			].join(" ")) + " svelte-18vt19h"))) {
    				attr_dev(div4, "class", div4_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(offlineredirect.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);

    			add_render_callback(() => {
    				if (div9_outro) div9_outro.end(1);
    				div9_intro = create_in_transition(div9, fly, { delay: 400, duration: 400 });
    				div9_intro.start();
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(offlineredirect.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			if (div9_intro) div9_intro.invalidate();
    			div9_outro = create_out_transition(div9, fade, { duration: 400 });
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(offlineredirect, detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div9);
    			if_blocks[current_block_type_index].d();
    			if (if_block2) if_block2.d();
    			if (detaching && div9_outro) div9_outro.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$9.name,
    		type: "slot",
    		source: "(113:0) <AppLayout>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$u(ctx) {
    	let applayout;
    	let current;

    	applayout = new AppLayout({
    			props: {
    				$$slots: { default: [create_default_slot$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(applayout.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(applayout, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const applayout_changes = {};

    			if (dirty & /*$$scope, visualiserEnvironment, isModifyingSpaceship, groupedNFTs*/ 4194311) {
    				applayout_changes.$$scope = { dirty, ctx };
    			}

    			applayout.$set(applayout_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(applayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(applayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(applayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let groupedNFTs;
    	let $userModel;
    	validate_store(userModel, 'userModel');
    	component_subscribe($$self, userModel, $$value => $$invalidate(11, $userModel = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PrivateMenu', slots, []);
    	let environments = Client$1.race.Constants.environments;
    	let isModifyingSpaceship = false;

    	function selectNFT(item) {
    		Client$1.phaser.playSound("buttonSelection");

    		if (item.nftCategory === "Wheels") {
    			setVisualiserEnvironment(environments.ROAD, false);
    		} else if (item.nftCategory === "Flame") {
    			setVisualiserEnvironment(environments.SPACE, false);
    		}

    		// Create new reference to trigger reactivity
    		$$invalidate(2, groupedNFTs = Object.fromEntries(Object.entries(groupedNFTs).map(([category, items]) => [
    			category,
    			items.map(nft => ({
    				...nft,
    				nftSelected: nft.nftCategory === item.nftCategory
    				? nft === item
    				: nft.nftSelected
    			}))
    		])));

    		// Send the ids of the selected NFTs to the server
    		let selectedNFTs = Object.values(groupedNFTs).flat().filter(nft => nft.nftSelected);

    		Client$1.socket.updateNFTSelection(selectedNFTs.map(nft => nft.nftId));
    		Client$1.phaser.updateVisualiserNFTs(selectedNFTs);
    	}

    	function goToCircuitEditor() {
    		Client$1.pushRoute("/editormenu");
    	}

    	function goToCampaignMenu() {
    		Client$1.pushRoute("/campaignmenu");
    	}

    	function goToNextCircuitVote() {
    		Client$1.pushRoute("/circuitvote");
    	}

    	function goToSpaceshipModification() {
    		Client$1.phaser.playSound("buttonClick");
    		$$invalidate(0, isModifyingSpaceship = true);
    	}

    	function goBack() {
    		$$invalidate(0, isModifyingSpaceship = false);
    	}

    	function setVisualiserEnvironment(newEnvironment, playSound = true) {
    		playSound && Client$1.phaser.playSound("transition");
    		$$invalidate(1, visualiserEnvironment = newEnvironment);
    		Client$1.phaser.setVisualiserEnvironment(newEnvironment);
    	}

    	let visualiserEnvironment = environments.SPACE;

    	onMount(() => {
    		// Load the spaceship visualiser
    		Client$1.phaser.initSpaceshipModificationCanvas(Client$1);
    	});

    	onDestroy(() => {
    		// Destroy the spaceship visualiser
    		Client$1.phaser.destroySpaceshipModificationCanvas();
    	});

    	const writable_props = [];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PrivateMenu> was created with unknown prop '${key}'`);
    	});

    	const click_handler = item => selectNFT(item);
    	const click_handler_1 = () => setVisualiserEnvironment(environments.SPACE);
    	const click_handler_2 = () => setVisualiserEnvironment(environments.ROAD);

    	$$self.$capture_state = () => ({
    		fly,
    		fade,
    		slide,
    		AppLayout,
    		PointerzButton,
    		OfflineRedirect,
    		BackButton,
    		Client: Client$1,
    		userModel,
    		onMount,
    		onDestroy,
    		environments,
    		isModifyingSpaceship,
    		selectNFT,
    		goToCircuitEditor,
    		goToCampaignMenu,
    		goToNextCircuitVote,
    		goToSpaceshipModification,
    		goBack,
    		setVisualiserEnvironment,
    		visualiserEnvironment,
    		groupedNFTs,
    		$userModel
    	});

    	$$self.$inject_state = $$props => {
    		if ('environments' in $$props) $$invalidate(3, environments = $$props.environments);
    		if ('isModifyingSpaceship' in $$props) $$invalidate(0, isModifyingSpaceship = $$props.isModifyingSpaceship);
    		if ('visualiserEnvironment' in $$props) $$invalidate(1, visualiserEnvironment = $$props.visualiserEnvironment);
    		if ('groupedNFTs' in $$props) $$invalidate(2, groupedNFTs = $$props.groupedNFTs);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$userModel*/ 2048) {
    			$$invalidate(2, groupedNFTs = (() => {
    				const groups = {};
    				const userNfts = $userModel?.nfts || [];

    				// Initialize all categories with defaults
    				Object.entries(Client$1.race.Constants.defaultNFTs).forEach(([category, defaultNft]) => {
    					groups[category] = [
    						{
    							...defaultNft,
    							nftSelected: !userNfts.some(nft => nft.nftCategory === category && nft.nftSelected)
    						}
    					];
    				});

    				// Add user NFTs
    				userNfts.forEach(nft => {
    					if (!groups[nft.nftCategory]) {
    						groups[nft.nftCategory] = [];
    					}

    					groups[nft.nftCategory].push(nft);
    				});

    				return groups;
    			})());
    		}
    	};

    	return [
    		isModifyingSpaceship,
    		visualiserEnvironment,
    		groupedNFTs,
    		environments,
    		selectNFT,
    		goToCircuitEditor,
    		goToCampaignMenu,
    		goToNextCircuitVote,
    		goToSpaceshipModification,
    		goBack,
    		setVisualiserEnvironment,
    		$userModel,
    		click_handler,
    		click_handler_1,
    		click_handler_2
    	];
    }

    class PrivateMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$u, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PrivateMenu",
    			options,
    			id: create_fragment$u.name
    		});
    	}
    }

    /* src\client\svelte\pages\PublicMenu.svelte generated by Svelte v3.50.1 */
    const file$s = "src\\client\\svelte\\pages\\PublicMenu.svelte";

    // (109:8) {#if currentSubpage == SUBPAGES.SIGN_IN}
    function create_if_block_4$3(ctx) {
    	let pointerzinput;
    	let updating_value;
    	let current;

    	function pointerzinput_value_binding_1(value) {
    		/*pointerzinput_value_binding_1*/ ctx[10](value);
    	}

    	let pointerzinput_props = { type: "mail", placeholder: "Email" };

    	if (/*$playerMail*/ ctx[2] !== void 0) {
    		pointerzinput_props.value = /*$playerMail*/ ctx[2];
    	}

    	pointerzinput = new PointerzInput({
    			props: pointerzinput_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(pointerzinput, 'value', pointerzinput_value_binding_1));

    	const block = {
    		c: function create() {
    			create_component(pointerzinput.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pointerzinput, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pointerzinput_changes = {};

    			if (!updating_value && dirty & /*$playerMail*/ 4) {
    				updating_value = true;
    				pointerzinput_changes.value = /*$playerMail*/ ctx[2];
    				add_flush_callback(() => updating_value = false);
    			}

    			pointerzinput.$set(pointerzinput_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerzinput.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerzinput.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pointerzinput, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$3.name,
    		type: "if",
    		source: "(109:8) {#if currentSubpage == SUBPAGES.SIGN_IN}",
    		ctx
    	});

    	return block;
    }

    // (115:8) {#if currentSubpage == SUBPAGES.SIGN_IN || currentSubpage == SUBPAGES.REGISTERED_LOG_IN}
    function create_if_block_3$3(ctx) {
    	let pointerzinput;
    	let updating_value;
    	let current;

    	function pointerzinput_value_binding_2(value) {
    		/*pointerzinput_value_binding_2*/ ctx[11](value);
    	}

    	let pointerzinput_props = {
    		type: "password",
    		placeholder: "Password"
    	};

    	if (/*$playerPassword*/ ctx[1] !== void 0) {
    		pointerzinput_props.value = /*$playerPassword*/ ctx[1];
    	}

    	pointerzinput = new PointerzInput({
    			props: pointerzinput_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(pointerzinput, 'value', pointerzinput_value_binding_2));

    	const block = {
    		c: function create() {
    			create_component(pointerzinput.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pointerzinput, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pointerzinput_changes = {};

    			if (!updating_value && dirty & /*$playerPassword*/ 2) {
    				updating_value = true;
    				pointerzinput_changes.value = /*$playerPassword*/ ctx[1];
    				add_flush_callback(() => updating_value = false);
    			}

    			pointerzinput.$set(pointerzinput_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerzinput.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerzinput.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pointerzinput, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(115:8) {#if currentSubpage == SUBPAGES.SIGN_IN || currentSubpage == SUBPAGES.REGISTERED_LOG_IN}",
    		ctx
    	});

    	return block;
    }

    // (129:53) 
    function create_if_block_2$5(ctx) {
    	let pointerzbutton;
    	let current;

    	pointerzbutton = new PointerzButton({
    			props: {
    				multicolor: true,
    				important: true,
    				$$slots: { default: [create_default_slot_9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pointerzbutton.$on("click", /*click_handler_2*/ ctx[14]);

    	const block = {
    		c: function create() {
    			create_component(pointerzbutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pointerzbutton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pointerzbutton_changes = {};

    			if (dirty & /*$$scope*/ 2097152) {
    				pointerzbutton_changes.$$scope = { dirty, ctx };
    			}

    			pointerzbutton.$set(pointerzbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerzbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerzbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pointerzbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(129:53) ",
    		ctx
    	});

    	return block;
    }

    // (125:63) 
    function create_if_block_1$8(ctx) {
    	let pointerzbutton;
    	let current;

    	pointerzbutton = new PointerzButton({
    			props: {
    				multicolor: true,
    				important: true,
    				$$slots: { default: [create_default_slot_8$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pointerzbutton.$on("click", /*click_handler_1*/ ctx[13]);

    	const block = {
    		c: function create() {
    			create_component(pointerzbutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pointerzbutton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pointerzbutton_changes = {};

    			if (dirty & /*$$scope*/ 2097152) {
    				pointerzbutton_changes.$$scope = { dirty, ctx };
    			}

    			pointerzbutton.$set(pointerzbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerzbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerzbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pointerzbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(125:63) ",
    		ctx
    	});

    	return block;
    }

    // (121:8) {#if currentSubpage == SUBPAGES.PLAY_AS_ANONYMOUS}
    function create_if_block$g(ctx) {
    	let pointerzbutton;
    	let current;

    	pointerzbutton = new PointerzButton({
    			props: {
    				multicolor: true,
    				important: true,
    				$$slots: { default: [create_default_slot_7$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pointerzbutton.$on("click", /*click_handler*/ ctx[12]);

    	const block = {
    		c: function create() {
    			create_component(pointerzbutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pointerzbutton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pointerzbutton_changes = {};

    			if (dirty & /*$$scope*/ 2097152) {
    				pointerzbutton_changes.$$scope = { dirty, ctx };
    			}

    			pointerzbutton.$set(pointerzbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerzbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerzbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pointerzbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(121:8) {#if currentSubpage == SUBPAGES.PLAY_AS_ANONYMOUS}",
    		ctx
    	});

    	return block;
    }

    // (130:10) <PointerzButton multicolor important on:click={() => signIn(false)}>
    function create_default_slot_9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Sign in");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9.name,
    		type: "slot",
    		source: "(130:10) <PointerzButton multicolor important on:click={() => signIn(false)}>",
    		ctx
    	});

    	return block;
    }

    // (126:10) <PointerzButton multicolor important on:click={() => logIn(false)}>
    function create_default_slot_8$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Log in");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$1.name,
    		type: "slot",
    		source: "(126:10) <PointerzButton multicolor important on:click={() => logIn(false)}>",
    		ctx
    	});

    	return block;
    }

    // (122:10) <PointerzButton multicolor important on:click={() => logIn(true)}>
    function create_default_slot_7$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Play");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$2.name,
    		type: "slot",
    		source: "(122:10) <PointerzButton multicolor important on:click={() => logIn(true)}>",
    		ctx
    	});

    	return block;
    }

    // (104:6) <Cell>
    function create_default_slot_6$3(ctx) {
    	let pointerzinput;
    	let updating_value;
    	let t0;
    	let t1;
    	let t2;
    	let current_block_type_index;
    	let if_block2;
    	let if_block2_anchor;
    	let current;

    	function pointerzinput_value_binding(value) {
    		/*pointerzinput_value_binding*/ ctx[9](value);
    	}

    	let pointerzinput_props = {
    		placeholder: "Nickname",
    		maxlength: playerNameMaxChar
    	};

    	if (/*$playerName*/ ctx[3] !== void 0) {
    		pointerzinput_props.value = /*$playerName*/ ctx[3];
    	}

    	pointerzinput = new PointerzInput({
    			props: pointerzinput_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(pointerzinput, 'value', pointerzinput_value_binding));
    	let if_block0 = /*currentSubpage*/ ctx[0] == /*SUBPAGES*/ ctx[4].SIGN_IN && create_if_block_4$3(ctx);
    	let if_block1 = (/*currentSubpage*/ ctx[0] == /*SUBPAGES*/ ctx[4].SIGN_IN || /*currentSubpage*/ ctx[0] == /*SUBPAGES*/ ctx[4].REGISTERED_LOG_IN) && create_if_block_3$3(ctx);
    	const if_block_creators = [create_if_block$g, create_if_block_1$8, create_if_block_2$5];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*currentSubpage*/ ctx[0] == /*SUBPAGES*/ ctx[4].PLAY_AS_ANONYMOUS) return 0;
    		if (/*currentSubpage*/ ctx[0] == /*SUBPAGES*/ ctx[4].REGISTERED_LOG_IN) return 1;
    		if (/*currentSubpage*/ ctx[0] == /*SUBPAGES*/ ctx[4].SIGN_IN) return 2;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			create_component(pointerzinput.$$.fragment);
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(pointerzinput, target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t2, anchor);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pointerzinput_changes = {};

    			if (!updating_value && dirty & /*$playerName*/ 8) {
    				updating_value = true;
    				pointerzinput_changes.value = /*$playerName*/ ctx[3];
    				add_flush_callback(() => updating_value = false);
    			}

    			pointerzinput.$set(pointerzinput_changes);

    			if (/*currentSubpage*/ ctx[0] == /*SUBPAGES*/ ctx[4].SIGN_IN) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*currentSubpage*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4$3(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*currentSubpage*/ ctx[0] == /*SUBPAGES*/ ctx[4].SIGN_IN || /*currentSubpage*/ ctx[0] == /*SUBPAGES*/ ctx[4].REGISTERED_LOG_IN) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*currentSubpage*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_3$3(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t2.parentNode, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block2) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block2 = if_blocks[current_block_type_index];

    					if (!if_block2) {
    						if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block2.c();
    					} else {
    						if_block2.p(ctx, dirty);
    					}

    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				} else {
    					if_block2 = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerzinput.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerzinput.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pointerzinput, detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t2);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$3.name,
    		type: "slot",
    		source: "(104:6) <Cell>",
    		ctx
    	});

    	return block;
    }

    // (137:10) <PointerzButton              imagePath="assets/images/menu/log.png"              buttonColor="grey"              on:click={showLoginForm}              elementsPerRow="2"              important              animating              futuristic>
    function create_default_slot_5$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Log in");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$3.name,
    		type: "slot",
    		source: "(137:10) <PointerzButton              imagePath=\\\"assets/images/menu/log.png\\\"              buttonColor=\\\"grey\\\"              on:click={showLoginForm}              elementsPerRow=\\\"2\\\"              important              animating              futuristic>",
    		ctx
    	});

    	return block;
    }

    // (147:10) <PointerzButton              imagePath="assets/images/menu/signup.png"              buttonColor="grey"              on:click={showSigninForm}              elementsPerRow="2"              lastElementOfRow              important              animating>
    function create_default_slot_4$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Sign up");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$3.name,
    		type: "slot",
    		source: "(147:10) <PointerzButton              imagePath=\\\"assets/images/menu/signup.png\\\"              buttonColor=\\\"grey\\\"              on:click={showSigninForm}              elementsPerRow=\\\"2\\\"              lastElementOfRow              important              animating>",
    		ctx
    	});

    	return block;
    }

    // (136:8) <FlexContainer>
    function create_default_slot_3$3(ctx) {
    	let pointerzbutton0;
    	let t;
    	let pointerzbutton1;
    	let current;

    	pointerzbutton0 = new PointerzButton({
    			props: {
    				imagePath: "assets/images/menu/log.png",
    				buttonColor: "grey",
    				elementsPerRow: "2",
    				important: true,
    				animating: true,
    				futuristic: true,
    				$$slots: { default: [create_default_slot_5$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pointerzbutton0.$on("click", /*showLoginForm*/ ctx[6]);

    	pointerzbutton1 = new PointerzButton({
    			props: {
    				imagePath: "assets/images/menu/signup.png",
    				buttonColor: "grey",
    				elementsPerRow: "2",
    				lastElementOfRow: true,
    				important: true,
    				animating: true,
    				$$slots: { default: [create_default_slot_4$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pointerzbutton1.$on("click", /*showSigninForm*/ ctx[5]);

    	const block = {
    		c: function create() {
    			create_component(pointerzbutton0.$$.fragment);
    			t = space();
    			create_component(pointerzbutton1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pointerzbutton0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(pointerzbutton1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pointerzbutton0_changes = {};

    			if (dirty & /*$$scope*/ 2097152) {
    				pointerzbutton0_changes.$$scope = { dirty, ctx };
    			}

    			pointerzbutton0.$set(pointerzbutton0_changes);
    			const pointerzbutton1_changes = {};

    			if (dirty & /*$$scope*/ 2097152) {
    				pointerzbutton1_changes.$$scope = { dirty, ctx };
    			}

    			pointerzbutton1.$set(pointerzbutton1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerzbutton0.$$.fragment, local);
    			transition_in(pointerzbutton1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerzbutton0.$$.fragment, local);
    			transition_out(pointerzbutton1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pointerzbutton0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(pointerzbutton1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$3.name,
    		type: "slot",
    		source: "(136:8) <FlexContainer>",
    		ctx
    	});

    	return block;
    }

    // (135:6) <Cell>
    function create_default_slot_2$3(ctx) {
    	let flexcontainer;
    	let current;

    	flexcontainer = new FlexContainer({
    			props: {
    				$$slots: { default: [create_default_slot_3$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(flexcontainer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(flexcontainer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const flexcontainer_changes = {};

    			if (dirty & /*$$scope*/ 2097152) {
    				flexcontainer_changes.$$scope = { dirty, ctx };
    			}

    			flexcontainer.$set(flexcontainer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(flexcontainer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(flexcontainer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(flexcontainer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$3.name,
    		type: "slot",
    		source: "(135:6) <Cell>",
    		ctx
    	});

    	return block;
    }

    // (97:4) <Cell        style="        min-width:{css.publicMenu.minWidth}px;        max-width:{css.publicMenu.maxWidth}px;        display: inline-block;      "        noMargin>
    function create_default_slot_1$4(ctx) {
    	let cell0;
    	let t;
    	let cell1;
    	let current;

    	cell0 = new Cell({
    			props: {
    				$$slots: { default: [create_default_slot_6$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	cell1 = new Cell({
    			props: {
    				$$slots: { default: [create_default_slot_2$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(cell0.$$.fragment);
    			t = space();
    			create_component(cell1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(cell0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(cell1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const cell0_changes = {};

    			if (dirty & /*$$scope, currentSubpage, $playerPassword, $playerMail, $playerName*/ 2097167) {
    				cell0_changes.$$scope = { dirty, ctx };
    			}

    			cell0.$set(cell0_changes);
    			const cell1_changes = {};

    			if (dirty & /*$$scope*/ 2097152) {
    				cell1_changes.$$scope = { dirty, ctx };
    			}

    			cell1.$set(cell1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cell0.$$.fragment, local);
    			transition_in(cell1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cell0.$$.fragment, local);
    			transition_out(cell1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cell0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(cell1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$4.name,
    		type: "slot",
    		source: "(97:4) <Cell        style=\\\"        min-width:{css.publicMenu.minWidth}px;        max-width:{css.publicMenu.maxWidth}px;        display: inline-block;      \\\"        noMargin>",
    		ctx
    	});

    	return block;
    }

    // (95:0) <AppLayout>
    function create_default_slot$8(ctx) {
    	let div;
    	let cell;
    	let div_intro;
    	let div_outro;
    	let current;

    	cell = new Cell({
    			props: {
    				style: "\r\n      min-width:" + css.publicMenu.minWidth + "px;\r\n      max-width:" + css.publicMenu.maxWidth + "px;\r\n      display: inline-block;\r\n    ",
    				noMargin: true,
    				$$slots: { default: [create_default_slot_1$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(cell.$$.fragment);
    			add_location(div, file$s, 95, 2, 2720);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(cell, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const cell_changes = {};

    			if (dirty & /*$$scope, currentSubpage, $playerPassword, $playerMail, $playerName*/ 2097167) {
    				cell_changes.$$scope = { dirty, ctx };
    			}

    			cell.$set(cell_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cell.$$.fragment, local);

    			add_render_callback(() => {
    				if (div_outro) div_outro.end(1);
    				div_intro = create_in_transition(div, fade, { delay: 400, duration: 400 });
    				div_intro.start();
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cell.$$.fragment, local);
    			if (div_intro) div_intro.invalidate();
    			div_outro = create_out_transition(div, fade, { duration: 400 });
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(cell);
    			if (detaching && div_outro) div_outro.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$8.name,
    		type: "slot",
    		source: "(95:0) <AppLayout>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let applayout;
    	let current;

    	applayout = new AppLayout({
    			props: {
    				$$slots: { default: [create_default_slot$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(applayout.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(applayout, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const applayout_changes = {};

    			if (dirty & /*$$scope, currentSubpage, $playerPassword, $playerMail, $playerName*/ 2097167) {
    				applayout_changes.$$scope = { dirty, ctx };
    			}

    			applayout.$set(applayout_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(applayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(applayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(applayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let $infoInfo;
    	let $infoError;
    	let $playerPassword;
    	let $playerMail;
    	let $playerName;
    	let $loggedIn;
    	let $passedData;
    	let $userModel;
    	validate_store(infoInfo, 'infoInfo');
    	component_subscribe($$self, infoInfo, $$value => $$invalidate(16, $infoInfo = $$value));
    	validate_store(infoError, 'infoError');
    	component_subscribe($$self, infoError, $$value => $$invalidate(17, $infoError = $$value));
    	validate_store(playerPassword, 'playerPassword');
    	component_subscribe($$self, playerPassword, $$value => $$invalidate(1, $playerPassword = $$value));
    	validate_store(playerMail, 'playerMail');
    	component_subscribe($$self, playerMail, $$value => $$invalidate(2, $playerMail = $$value));
    	validate_store(playerName, 'playerName');
    	component_subscribe($$self, playerName, $$value => $$invalidate(3, $playerName = $$value));
    	validate_store(loggedIn, 'loggedIn');
    	component_subscribe($$self, loggedIn, $$value => $$invalidate(18, $loggedIn = $$value));
    	validate_store(passedData, 'passedData');
    	component_subscribe($$self, passedData, $$value => $$invalidate(19, $passedData = $$value));
    	validate_store(userModel, 'userModel');
    	component_subscribe($$self, userModel, $$value => $$invalidate(20, $userModel = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PublicMenu', slots, []);

    	const SUBPAGES = {
    		PLAY_AS_ANONYMOUS: 1,
    		REGISTERED_LOG_IN: 2,
    		SIGN_IN: 3
    	};

    	let currentSubpage = SUBPAGES.PLAY_AS_ANONYMOUS;

    	function showSigninForm() {
    		set_store_value(playerPassword, $playerPassword = "", $playerPassword);
    		set_store_value(playerMail, $playerMail = "", $playerMail);
    		$$invalidate(0, currentSubpage = SUBPAGES.SIGN_IN);
    	}

    	function showLoginForm() {
    		$$invalidate(0, currentSubpage = SUBPAGES.REGISTERED_LOG_IN);
    	}

    	// The action of logging in => send the event
    	function logIn(anonymous) {
    		localStorage.setItem("pointerz_username", $playerName); // Update the stored name

    		set_store_value(
    			playerName,
    			$playerName = $playerName
    			? $playerName.substring(0, playerNameMaxChar)
    			: "Anonymous Spaceship",
    			$playerName
    		); // Format it

    		Client$1.socket.logIn($playerName, $playerPassword, anonymous);
    	}

    	// Indeed logged in, server sent back the circuits and the records
    	Client$1.svelte.loggedIn = function (
    		{ retError, retInfo, circuits, editorCircuits, voteCircuits, records, user, anonymous }
    	) {
    		set_store_value(infoError, $infoError = retError, $infoError);

    		if (!retError) {
    			set_store_value(loggedIn, $loggedIn = !anonymous, $loggedIn); // This is only a local variable as an indicator to know if the user is anonymous or not, the server handles the rest
    			set_store_value(userModel, $userModel = user, $userModel);

    			set_store_value(
    				passedData,
    				$passedData = {
    					circuits,
    					records,
    					editorCircuits,
    					voteCircuits
    				},
    				$passedData
    			);

    			$loggedIn
    			? Client$1.pushRoute("/privatemenu")
    			: Client$1.pushRoute("/campaignmenu");
    		}
    	};

    	// The action of signing in
    	function signIn() {
    		set_store_value(playerName, $playerName = $playerName.substring(0, playerNameMaxChar), $playerName);
    		Client$1.socket.signIn($playerName, $playerMail, $playerPassword);
    	}

    	// If signed in, show the info / error and go to log-in page with the user name pre-entered
    	Client$1.svelte.signedIn = function ({ retError, retInfo }) {
    		set_store_value(infoError, $infoError = retError, $infoError);
    		set_store_value(infoInfo, $infoInfo = retInfo, $infoInfo);

    		if (retInfo) {
    			$$invalidate(0, currentSubpage = SUBPAGES.REGISTERED_LOG_IN);
    		}
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PublicMenu> was created with unknown prop '${key}'`);
    	});

    	function pointerzinput_value_binding(value) {
    		$playerName = value;
    		playerName.set($playerName);
    	}

    	function pointerzinput_value_binding_1(value) {
    		$playerMail = value;
    		playerMail.set($playerMail);
    	}

    	function pointerzinput_value_binding_2(value) {
    		$playerPassword = value;
    		playerPassword.set($playerPassword);
    	}

    	const click_handler = () => logIn(true);
    	const click_handler_1 = () => logIn(false);
    	const click_handler_2 = () => signIn();

    	$$self.$capture_state = () => ({
    		infoError,
    		infoInfo,
    		Client: Client$1,
    		userModel,
    		loggedIn,
    		passedData,
    		playerName,
    		playerMail,
    		playerPassword,
    		playerNameMaxChar,
    		css,
    		fade,
    		AppLayout,
    		PointerzButton,
    		FlexContainer,
    		PointerzInput,
    		Cell,
    		SUBPAGES,
    		currentSubpage,
    		showSigninForm,
    		showLoginForm,
    		logIn,
    		signIn,
    		$infoInfo,
    		$infoError,
    		$playerPassword,
    		$playerMail,
    		$playerName,
    		$loggedIn,
    		$passedData,
    		$userModel
    	});

    	$$self.$inject_state = $$props => {
    		if ('currentSubpage' in $$props) $$invalidate(0, currentSubpage = $$props.currentSubpage);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		currentSubpage,
    		$playerPassword,
    		$playerMail,
    		$playerName,
    		SUBPAGES,
    		showSigninForm,
    		showLoginForm,
    		logIn,
    		signIn,
    		pointerzinput_value_binding,
    		pointerzinput_value_binding_1,
    		pointerzinput_value_binding_2,
    		click_handler,
    		click_handler_1,
    		click_handler_2
    	];
    }

    class PublicMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$t, create_fragment$t, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PublicMenu",
    			options,
    			id: create_fragment$t.name
    		});
    	}
    }

    /* node_modules\svelte-loading-spinners\dist\Shadow.svelte generated by Svelte v3.50.1 */

    const file$r = "node_modules\\svelte-loading-spinners\\dist\\Shadow.svelte";

    function create_fragment$s(ctx) {
    	let div1;
    	let div0;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "class", "shadow svelte-tycttu");
    			add_location(div0, file$r, 73, 2, 1978);
    			attr_dev(div1, "class", "wrapper svelte-tycttu");
    			set_style(div1, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
    			set_style(div1, "--color", /*color*/ ctx[0]);
    			set_style(div1, "--duration", /*duration*/ ctx[2]);
    			add_location(div1, file$r, 70, 0, 1875);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*size, unit*/ 10) {
    				set_style(div1, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
    			}

    			if (dirty & /*color*/ 1) {
    				set_style(div1, "--color", /*color*/ ctx[0]);
    			}

    			if (dirty & /*duration*/ 4) {
    				set_style(div1, "--duration", /*duration*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Shadow', slots, []);
    	let { color = "#FF3E00" } = $$props;
    	let { unit = "px" } = $$props;
    	let { duration = "1.7s" } = $$props;
    	let { size = "60" } = $$props;
    	const writable_props = ['color', 'unit', 'duration', 'size'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Shadow> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('color' in $$props) $$invalidate(0, color = $$props.color);
    		if ('unit' in $$props) $$invalidate(1, unit = $$props.unit);
    		if ('duration' in $$props) $$invalidate(2, duration = $$props.duration);
    		if ('size' in $$props) $$invalidate(3, size = $$props.size);
    	};

    	$$self.$capture_state = () => ({ color, unit, duration, size });

    	$$self.$inject_state = $$props => {
    		if ('color' in $$props) $$invalidate(0, color = $$props.color);
    		if ('unit' in $$props) $$invalidate(1, unit = $$props.unit);
    		if ('duration' in $$props) $$invalidate(2, duration = $$props.duration);
    		if ('size' in $$props) $$invalidate(3, size = $$props.size);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [color, unit, duration, size];
    }

    class Shadow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$s, safe_not_equal, { color: 0, unit: 1, duration: 2, size: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Shadow",
    			options,
    			id: create_fragment$s.name
    		});
    	}

    	get color() {
    		throw new Error("<Shadow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Shadow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get unit() {
    		throw new Error("<Shadow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set unit(value) {
    		throw new Error("<Shadow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get duration() {
    		throw new Error("<Shadow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set duration(value) {
    		throw new Error("<Shadow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Shadow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Shadow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\client\svelte\components\ui\RankingAndTime.svelte generated by Svelte v3.50.1 */
    const file$q = "src\\client\\svelte\\components\\ui\\RankingAndTime.svelte";

    // (42:4) {#if !noDifference}
    function create_if_block$f(ctx) {
    	let span;
    	let t;
    	let span_class_value;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*cpDiff*/ ctx[4]);

    			attr_dev(span, "class", span_class_value = "difference " + (/*checkpointDifference*/ ctx[0] > 0
    			? 'positiveDiff'
    			: /*checkpointDifference*/ ctx[0] < 0
    				? 'negativeDiff'
    				: 'zeroDiff') + " svelte-14x6ltj");

    			add_location(span, file$q, 42, 6, 1364);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*cpDiff*/ 16) set_data_dev(t, /*cpDiff*/ ctx[4]);

    			if (dirty & /*checkpointDifference*/ 1 && span_class_value !== (span_class_value = "difference " + (/*checkpointDifference*/ ctx[0] > 0
    			? 'positiveDiff'
    			: /*checkpointDifference*/ ctx[0] < 0
    				? 'negativeDiff'
    				: 'zeroDiff') + " svelte-14x6ltj")) {
    				attr_dev(span, "class", span_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(42:4) {#if !noDifference}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$r(ctx) {
    	let div2;
    	let div0;
    	let t0;
    	let sup;
    	let t1_value = Client$1.getSupFromNumber(/*checkpointPosition*/ ctx[1]) + "";
    	let t1;
    	let div0_style_value;
    	let t2;
    	let div1;
    	let span;
    	let t3;
    	let span_style_value;
    	let t4;
    	let div2_style_value;
    	let if_block = !/*noDifference*/ ctx[5] && create_if_block$f(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t0 = text(/*checkpointPosition*/ ctx[1]);
    			sup = element("sup");
    			t1 = text(t1_value);
    			t2 = space();
    			div1 = element("div");
    			span = element("span");
    			t3 = text(/*cpTime*/ ctx[3]);
    			t4 = space();
    			if (if_block) if_block.c();
    			attr_dev(sup, "class", "svelte-14x6ltj");
    			add_location(sup, file$q, 29, 24, 925);
    			attr_dev(div0, "class", "checkpointPosition svelte-14x6ltj");

    			attr_dev(div0, "style", div0_style_value = /*noPosition*/ ctx[6]
    			? "width: 0px;font-size: 0;padding:0;"
    			: "");

    			add_location(div0, file$q, 26, 2, 794);
    			attr_dev(span, "class", "checkpointTime svelte-14x6ltj");

    			attr_dev(span, "style", span_style_value = "" + ((/*noDifference*/ ctx[5]
    			? 'border-bottom-right-radius:8px;'
    			: '') + " " + (/*noPosition*/ ctx[6]
    			? 'border-top-left-radius:8px;'
    			: '') + " " + (/*noPosition*/ ctx[6] && /*noDifference*/ ctx[5]
    			? 'border-bottom-left-radius:8px'
    			: '')));

    			add_location(span, file$q, 32, 4, 1041);
    			attr_dev(div1, "class", "timeAndDifferenceContainer svelte-14x6ltj");
    			add_location(div1, file$q, 31, 2, 995);
    			attr_dev(div2, "class", "timeContainer " + /*fSizeClass*/ ctx[7] + " svelte-14x6ltj");

    			attr_dev(div2, "style", div2_style_value = "margin-bottom: " + css.default.margin + "px;" + (/*fullSize*/ ctx[2] && /*noDifference*/ ctx[5]
    			? "grid-template-rows: [l1] 36px [l2];"
    			: ""));

    			add_location(div2, file$q, 20, 0, 600);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, t0);
    			append_dev(div0, sup);
    			append_dev(sup, t1);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, span);
    			append_dev(span, t3);
    			append_dev(div1, t4);
    			if (if_block) if_block.m(div1, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*checkpointPosition*/ 2) set_data_dev(t0, /*checkpointPosition*/ ctx[1]);
    			if (dirty & /*checkpointPosition*/ 2 && t1_value !== (t1_value = Client$1.getSupFromNumber(/*checkpointPosition*/ ctx[1]) + "")) set_data_dev(t1, t1_value);

    			if (dirty & /*noPosition*/ 64 && div0_style_value !== (div0_style_value = /*noPosition*/ ctx[6]
    			? "width: 0px;font-size: 0;padding:0;"
    			: "")) {
    				attr_dev(div0, "style", div0_style_value);
    			}

    			if (dirty & /*cpTime*/ 8) set_data_dev(t3, /*cpTime*/ ctx[3]);

    			if (dirty & /*noDifference, noPosition*/ 96 && span_style_value !== (span_style_value = "" + ((/*noDifference*/ ctx[5]
    			? 'border-bottom-right-radius:8px;'
    			: '') + " " + (/*noPosition*/ ctx[6]
    			? 'border-top-left-radius:8px;'
    			: '') + " " + (/*noPosition*/ ctx[6] && /*noDifference*/ ctx[5]
    			? 'border-bottom-left-radius:8px'
    			: '')))) {
    				attr_dev(span, "style", span_style_value);
    			}

    			if (!/*noDifference*/ ctx[5]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$f(ctx);
    					if_block.c();
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*fullSize, noDifference*/ 36 && div2_style_value !== (div2_style_value = "margin-bottom: " + css.default.margin + "px;" + (/*fullSize*/ ctx[2] && /*noDifference*/ ctx[5]
    			? "grid-template-rows: [l1] 36px [l2];"
    			: ""))) {
    				attr_dev(div2, "style", div2_style_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let noPosition;
    	let noDifference;
    	let cpDiff;
    	let cpTime;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('RankingAndTime', slots, []);
    	let { checkpointDifference = undefined } = $$props;
    	let { checkpointPosition = undefined } = $$props;
    	let { checkpointTime = undefined } = $$props;
    	let { fullSize = false } = $$props;
    	let fSizeClass = fullSize ? "fullSize" : "";
    	const writable_props = ['checkpointDifference', 'checkpointPosition', 'checkpointTime', 'fullSize'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RankingAndTime> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('checkpointDifference' in $$props) $$invalidate(0, checkpointDifference = $$props.checkpointDifference);
    		if ('checkpointPosition' in $$props) $$invalidate(1, checkpointPosition = $$props.checkpointPosition);
    		if ('checkpointTime' in $$props) $$invalidate(8, checkpointTime = $$props.checkpointTime);
    		if ('fullSize' in $$props) $$invalidate(2, fullSize = $$props.fullSize);
    	};

    	$$self.$capture_state = () => ({
    		Client: Client$1,
    		css,
    		checkpointDifference,
    		checkpointPosition,
    		checkpointTime,
    		fullSize,
    		fSizeClass,
    		cpTime,
    		cpDiff,
    		noDifference,
    		noPosition
    	});

    	$$self.$inject_state = $$props => {
    		if ('checkpointDifference' in $$props) $$invalidate(0, checkpointDifference = $$props.checkpointDifference);
    		if ('checkpointPosition' in $$props) $$invalidate(1, checkpointPosition = $$props.checkpointPosition);
    		if ('checkpointTime' in $$props) $$invalidate(8, checkpointTime = $$props.checkpointTime);
    		if ('fullSize' in $$props) $$invalidate(2, fullSize = $$props.fullSize);
    		if ('fSizeClass' in $$props) $$invalidate(7, fSizeClass = $$props.fSizeClass);
    		if ('cpTime' in $$props) $$invalidate(3, cpTime = $$props.cpTime);
    		if ('cpDiff' in $$props) $$invalidate(4, cpDiff = $$props.cpDiff);
    		if ('noDifference' in $$props) $$invalidate(5, noDifference = $$props.noDifference);
    		if ('noPosition' in $$props) $$invalidate(6, noPosition = $$props.noPosition);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*checkpointPosition*/ 2) {
    			$$invalidate(6, noPosition = isNaN(checkpointPosition));
    		}

    		if ($$self.$$.dirty & /*checkpointDifference*/ 1) {
    			$$invalidate(5, noDifference = isNaN(checkpointDifference));
    		}

    		if ($$self.$$.dirty & /*checkpointDifference*/ 1) {
    			$$invalidate(4, cpDiff = Client$1.race.Functions.msToTime(checkpointDifference, 3, false, true));
    		}

    		if ($$self.$$.dirty & /*checkpointTime*/ 256) {
    			$$invalidate(3, cpTime = Client$1.race.Functions.msToTime(checkpointTime, 3));
    		}
    	};

    	return [
    		checkpointDifference,
    		checkpointPosition,
    		fullSize,
    		cpTime,
    		cpDiff,
    		noDifference,
    		noPosition,
    		fSizeClass,
    		checkpointTime
    	];
    }

    class RankingAndTime extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$r, create_fragment$r, safe_not_equal, {
    			checkpointDifference: 0,
    			checkpointPosition: 1,
    			checkpointTime: 8,
    			fullSize: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RankingAndTime",
    			options,
    			id: create_fragment$r.name
    		});
    	}

    	get checkpointDifference() {
    		throw new Error("<RankingAndTime>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set checkpointDifference(value) {
    		throw new Error("<RankingAndTime>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get checkpointPosition() {
    		throw new Error("<RankingAndTime>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set checkpointPosition(value) {
    		throw new Error("<RankingAndTime>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get checkpointTime() {
    		throw new Error("<RankingAndTime>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set checkpointTime(value) {
    		throw new Error("<RankingAndTime>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fullSize() {
    		throw new Error("<RankingAndTime>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fullSize(value) {
    		throw new Error("<RankingAndTime>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\client\svelte\components\race\CheckpointTime.svelte generated by Svelte v3.50.1 */
    const file$p = "src\\client\\svelte\\components\\race\\CheckpointTime.svelte";

    // (50:0) {#if showCheckpointTime}
    function create_if_block$e(ctx) {
    	let div1;
    	let div0;
    	let rankingandtime;
    	let updating_checkpointTime;
    	let updating_checkpointDifference;
    	let updating_checkpointPosition;
    	let div0_outro;
    	let div1_outro;
    	let current;

    	function rankingandtime_checkpointTime_binding(value) {
    		/*rankingandtime_checkpointTime_binding*/ ctx[4](value);
    	}

    	function rankingandtime_checkpointDifference_binding(value) {
    		/*rankingandtime_checkpointDifference_binding*/ ctx[5](value);
    	}

    	function rankingandtime_checkpointPosition_binding(value) {
    		/*rankingandtime_checkpointPosition_binding*/ ctx[6](value);
    	}

    	let rankingandtime_props = {};

    	if (/*checkpointTime*/ ctx[0] !== void 0) {
    		rankingandtime_props.checkpointTime = /*checkpointTime*/ ctx[0];
    	}

    	if (/*checkpointDifference*/ ctx[2] !== void 0) {
    		rankingandtime_props.checkpointDifference = /*checkpointDifference*/ ctx[2];
    	}

    	if (/*checkpointPosition*/ ctx[1] !== void 0) {
    		rankingandtime_props.checkpointPosition = /*checkpointPosition*/ ctx[1];
    	}

    	rankingandtime = new RankingAndTime({
    			props: rankingandtime_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(rankingandtime, 'checkpointTime', rankingandtime_checkpointTime_binding));
    	binding_callbacks.push(() => bind(rankingandtime, 'checkpointDifference', rankingandtime_checkpointDifference_binding));
    	binding_callbacks.push(() => bind(rankingandtime, 'checkpointPosition', rankingandtime_checkpointPosition_binding));

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			create_component(rankingandtime.$$.fragment);
    			add_location(div0, file$p, 51, 4, 1615);
    			attr_dev(div1, "class", "checkpointTimeContainer svelte-1vg2pj3");
    			add_location(div1, file$p, 50, 2, 1543);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(rankingandtime, div0, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const rankingandtime_changes = {};

    			if (!updating_checkpointTime && dirty & /*checkpointTime*/ 1) {
    				updating_checkpointTime = true;
    				rankingandtime_changes.checkpointTime = /*checkpointTime*/ ctx[0];
    				add_flush_callback(() => updating_checkpointTime = false);
    			}

    			if (!updating_checkpointDifference && dirty & /*checkpointDifference*/ 4) {
    				updating_checkpointDifference = true;
    				rankingandtime_changes.checkpointDifference = /*checkpointDifference*/ ctx[2];
    				add_flush_callback(() => updating_checkpointDifference = false);
    			}

    			if (!updating_checkpointPosition && dirty & /*checkpointPosition*/ 2) {
    				updating_checkpointPosition = true;
    				rankingandtime_changes.checkpointPosition = /*checkpointPosition*/ ctx[1];
    				add_flush_callback(() => updating_checkpointPosition = false);
    			}

    			rankingandtime.$set(rankingandtime_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rankingandtime.$$.fragment, local);
    			if (div0_outro) div0_outro.end(1);
    			if (div1_outro) div1_outro.end(1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rankingandtime.$$.fragment, local);
    			div0_outro = create_out_transition(div0, fade, { duration: 200 });
    			div1_outro = create_out_transition(div1, fade, { duration: 400 });
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(rankingandtime);
    			if (detaching && div0_outro) div0_outro.end();
    			if (detaching && div1_outro) div1_outro.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(50:0) {#if showCheckpointTime}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*showCheckpointTime*/ ctx[3] && create_if_block$e(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*showCheckpointTime*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*showCheckpointTime*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$e(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CheckpointTime', slots, []);
    	let checkpointTime, checkpointPosition, checkpointDifference; // The data displayed
    	let showCheckpointTime = false;
    	let timeoutSet = false; // The current timeout (if checkpoint is showed)

    	// This function is triggered each time tick
    	Client$1.svelte.updateCheckpointTime = function (newCheckpointTime, position, difference) {
    		if (checkpointTime != newCheckpointTime) {
    			// If that's a new checkpoint crossed
    			$$invalidate(0, checkpointTime = newCheckpointTime);

    			$$invalidate(1, checkpointPosition = position);
    			$$invalidate(2, checkpointDifference = difference);
    			$$invalidate(3, showCheckpointTime = true);
    			Client$1.phaser.playSound("checkpoint");

    			if (timeoutSet) {
    				// Reset the timeout if new checkpoint crossed
    				clearTimeout(timeoutSet);
    			}

    			timeoutSet = setTimeout(
    				() => {
    					timeoutSet = false;
    					$$invalidate(3, showCheckpointTime = false);
    				},
    				1500
    			);

    			// If that's the end
    			if (Client$1.race.user.ended) {
    				setTimeout(
    					() => {
    						// Show the end menu
    						Client$1.phaser.playSound("raceEnded");

    						Client$1.svelte.showEndraceMenu(true, checkpointPosition, checkpointTime, checkpointDifference);
    					},
    					500
    				);
    			}
    		}
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CheckpointTime> was created with unknown prop '${key}'`);
    	});

    	function rankingandtime_checkpointTime_binding(value) {
    		checkpointTime = value;
    		$$invalidate(0, checkpointTime);
    	}

    	function rankingandtime_checkpointDifference_binding(value) {
    		checkpointDifference = value;
    		$$invalidate(2, checkpointDifference);
    	}

    	function rankingandtime_checkpointPosition_binding(value) {
    		checkpointPosition = value;
    		$$invalidate(1, checkpointPosition);
    	}

    	$$self.$capture_state = () => ({
    		fade,
    		RankingAndTime,
    		Client: Client$1,
    		checkpointTime,
    		checkpointPosition,
    		checkpointDifference,
    		showCheckpointTime,
    		timeoutSet
    	});

    	$$self.$inject_state = $$props => {
    		if ('checkpointTime' in $$props) $$invalidate(0, checkpointTime = $$props.checkpointTime);
    		if ('checkpointPosition' in $$props) $$invalidate(1, checkpointPosition = $$props.checkpointPosition);
    		if ('checkpointDifference' in $$props) $$invalidate(2, checkpointDifference = $$props.checkpointDifference);
    		if ('showCheckpointTime' in $$props) $$invalidate(3, showCheckpointTime = $$props.showCheckpointTime);
    		if ('timeoutSet' in $$props) timeoutSet = $$props.timeoutSet;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		checkpointTime,
    		checkpointPosition,
    		checkpointDifference,
    		showCheckpointTime,
    		rankingandtime_checkpointTime_binding,
    		rankingandtime_checkpointDifference_binding,
    		rankingandtime_checkpointPosition_binding
    	];
    }

    class CheckpointTime extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CheckpointTime",
    			options,
    			id: create_fragment$q.name
    		});
    	}
    }

    /* src\client\svelte\components\race\LapCounter.svelte generated by Svelte v3.50.1 */
    const file$o = "src\\client\\svelte\\components\\race\\LapCounter.svelte";

    // (65:0) {#if lapsNumber > 1}
    function create_if_block$d(ctx) {
    	let div2;
    	let div1;
    	let t0;
    	let div0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let pointerztable;
    	let updating_values;
    	let div2_outro;
    	let current;

    	function pointerztable_values_binding(value) {
    		/*pointerztable_values_binding*/ ctx[4](value);
    	}

    	let pointerztable_props = {
    		columns: /*lapsColumns*/ ctx[3],
    		highlightedStyle: "background: rgba(100,100,100,0.5);color: white;"
    	};

    	if (/*lapsValues*/ ctx[2] !== void 0) {
    		pointerztable_props.values = /*lapsValues*/ ctx[2];
    	}

    	pointerztable = new PointerzTable({
    			props: pointerztable_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(pointerztable, 'values', pointerztable_values_binding));

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			t0 = text("Laps\r\n      ");
    			div0 = element("div");
    			t1 = text(/*currentLap*/ ctx[1]);
    			t2 = text(" / ");
    			t3 = text(/*lapsNumber*/ ctx[0]);
    			t4 = space();
    			create_component(pointerztable.$$.fragment);
    			attr_dev(div0, "class", "smallCounterContainer svelte-15sdj9f");
    			add_location(div0, file$o, 68, 6, 2257);
    			attr_dev(div1, "class", "lapCounterTitle svelte-15sdj9f");
    			add_location(div1, file$o, 66, 4, 2208);
    			attr_dev(div2, "class", "lapCounter svelte-15sdj9f");
    			add_location(div2, file$o, 65, 2, 2149);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, t1);
    			append_dev(div0, t2);
    			append_dev(div0, t3);
    			append_dev(div2, t4);
    			mount_component(pointerztable, div2, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*currentLap*/ 2) set_data_dev(t1, /*currentLap*/ ctx[1]);
    			if (!current || dirty & /*lapsNumber*/ 1) set_data_dev(t3, /*lapsNumber*/ ctx[0]);
    			const pointerztable_changes = {};

    			if (!updating_values && dirty & /*lapsValues*/ 4) {
    				updating_values = true;
    				pointerztable_changes.values = /*lapsValues*/ ctx[2];
    				add_flush_callback(() => updating_values = false);
    			}

    			pointerztable.$set(pointerztable_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerztable.$$.fragment, local);
    			if (div2_outro) div2_outro.end(1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerztable.$$.fragment, local);
    			div2_outro = create_out_transition(div2, fade, { duration: 400 });
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(pointerztable);
    			if (detaching && div2_outro) div2_outro.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(65:0) {#if lapsNumber > 1}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*lapsNumber*/ ctx[0] > 1 && create_if_block$d(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*lapsNumber*/ ctx[0] > 1) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*lapsNumber*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$d(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('LapCounter', slots, []);

    	let lapsColumns = [
    		{
    			name: "ranking",
    			style: "font-size: 20px;width: fit-content;font-family:virgo"
    		},
    		{
    			name: "lapTime",
    			style: "text-align: right;font-style: italic;font-size: 14px;width: 74px;vertical-align:middle;"
    		}
    	];

    	let lapsNumber, currentLap, lapsValues, totalTimePreviousLaps;

    	// Default values for the variables used in this component
    	Client$1.svelte.initLapsNumber = function (number) {
    		$$invalidate(2, lapsValues = []); // The times for the different laps
    		$$invalidate(0, lapsNumber = number); // The expected total number of laps at the end of the race
    		$$invalidate(1, currentLap = 0); // The current lap
    		totalTimePreviousLaps = 0; // The total time of all the previous laps (for computing the current lap time)
    		Client$1.svelte.addNewLap();
    	};

    	// Add a new lap to the race
    	Client$1.svelte.addNewLap = function (previousLapTime) {
    		if (lapsValues.length > 0) {
    			// New lap = changing the state of the previous lap (if it exists )
    			let lastLap = lapsValues[lapsValues.length - 1];

    			lastLap.highlighted = false; // not highlighting it
    			lastLap.lapTime = Client$1.race.Functions.msToTime(previousLapTime - totalTimePreviousLaps, 3); // Updating the lap time
    			totalTimePreviousLaps = previousLapTime; // Updating the total laps value
    		}

    		$$invalidate(1, currentLap++, currentLap);

    		$$invalidate(2, lapsValues = [
    			...lapsValues,
    			{
    				ranking: currentLap,
    				lapTime: Client$1.race.Functions.msToTime(0, 3),
    				highlighted: true
    			}
    		]); // Adding the current lap
    	};

    	// Update the lap timing
    	Client$1.svelte.updateLapTimes = function (currentTime) {
    		if (!lapsValues.length) {
    			return;
    		}

    		$$invalidate(2, lapsValues[lapsValues.length - 1].lapTime = Client$1.race.Functions.msToTime(currentTime - totalTimePreviousLaps, 3), lapsValues);
    		$$invalidate(2, lapsValues);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LapCounter> was created with unknown prop '${key}'`);
    	});

    	function pointerztable_values_binding(value) {
    		lapsValues = value;
    		$$invalidate(2, lapsValues);
    	}

    	$$self.$capture_state = () => ({
    		Client: Client$1,
    		fade,
    		PointerzTable,
    		lapsColumns,
    		lapsNumber,
    		currentLap,
    		lapsValues,
    		totalTimePreviousLaps
    	});

    	$$self.$inject_state = $$props => {
    		if ('lapsColumns' in $$props) $$invalidate(3, lapsColumns = $$props.lapsColumns);
    		if ('lapsNumber' in $$props) $$invalidate(0, lapsNumber = $$props.lapsNumber);
    		if ('currentLap' in $$props) $$invalidate(1, currentLap = $$props.currentLap);
    		if ('lapsValues' in $$props) $$invalidate(2, lapsValues = $$props.lapsValues);
    		if ('totalTimePreviousLaps' in $$props) totalTimePreviousLaps = $$props.totalTimePreviousLaps;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [lapsNumber, currentLap, lapsValues, lapsColumns, pointerztable_values_binding];
    }

    class LapCounter extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$p, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LapCounter",
    			options,
    			id: create_fragment$p.name
    		});
    	}
    }

    /* src\client\svelte\components\race\LiveRanking.svelte generated by Svelte v3.50.1 */
    const file$n = "src\\client\\svelte\\components\\race\\LiveRanking.svelte";

    function create_fragment$o(ctx) {
    	let div2;
    	let div0;
    	let t1;
    	let div1;
    	let pointerztable;
    	let updating_values;
    	let div2_outro;
    	let current;

    	function pointerztable_values_binding(value) {
    		/*pointerztable_values_binding*/ ctx[2](value);
    	}

    	let pointerztable_props = {
    		columns: /*liveRankingTableColumns*/ ctx[1],
    		highlightedStyle: "background: var(--dark-grey-color);color: var(--white-color);"
    	};

    	if (/*liveRankingValues*/ ctx[0] !== void 0) {
    		pointerztable_props.values = /*liveRankingValues*/ ctx[0];
    	}

    	pointerztable = new PointerzTable({
    			props: pointerztable_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(pointerztable, 'values', pointerztable_values_binding));

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			div0.textContent = "Live ranking";
    			t1 = space();
    			div1 = element("div");
    			create_component(pointerztable.$$.fragment);
    			attr_dev(div0, "class", "raceRankingTitle svelte-1yhu02o");
    			add_location(div0, file$n, 105, 2, 4183);
    			set_style(div1, "margin-top", "33px");
    			add_location(div1, file$n, 106, 2, 4235);
    			attr_dev(div2, "class", "raceRanking svelte-1yhu02o");
    			add_location(div2, file$n, 104, 0, 4125);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			mount_component(pointerztable, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const pointerztable_changes = {};

    			if (!updating_values && dirty & /*liveRankingValues*/ 1) {
    				updating_values = true;
    				pointerztable_changes.values = /*liveRankingValues*/ ctx[0];
    				add_flush_callback(() => updating_values = false);
    			}

    			pointerztable.$set(pointerztable_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerztable.$$.fragment, local);
    			if (div2_outro) div2_outro.end(1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerztable.$$.fragment, local);
    			div2_outro = create_out_transition(div2, fade, { duration: 400 });
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(pointerztable);
    			if (detaching && div2_outro) div2_outro.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('LiveRanking', slots, []);
    	let liveRankingValues = [];

    	let liveRankingTableColumns = [
    		{
    			name: "ranking",
    			style: "font-size: 20px;width: 24px;font-family:virgo"
    		},
    		{
    			name: "nickname",
    			style: "font-size: 14px;font-family: 'Nunito Bold';"
    		},
    		{
    			name: "formattedRunTime",
    			style: "text-align: right;font-style: italic;font-size: 14px;width: 74px;vertical-align:middle;"
    		}
    	];

    	// Updating the live ranking with the data for the players in competition, ranked by time
    	Client$1.svelte.updateLiveRanking = function (competitors) {
    		let firstPlayer = competitors[0];
    		let temp = [];

    		for (var i = 0; i < competitors.length; i++) {
    			let c = competitors[i];
    			let timeDiff;

    			if (c == firstPlayer) {
    				// If it's the number one, then just display its last know time at the last cp crossed
    				timeDiff = Client$1.race.Functions.msToTime(
    					c.liveCheckpointsCrossed.length
    					? c.liveCheckpointsCrossed[c.liveCheckpointsCrossed.length - 1].instant
    					: 0,
    					3
    				);
    			} else {
    				if (!c.liveCheckpointsCrossed.length) {
    					// If this player didn't cross any cp, then display the difference with the first cp of the first player
    					timeDiff = Client$1.race.user.currentInstant - (firstPlayer.liveCheckpointsCrossed.length
    					? firstPlayer.liveCheckpointsCrossed[0].instant
    					: Client$1.race.user.currentInstant);
    				} else {
    					// If there is at least one cp crossed (then the first player also crossed at least one)
    					// The difference with the first according at the last cp crossed by this player
    					let lastCpTimeDiff = c.liveCheckpointsCrossed[c.liveCheckpointsCrossed.length - 1].instant - firstPlayer.liveCheckpointsCrossed[c.liveCheckpointsCrossed.length - 1].instant;

    					let nextCpTimeDiff = 0;

    					if (c.liveCheckpointsCrossed.length < firstPlayer.liveCheckpointsCrossed.length) {
    						// If the first player crossed at least one cp more than this player
    						nextCpTimeDiff = Client$1.race.user.currentInstant - firstPlayer.liveCheckpointsCrossed[c.liveCheckpointsCrossed.length].instant; // Then this player is at least late of the time difference between the current time and the time at which this first player crossed this cp
    					}

    					timeDiff = Math.max(lastCpTimeDiff, nextCpTimeDiff); // Take the time diff which is higher to display it
    				}

    				timeDiff = "+" + Client$1.race.Functions.msToTime(timeDiff, 3, true); // Add a + for display purpose
    			}

    			// Add the data to the display table
    			temp.push({
    				ranking: i + 1,
    				nickname: c.nickname,
    				formattedRunTime: timeDiff,
    				highlighted: c.isCurrentPlayer
    			});

    			// Update the crossed checkpoints display
    			if (c.isCurrentPlayer && c.liveCheckpointsCrossed.length > 0) {
    				let checkpointIndice = c.liveCheckpointsCrossed.length - 1;
    				let lastCp = c.liveCheckpointsCrossed[checkpointIndice];

    				// This functions is called each time and the checkpoint time is only displayed if that's a new time
    				Client$1.svelte.updateCheckpointTime(lastCp.instant, i + 1, Client$1.race.user.replay && Client$1.race.user.replay.checkpointsCrossed.length >= c.liveCheckpointsCrossed.length
    				? lastCp.instant - Client$1.race.user.replay.checkpointsCrossed[checkpointIndice].instant
    				: undefined);
    			}
    		}

    		$$invalidate(0, liveRankingValues = temp);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LiveRanking> was created with unknown prop '${key}'`);
    	});

    	function pointerztable_values_binding(value) {
    		liveRankingValues = value;
    		$$invalidate(0, liveRankingValues);
    	}

    	$$self.$capture_state = () => ({
    		Client: Client$1,
    		fade,
    		PointerzTable,
    		liveRankingValues,
    		liveRankingTableColumns
    	});

    	$$self.$inject_state = $$props => {
    		if ('liveRankingValues' in $$props) $$invalidate(0, liveRankingValues = $$props.liveRankingValues);
    		if ('liveRankingTableColumns' in $$props) $$invalidate(1, liveRankingTableColumns = $$props.liveRankingTableColumns);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [liveRankingValues, liveRankingTableColumns, pointerztable_values_binding];
    }

    class LiveRanking extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$o, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LiveRanking",
    			options,
    			id: create_fragment$o.name
    		});
    	}
    }

    /* src\client\svelte\components\race\RaceCounter.svelte generated by Svelte v3.50.1 */
    const file$m = "src\\client\\svelte\\components\\race\\RaceCounter.svelte";

    // (41:0) {#if showCounter}
    function create_if_block$c(ctx) {
    	let div;
    	let t_value = (/*raceCounter*/ ctx[0] ? /*raceCounter*/ ctx[0] : "GO !") + "";
    	let t;
    	let div_intro;
    	let div_outro;
    	let current;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "raceCounter svelte-v3fhar");
    			add_location(div, file$m, 41, 2, 1200);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*raceCounter*/ 1) && t_value !== (t_value = (/*raceCounter*/ ctx[0] ? /*raceCounter*/ ctx[0] : "GO !") + "")) set_data_dev(t, t_value);
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (div_outro) div_outro.end(1);
    				div_intro = create_in_transition(div, scale, { duration: 500 });
    				div_intro.start();
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (div_intro) div_intro.invalidate();
    			div_outro = create_out_transition(div, fade, { duration: 400 });
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching && div_outro) div_outro.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(41:0) {#if showCounter}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*showCounter*/ ctx[1] && create_if_block$c(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*showCounter*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*showCounter*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$c(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('RaceCounter', slots, []);
    	let raceCounter; // The number to be displayed
    	let showCounter = false;

    	Client$1.svelte.startRaceCounter = function () {
    		$$invalidate(0, raceCounter = 4);
    		$$invalidate(1, showCounter = false);

    		setTimeout(
    			() => {
    				let updateInterval = setInterval(
    					() => {
    						// -1 each second and making the new one appear and then disappear
    						if (!Client$1.race.game) {
    							clearInterval(updateInterval);
    							return;
    						}

    						if (Client$1.race.game.racePaused) {
    							return;
    						}

    						if (!showCounter) {
    							$$invalidate(0, raceCounter--, raceCounter);

    							if (raceCounter == 0) {
    								Client$1.phaser.playSound("raceStart");
    							} else if (raceCounter > 0) {
    								Client$1.phaser.playSound("raceCountdown");
    							}
    						}

    						$$invalidate(1, showCounter = !showCounter);

    						if (raceCounter == 0) {
    							Client$1.race.user.startRace();
    						} else if (raceCounter < 0) {
    							$$invalidate(1, showCounter = false);
    							clearInterval(updateInterval);
    						}
    					},
    					500
    				);
    			},
    			500
    		);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RaceCounter> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		scale,
    		fade,
    		Client: Client$1,
    		raceCounter,
    		showCounter
    	});

    	$$self.$inject_state = $$props => {
    		if ('raceCounter' in $$props) $$invalidate(0, raceCounter = $$props.raceCounter);
    		if ('showCounter' in $$props) $$invalidate(1, showCounter = $$props.showCounter);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [raceCounter, showCounter];
    }

    class RaceCounter extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$n, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RaceCounter",
    			options,
    			id: create_fragment$n.name
    		});
    	}
    }

    /* src\client\svelte\components\race\RaceTime.svelte generated by Svelte v3.50.1 */
    const file$l = "src\\client\\svelte\\components\\race\\RaceTime.svelte";

    function create_fragment$m(ctx) {
    	let div;
    	let t;
    	let div_outro;
    	let current;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*currentInstant*/ ctx[0]);
    			attr_dev(div, "class", "currentInstant svelte-ztvxnz");
    			add_location(div, file$l, 17, 0, 536);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*currentInstant*/ 1) set_data_dev(t, /*currentInstant*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (div_outro) div_outro.end(1);
    			current = true;
    		},
    		o: function outro(local) {
    			div_outro = create_out_transition(div, fade, { duration: 400 });
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching && div_outro) div_outro.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('RaceTime', slots, []);
    	let currentInstant; // The time to be displayed

    	Client$1.svelte.updateRaceTime = function () {
    		$$invalidate(0, currentInstant = Client$1.race.Functions.msToTime(Client$1.race.user.ended
    		? Client$1.race.user.checkpointsCrossed[Client$1.race.user.checkpointsCrossed.length - 1].instant
    		: Client$1.race.user.currentInstant));
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RaceTime> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Client: Client$1, fade, currentInstant });

    	$$self.$inject_state = $$props => {
    		if ('currentInstant' in $$props) $$invalidate(0, currentInstant = $$props.currentInstant);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [currentInstant];
    }

    class RaceTime extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$m, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RaceTime",
    			options,
    			id: create_fragment$m.name
    		});
    	}
    }

    /* src\client\svelte\components\race\EndraceMenu.svelte generated by Svelte v3.50.1 */
    const file$k = "src\\client\\svelte\\components\\race\\EndraceMenu.svelte";

    // (91:0) {#if showMenu}
    function create_if_block$b(ctx) {
    	let div;
    	let cell;
    	let div_intro;
    	let div_outro;
    	let current;

    	cell = new Cell({
    			props: {
    				color: "orange",
    				style: "\r\n            width:" + (css.endRace.blockWidth + 2 * css.default.margin) + "px;\r\n            position:absolute;\r\n            top: calc(50% - 200px);\r\n            margin-left: auto;\r\n            margin-right: auto;\r\n            left: 0;\r\n            right: 0;\r\n            text-align: center;",
    				title: /*circuitName*/ ctx[7],
    				titleImagePath: "assets/images/menu/circuit.png",
    				$$slots: { default: [create_default_slot$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(cell.$$.fragment);
    			attr_dev(div, "class", "overlay svelte-1rqmtti");
    			add_location(div, file$k, 91, 2, 3116);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(cell, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const cell_changes = {};
    			if (dirty & /*circuitName*/ 128) cell_changes.title = /*circuitName*/ ctx[7];

    			if (dirty & /*$$scope, isEditedCircuit, isResume, globalRecordLoading, timeDiffWithGlobal, globalRanking, globalTime, $loggedIn, isVoteCircuit, raceRanking, raceTime*/ 8392574) {
    				cell_changes.$$scope = { dirty, ctx };
    			}

    			cell.$set(cell_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cell.$$.fragment, local);

    			add_render_callback(() => {
    				if (div_outro) div_outro.end(1);
    				div_intro = create_in_transition(div, fade, { duration: 800 });
    				div_intro.start();
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cell.$$.fragment, local);
    			if (div_intro) div_intro.invalidate();
    			div_outro = create_out_transition(div, fade, { duration: 400 });
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(cell);
    			if (detaching && div_outro) div_outro.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(91:0) {#if showMenu}",
    		ctx
    	});

    	return block;
    }

    // (106:6) {#if raceTime}
    function create_if_block_6$1(ctx) {
    	let celltitle;
    	let t;
    	let rankingandtime;
    	let updating_checkpointPosition;
    	let updating_checkpointTime;
    	let current;

    	celltitle = new CellTitle({
    			props: {
    				small: true,
    				noMargins: true,
    				color: "darkOrange",
    				imagePath: "assets/images/menu/trophy.png",
    				$$slots: { default: [create_default_slot_8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function rankingandtime_checkpointPosition_binding(value) {
    		/*rankingandtime_checkpointPosition_binding*/ ctx[16](value);
    	}

    	function rankingandtime_checkpointTime_binding(value) {
    		/*rankingandtime_checkpointTime_binding*/ ctx[17](value);
    	}

    	let rankingandtime_props = { fullSize: true };

    	if (/*raceRanking*/ ctx[1] !== void 0) {
    		rankingandtime_props.checkpointPosition = /*raceRanking*/ ctx[1];
    	}

    	if (/*raceTime*/ ctx[2] !== void 0) {
    		rankingandtime_props.checkpointTime = /*raceTime*/ ctx[2];
    	}

    	rankingandtime = new RankingAndTime({
    			props: rankingandtime_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(rankingandtime, 'checkpointPosition', rankingandtime_checkpointPosition_binding));
    	binding_callbacks.push(() => bind(rankingandtime, 'checkpointTime', rankingandtime_checkpointTime_binding));

    	const block = {
    		c: function create() {
    			create_component(celltitle.$$.fragment);
    			t = space();
    			create_component(rankingandtime.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(celltitle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(rankingandtime, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const celltitle_changes = {};

    			if (dirty & /*$$scope*/ 8388608) {
    				celltitle_changes.$$scope = { dirty, ctx };
    			}

    			celltitle.$set(celltitle_changes);
    			const rankingandtime_changes = {};

    			if (!updating_checkpointPosition && dirty & /*raceRanking*/ 2) {
    				updating_checkpointPosition = true;
    				rankingandtime_changes.checkpointPosition = /*raceRanking*/ ctx[1];
    				add_flush_callback(() => updating_checkpointPosition = false);
    			}

    			if (!updating_checkpointTime && dirty & /*raceTime*/ 4) {
    				updating_checkpointTime = true;
    				rankingandtime_changes.checkpointTime = /*raceTime*/ ctx[2];
    				add_flush_callback(() => updating_checkpointTime = false);
    			}

    			rankingandtime.$set(rankingandtime_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(celltitle.$$.fragment, local);
    			transition_in(rankingandtime.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(celltitle.$$.fragment, local);
    			transition_out(rankingandtime.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(celltitle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(rankingandtime, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(106:6) {#if raceTime}",
    		ctx
    	});

    	return block;
    }

    // (107:8) <CellTitle            small            noMargins            color="darkOrange"            imagePath="assets/images/menu/trophy.png">
    function create_default_slot_8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Race");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8.name,
    		type: "slot",
    		source: "(107:8) <CellTitle            small            noMargins            color=\\\"darkOrange\\\"            imagePath=\\\"assets/images/menu/trophy.png\\\">",
    		ctx
    	});

    	return block;
    }

    // (119:6) {#if !isVoteCircuit}
    function create_if_block_3$2(ctx) {
    	let celltitle;
    	let t;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;

    	celltitle = new CellTitle({
    			props: {
    				small: true,
    				noMargins: true,
    				color: "darkOrange",
    				imagePath: "assets/images/menu/" + (/*$loggedIn*/ ctx[11] ? 'globe' : 'user') + ".png",
    				$$slots: { default: [create_default_slot_7$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block_4$2, create_if_block_5$2, create_else_block_1$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*globalRecordLoading*/ ctx[6]) return 0;
    		if (/*globalTime*/ ctx[5]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			create_component(celltitle.$$.fragment);
    			t = space();
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(celltitle, target, anchor);
    			insert_dev(target, t, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const celltitle_changes = {};
    			if (dirty & /*$loggedIn*/ 2048) celltitle_changes.imagePath = "assets/images/menu/" + (/*$loggedIn*/ ctx[11] ? 'globe' : 'user') + ".png";

    			if (dirty & /*$$scope, $loggedIn*/ 8390656) {
    				celltitle_changes.$$scope = { dirty, ctx };
    			}

    			celltitle.$set(celltitle_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(celltitle.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(celltitle.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(celltitle, detaching);
    			if (detaching) detach_dev(t);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(119:6) {#if !isVoteCircuit}",
    		ctx
    	});

    	return block;
    }

    // (120:8) <CellTitle            small            noMargins            color="darkOrange"            imagePath="assets/images/menu/{$loggedIn ? 'globe' : 'user'}.png">
    function create_default_slot_7$1(ctx) {
    	let t_value = (/*$loggedIn*/ ctx[11] ? "World ranking" : "Best time") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$loggedIn*/ 2048 && t_value !== (t_value = (/*$loggedIn*/ ctx[11] ? "World ranking" : "Best time") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$1.name,
    		type: "slot",
    		source: "(120:8) <CellTitle            small            noMargins            color=\\\"darkOrange\\\"            imagePath=\\\"assets/images/menu/{$loggedIn ? 'globe' : 'user'}.png\\\">",
    		ctx
    	});

    	return block;
    }

    // (137:8) {:else}
    function create_else_block_1$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "No record on this circuit";
    			attr_dev(div, "class", "noRecord svelte-1rqmtti");
    			set_style(div, "margin-bottom", "8px");
    			add_location(div, file$k, 137, 10, 4671);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(137:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (131:29) 
    function create_if_block_5$2(ctx) {
    	let rankingandtime;
    	let updating_checkpointDifference;
    	let updating_checkpointPosition;
    	let updating_checkpointTime;
    	let current;

    	function rankingandtime_checkpointDifference_binding(value) {
    		/*rankingandtime_checkpointDifference_binding*/ ctx[18](value);
    	}

    	function rankingandtime_checkpointPosition_binding_1(value) {
    		/*rankingandtime_checkpointPosition_binding_1*/ ctx[19](value);
    	}

    	function rankingandtime_checkpointTime_binding_1(value) {
    		/*rankingandtime_checkpointTime_binding_1*/ ctx[20](value);
    	}

    	let rankingandtime_props = { fullSize: true };

    	if (/*timeDiffWithGlobal*/ ctx[3] !== void 0) {
    		rankingandtime_props.checkpointDifference = /*timeDiffWithGlobal*/ ctx[3];
    	}

    	if (/*globalRanking*/ ctx[4] !== void 0) {
    		rankingandtime_props.checkpointPosition = /*globalRanking*/ ctx[4];
    	}

    	if (/*globalTime*/ ctx[5] !== void 0) {
    		rankingandtime_props.checkpointTime = /*globalTime*/ ctx[5];
    	}

    	rankingandtime = new RankingAndTime({
    			props: rankingandtime_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(rankingandtime, 'checkpointDifference', rankingandtime_checkpointDifference_binding));
    	binding_callbacks.push(() => bind(rankingandtime, 'checkpointPosition', rankingandtime_checkpointPosition_binding_1));
    	binding_callbacks.push(() => bind(rankingandtime, 'checkpointTime', rankingandtime_checkpointTime_binding_1));

    	const block = {
    		c: function create() {
    			create_component(rankingandtime.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(rankingandtime, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const rankingandtime_changes = {};

    			if (!updating_checkpointDifference && dirty & /*timeDiffWithGlobal*/ 8) {
    				updating_checkpointDifference = true;
    				rankingandtime_changes.checkpointDifference = /*timeDiffWithGlobal*/ ctx[3];
    				add_flush_callback(() => updating_checkpointDifference = false);
    			}

    			if (!updating_checkpointPosition && dirty & /*globalRanking*/ 16) {
    				updating_checkpointPosition = true;
    				rankingandtime_changes.checkpointPosition = /*globalRanking*/ ctx[4];
    				add_flush_callback(() => updating_checkpointPosition = false);
    			}

    			if (!updating_checkpointTime && dirty & /*globalTime*/ 32) {
    				updating_checkpointTime = true;
    				rankingandtime_changes.checkpointTime = /*globalTime*/ ctx[5];
    				add_flush_callback(() => updating_checkpointTime = false);
    			}

    			rankingandtime.$set(rankingandtime_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rankingandtime.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rankingandtime.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(rankingandtime, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$2.name,
    		type: "if",
    		source: "(131:29) ",
    		ctx
    	});

    	return block;
    }

    // (127:8) {#if globalRecordLoading}
    function create_if_block_4$2(ctx) {
    	let div;
    	let shadow;
    	let current;

    	shadow = new Shadow({
    			props: {
    				size: "16",
    				color: "var(--almost-white-color)",
    				unit: "px"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(shadow.$$.fragment);
    			attr_dev(div, "class", "centerer svelte-1rqmtti");
    			add_location(div, file$k, 127, 10, 4282);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(shadow, div, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(shadow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(shadow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(shadow);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(127:8) {#if globalRecordLoading}",
    		ctx
    	});

    	return block;
    }

    // (144:8) {#if isResume}
    function create_if_block_2$4(ctx) {
    	let pointerzbutton;
    	let current;

    	pointerzbutton = new PointerzButton({
    			props: {
    				buttonColor: "green",
    				important: true,
    				elementsPerRow: "2",
    				$$slots: { default: [create_default_slot_6$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pointerzbutton.$on("click", /*resume*/ ctx[15]);

    	const block = {
    		c: function create() {
    			create_component(pointerzbutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pointerzbutton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pointerzbutton_changes = {};

    			if (dirty & /*$$scope*/ 8388608) {
    				pointerzbutton_changes.$$scope = { dirty, ctx };
    			}

    			pointerzbutton.$set(pointerzbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerzbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerzbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pointerzbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(144:8) {#if isResume}",
    		ctx
    	});

    	return block;
    }

    // (145:10) <PointerzButton              buttonColor="green"              on:click={resume}              important              elementsPerRow="2">
    function create_default_slot_6$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Resume");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$2.name,
    		type: "slot",
    		source: "(145:10) <PointerzButton              buttonColor=\\\"green\\\"              on:click={resume}              important              elementsPerRow=\\\"2\\\">",
    		ctx
    	});

    	return block;
    }

    // (153:8) <PointerzButton            buttonColor="red"            on:click={restart}            important            elementsPerRow={isResume ? 2 : 1}            lastElementOfRow="true">
    function create_default_slot_5$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Restart");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$2.name,
    		type: "slot",
    		source: "(153:8) <PointerzButton            buttonColor=\\\"red\\\"            on:click={restart}            important            elementsPerRow={isResume ? 2 : 1}            lastElementOfRow=\\\"true\\\">",
    		ctx
    	});

    	return block;
    }

    // (143:6) <FlexContainer flexWrap="wrap" justifyContent="center">
    function create_default_slot_4$2(ctx) {
    	let t;
    	let pointerzbutton;
    	let current;
    	let if_block = /*isResume*/ ctx[8] && create_if_block_2$4(ctx);

    	pointerzbutton = new PointerzButton({
    			props: {
    				buttonColor: "red",
    				important: true,
    				elementsPerRow: /*isResume*/ ctx[8] ? 2 : 1,
    				lastElementOfRow: "true",
    				$$slots: { default: [create_default_slot_5$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pointerzbutton.$on("click", /*restart*/ ctx[14]);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			create_component(pointerzbutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(pointerzbutton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*isResume*/ ctx[8]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*isResume*/ 256) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$4(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const pointerzbutton_changes = {};
    			if (dirty & /*isResume*/ 256) pointerzbutton_changes.elementsPerRow = /*isResume*/ ctx[8] ? 2 : 1;

    			if (dirty & /*$$scope*/ 8388608) {
    				pointerzbutton_changes.$$scope = { dirty, ctx };
    			}

    			pointerzbutton.$set(pointerzbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(pointerzbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(pointerzbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(pointerzbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$2.name,
    		type: "slot",
    		source: "(143:6) <FlexContainer flexWrap=\\\"wrap\\\" justifyContent=\\\"center\\\">",
    		ctx
    	});

    	return block;
    }

    // (167:8) {:else}
    function create_else_block$5(ctx) {
    	let pointerzbutton;
    	let current;

    	pointerzbutton = new PointerzButton({
    			props: {
    				buttonColor: "blue",
    				important: true,
    				$$slots: { default: [create_default_slot_3$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pointerzbutton.$on("click", /*goToMenu*/ ctx[12]);

    	const block = {
    		c: function create() {
    			create_component(pointerzbutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pointerzbutton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pointerzbutton_changes = {};

    			if (dirty & /*$$scope*/ 8388608) {
    				pointerzbutton_changes.$$scope = { dirty, ctx };
    			}

    			pointerzbutton.$set(pointerzbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerzbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerzbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pointerzbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(167:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (163:8) {#if isEditedCircuit}
    function create_if_block_1$7(ctx) {
    	let pointerzbutton;
    	let current;

    	pointerzbutton = new PointerzButton({
    			props: {
    				buttonColor: "blue",
    				important: true,
    				$$slots: { default: [create_default_slot_2$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pointerzbutton.$on("click", /*goToEditor*/ ctx[13]);

    	const block = {
    		c: function create() {
    			create_component(pointerzbutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pointerzbutton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pointerzbutton_changes = {};

    			if (dirty & /*$$scope*/ 8388608) {
    				pointerzbutton_changes.$$scope = { dirty, ctx };
    			}

    			pointerzbutton.$set(pointerzbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerzbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerzbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pointerzbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(163:8) {#if isEditedCircuit}",
    		ctx
    	});

    	return block;
    }

    // (168:10) <PointerzButton buttonColor="blue" on:click={goToMenu} important>
    function create_default_slot_3$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Change circuit");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$2.name,
    		type: "slot",
    		source: "(168:10) <PointerzButton buttonColor=\\\"blue\\\" on:click={goToMenu} important>",
    		ctx
    	});

    	return block;
    }

    // (164:10) <PointerzButton buttonColor="blue" on:click={goToEditor} important>
    function create_default_slot_2$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Go to editor");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$2.name,
    		type: "slot",
    		source: "(164:10) <PointerzButton buttonColor=\\\"blue\\\" on:click={goToEditor} important>",
    		ctx
    	});

    	return block;
    }

    // (162:6) <FlexContainer flexWrap="wrap" justifyContent="center">
    function create_default_slot_1$3(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$7, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*isEditedCircuit*/ ctx[9]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$3.name,
    		type: "slot",
    		source: "(162:6) <FlexContainer flexWrap=\\\"wrap\\\" justifyContent=\\\"center\\\">",
    		ctx
    	});

    	return block;
    }

    // (93:4) <Cell        color="orange"        style="              width:{css.endRace.blockWidth + 2 * css.default.margin}px;              position:absolute;              top: calc(50% - 200px);              margin-left: auto;              margin-right: auto;              left: 0;              right: 0;              text-align: center;"        title={circuitName}        titleImagePath="assets/images/menu/circuit.png">
    function create_default_slot$7(ctx) {
    	let t0;
    	let t1;
    	let flexcontainer0;
    	let t2;
    	let flexcontainer1;
    	let current;
    	let if_block0 = /*raceTime*/ ctx[2] && create_if_block_6$1(ctx);
    	let if_block1 = !/*isVoteCircuit*/ ctx[10] && create_if_block_3$2(ctx);

    	flexcontainer0 = new FlexContainer({
    			props: {
    				flexWrap: "wrap",
    				justifyContent: "center",
    				$$slots: { default: [create_default_slot_4$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	flexcontainer1 = new FlexContainer({
    			props: {
    				flexWrap: "wrap",
    				justifyContent: "center",
    				$$slots: { default: [create_default_slot_1$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			create_component(flexcontainer0.$$.fragment);
    			t2 = space();
    			create_component(flexcontainer1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(flexcontainer0, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(flexcontainer1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*raceTime*/ ctx[2]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*raceTime*/ 4) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_6$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!/*isVoteCircuit*/ ctx[10]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*isVoteCircuit*/ 1024) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_3$2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			const flexcontainer0_changes = {};

    			if (dirty & /*$$scope, isResume*/ 8388864) {
    				flexcontainer0_changes.$$scope = { dirty, ctx };
    			}

    			flexcontainer0.$set(flexcontainer0_changes);
    			const flexcontainer1_changes = {};

    			if (dirty & /*$$scope, isEditedCircuit*/ 8389120) {
    				flexcontainer1_changes.$$scope = { dirty, ctx };
    			}

    			flexcontainer1.$set(flexcontainer1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(flexcontainer0.$$.fragment, local);
    			transition_in(flexcontainer1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(flexcontainer0.$$.fragment, local);
    			transition_out(flexcontainer1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(flexcontainer0, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(flexcontainer1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(93:4) <Cell        color=\\\"orange\\\"        style=\\\"              width:{css.endRace.blockWidth + 2 * css.default.margin}px;              position:absolute;              top: calc(50% - 200px);              margin-left: auto;              margin-right: auto;              left: 0;              right: 0;              text-align: center;\\\"        title={circuitName}        titleImagePath=\\\"assets/images/menu/circuit.png\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*showMenu*/ ctx[0] && create_if_block$b(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*showMenu*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*showMenu*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$b(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let $loggedIn;
    	validate_store(loggedIn, 'loggedIn');
    	component_subscribe($$self, loggedIn, $$value => $$invalidate(11, $loggedIn = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EndraceMenu', slots, []);
    	let showMenu = false;
    	let raceRanking, raceTime, timeDiffWithGlobal; // The race times and rankings
    	let globalRanking, globalTime; // The global times and rankings for the logged user
    	let globalRecordLoading = false; // The loading animation when a record is being recorded on the database
    	let circuitName = "";
    	let isResume = true; // Show the resume button only if the race has not ended
    	let resumeButtonWidth = 50; // In percent
    	let isEditedCircuit = false;
    	let isVoteCircuit = false;

    	// Actions of the menu
    	function goToMenu() {
    		$$invalidate(0, showMenu = false);

    		isVoteCircuit
    		? Client$1.pushRoute("/circuitvote")
    		: Client$1.pushRoute("/campaignmenu");

    		Client$1.race.stop();
    		!isVoteCircuit && Client$1.socket.getCircuitRecords();
    	}

    	function goToEditor() {
    		$$invalidate(0, showMenu = false);
    		Client$1.pushRoute("/editor");
    		let circuitToEdit = Client$1.race.game.currentCircuit;
    		Client$1.race.stop();
    		Client$1.editor.initialize(circuitToEdit);
    	}

    	function restart() {
    		$$invalidate(0, showMenu = false);
    		Client$1.race.restart();
    	}

    	function resume() {
    		Client$1.race.setRacePause(false);
    		Client$1.svelte.showEndraceMenu(false);
    	}

    	// Show the menu (triggered if the race has ended or if the escape is pressed)
    	Client$1.svelte.showEndraceMenu = function (show, pos, time, diff) {
    		if (show == showMenu) {
    			// do it only if that's not the current state
    			return;
    		}

    		$$invalidate(9, isEditedCircuit = Client$1.race.game.currentCircuit.isEditedCircuit);
    		$$invalidate(10, isVoteCircuit = Client$1.race.game.currentCircuit.campaignPublicationTime < 0);

    		// Update the data and buttons
    		resumeButtonWidth = Client$1.race.user.ended ? 100 : 50;

    		$$invalidate(8, isResume = !Client$1.race.user.ended);
    		$$invalidate(7, circuitName = Client$1.race.game.currentCircuit.name);
    		$$invalidate(0, showMenu = show);
    		$$invalidate(1, raceRanking = pos);
    		$$invalidate(2, raceTime = time);
    		$$invalidate(3, timeDiffWithGlobal = diff);

    		if ((isNaN(diff) || diff < 0) && time) {
    			// If that's a new record, then do the loading animation to wait for the new record to be validated by the server
    			$$invalidate(6, globalRecordLoading = true);
    		}
    	};

    	// Once the new record has arrived
    	Client$1.svelte.updateEndraceRecord = function () {
    		if (!Client$1.race.user.record || !Client$1.race.user.record.run) {
    			return;
    		} // Error handling

    		$$invalidate(6, globalRecordLoading = false);
    		$$invalidate(4, globalRanking = Client$1.race.user.record.ranking + 1);
    		$$invalidate(5, globalTime = Client$1.race.user.record.run.runTime);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EndraceMenu> was created with unknown prop '${key}'`);
    	});

    	function rankingandtime_checkpointPosition_binding(value) {
    		raceRanking = value;
    		$$invalidate(1, raceRanking);
    	}

    	function rankingandtime_checkpointTime_binding(value) {
    		raceTime = value;
    		$$invalidate(2, raceTime);
    	}

    	function rankingandtime_checkpointDifference_binding(value) {
    		timeDiffWithGlobal = value;
    		$$invalidate(3, timeDiffWithGlobal);
    	}

    	function rankingandtime_checkpointPosition_binding_1(value) {
    		globalRanking = value;
    		$$invalidate(4, globalRanking);
    	}

    	function rankingandtime_checkpointTime_binding_1(value) {
    		globalTime = value;
    		$$invalidate(5, globalTime);
    	}

    	$$self.$capture_state = () => ({
    		push,
    		fade,
    		Shadow,
    		Client: Client$1,
    		loggedIn,
    		css,
    		PointerzButton,
    		RankingAndTime,
    		Cell,
    		CellTitle,
    		FlexContainer,
    		showMenu,
    		raceRanking,
    		raceTime,
    		timeDiffWithGlobal,
    		globalRanking,
    		globalTime,
    		globalRecordLoading,
    		circuitName,
    		isResume,
    		resumeButtonWidth,
    		isEditedCircuit,
    		isVoteCircuit,
    		goToMenu,
    		goToEditor,
    		restart,
    		resume,
    		$loggedIn
    	});

    	$$self.$inject_state = $$props => {
    		if ('showMenu' in $$props) $$invalidate(0, showMenu = $$props.showMenu);
    		if ('raceRanking' in $$props) $$invalidate(1, raceRanking = $$props.raceRanking);
    		if ('raceTime' in $$props) $$invalidate(2, raceTime = $$props.raceTime);
    		if ('timeDiffWithGlobal' in $$props) $$invalidate(3, timeDiffWithGlobal = $$props.timeDiffWithGlobal);
    		if ('globalRanking' in $$props) $$invalidate(4, globalRanking = $$props.globalRanking);
    		if ('globalTime' in $$props) $$invalidate(5, globalTime = $$props.globalTime);
    		if ('globalRecordLoading' in $$props) $$invalidate(6, globalRecordLoading = $$props.globalRecordLoading);
    		if ('circuitName' in $$props) $$invalidate(7, circuitName = $$props.circuitName);
    		if ('isResume' in $$props) $$invalidate(8, isResume = $$props.isResume);
    		if ('resumeButtonWidth' in $$props) resumeButtonWidth = $$props.resumeButtonWidth;
    		if ('isEditedCircuit' in $$props) $$invalidate(9, isEditedCircuit = $$props.isEditedCircuit);
    		if ('isVoteCircuit' in $$props) $$invalidate(10, isVoteCircuit = $$props.isVoteCircuit);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		showMenu,
    		raceRanking,
    		raceTime,
    		timeDiffWithGlobal,
    		globalRanking,
    		globalTime,
    		globalRecordLoading,
    		circuitName,
    		isResume,
    		isEditedCircuit,
    		isVoteCircuit,
    		$loggedIn,
    		goToMenu,
    		goToEditor,
    		restart,
    		resume,
    		rankingandtime_checkpointPosition_binding,
    		rankingandtime_checkpointTime_binding,
    		rankingandtime_checkpointDifference_binding,
    		rankingandtime_checkpointPosition_binding_1,
    		rankingandtime_checkpointTime_binding_1
    	];
    }

    class EndraceMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$l, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EndraceMenu",
    			options,
    			id: create_fragment$l.name
    		});
    	}
    }

    /* src\client\svelte\pages\RaceOverlay.svelte generated by Svelte v3.50.1 */
    const file$j = "src\\client\\svelte\\pages\\RaceOverlay.svelte";

    // (30:0) {#if loadingRace}
    function create_if_block$a(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let shadow;
    	let div2_outro;
    	let current;

    	shadow = new Shadow({
    			props: {
    				size: "80",
    				color: "var(--red-color)",
    				unit: "px"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			create_component(shadow.$$.fragment);
    			set_style(div0, "display", "inline-block");
    			add_location(div0, file$j, 32, 6, 1135);
    			attr_dev(div1, "class", "centerer svelte-1u1qfsh");
    			add_location(div1, file$j, 31, 4, 1105);
    			attr_dev(div2, "class", "background svelte-1u1qfsh");
    			add_location(div2, file$j, 30, 2, 1046);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			mount_component(shadow, div0, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(shadow.$$.fragment, local);
    			if (div2_outro) div2_outro.end(1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(shadow.$$.fragment, local);
    			div2_outro = create_out_transition(div2, fade, { duration: 400 });
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(shadow);
    			if (detaching && div2_outro) div2_outro.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(30:0) {#if loadingRace}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let offlineredirect;
    	let t0;
    	let liveranking;
    	let t1;
    	let racecounter;
    	let t2;
    	let racetime;
    	let t3;
    	let checkpointtime;
    	let t4;
    	let lapcounter;
    	let t5;
    	let endracemenu;
    	let t6;
    	let if_block_anchor;
    	let current;
    	offlineredirect = new OfflineRedirect({ $$inline: true });
    	liveranking = new LiveRanking({ $$inline: true });
    	racecounter = new RaceCounter({ $$inline: true });
    	racetime = new RaceTime({ $$inline: true });
    	checkpointtime = new CheckpointTime({ $$inline: true });
    	lapcounter = new LapCounter({ $$inline: true });
    	endracemenu = new EndraceMenu({ $$inline: true });
    	let if_block = /*loadingRace*/ ctx[0] && create_if_block$a(ctx);

    	const block = {
    		c: function create() {
    			create_component(offlineredirect.$$.fragment);
    			t0 = space();
    			create_component(liveranking.$$.fragment);
    			t1 = space();
    			create_component(racecounter.$$.fragment);
    			t2 = space();
    			create_component(racetime.$$.fragment);
    			t3 = space();
    			create_component(checkpointtime.$$.fragment);
    			t4 = space();
    			create_component(lapcounter.$$.fragment);
    			t5 = space();
    			create_component(endracemenu.$$.fragment);
    			t6 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(offlineredirect, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(liveranking, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(racecounter, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(racetime, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(checkpointtime, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(lapcounter, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(endracemenu, target, anchor);
    			insert_dev(target, t6, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*loadingRace*/ ctx[0]) {
    				if (if_block) {
    					if (dirty & /*loadingRace*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$a(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(offlineredirect.$$.fragment, local);
    			transition_in(liveranking.$$.fragment, local);
    			transition_in(racecounter.$$.fragment, local);
    			transition_in(racetime.$$.fragment, local);
    			transition_in(checkpointtime.$$.fragment, local);
    			transition_in(lapcounter.$$.fragment, local);
    			transition_in(endracemenu.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(offlineredirect.$$.fragment, local);
    			transition_out(liveranking.$$.fragment, local);
    			transition_out(racecounter.$$.fragment, local);
    			transition_out(racetime.$$.fragment, local);
    			transition_out(checkpointtime.$$.fragment, local);
    			transition_out(lapcounter.$$.fragment, local);
    			transition_out(endracemenu.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(offlineredirect, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(liveranking, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(racecounter, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(racetime, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(checkpointtime, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(lapcounter, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(endracemenu, detaching);
    			if (detaching) detach_dev(t6);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('RaceOverlay', slots, []);
    	let loadingRace = true; // The loading circuit animation

    	// Circuit loading animation
    	Client$1.svelte.setRaceLoading = function (val) {
    		$$invalidate(0, loadingRace = val);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RaceOverlay> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		fade,
    		Shadow,
    		Client: Client$1,
    		CheckpointTime,
    		LapCounter,
    		LiveRanking,
    		RaceCounter,
    		RaceTime,
    		EndraceMenu,
    		OfflineRedirect,
    		loadingRace
    	});

    	$$self.$inject_state = $$props => {
    		if ('loadingRace' in $$props) $$invalidate(0, loadingRace = $$props.loadingRace);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [loadingRace];
    }

    class RaceOverlay extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$k, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RaceOverlay",
    			options,
    			id: create_fragment$k.name
    		});
    	}
    }

    /* src\client\svelte\pages\EditorMenu.svelte generated by Svelte v3.50.1 */
    const file$i = "src\\client\\svelte\\pages\\EditorMenu.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	child_ctx[16] = i;
    	return child_ctx;
    }

    // (127:10) <TextBlock              clickable              color={selectedCircuitId == circuit._id ? "darkOrange" : "grey"}              on:click={() => selectCircuit(circuit._id)}              slideTransition>
    function create_default_slot_7(ctx) {
    	let t0_value = /*circuit*/ ctx[14].name + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$loadedEditorCircuits*/ 2 && t0_value !== (t0_value = /*circuit*/ ctx[14].name + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(127:10) <TextBlock              clickable              color={selectedCircuitId == circuit._id ? \\\"darkOrange\\\" : \\\"grey\\\"}              on:click={() => selectCircuit(circuit._id)}              slideTransition>",
    		ctx
    	});

    	return block;
    }

    // (126:8) {#each $loadedEditorCircuits as circuit, i (circuit._id)}
    function create_each_block$8(key_1, ctx) {
    	let first;
    	let textblock;
    	let current;

    	function click_handler() {
    		return /*click_handler*/ ctx[6](/*circuit*/ ctx[14]);
    	}

    	textblock = new TextBlock({
    			props: {
    				clickable: true,
    				color: /*selectedCircuitId*/ ctx[0] == /*circuit*/ ctx[14]._id
    				? "darkOrange"
    				: "grey",
    				slideTransition: true,
    				$$slots: { default: [create_default_slot_7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	textblock.$on("click", click_handler);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(textblock.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(textblock, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const textblock_changes = {};

    			if (dirty & /*selectedCircuitId, $loadedEditorCircuits*/ 3) textblock_changes.color = /*selectedCircuitId*/ ctx[0] == /*circuit*/ ctx[14]._id
    			? "darkOrange"
    			: "grey";

    			if (dirty & /*$$scope, $loadedEditorCircuits*/ 131074) {
    				textblock_changes.$$scope = { dirty, ctx };
    			}

    			textblock.$set(textblock_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(textblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(126:8) {#each $loadedEditorCircuits as circuit, i (circuit._id)}",
    		ctx
    	});

    	return block;
    }

    // (122:6) <Cell          title="Circuits"          color="orange"          titleImagePath="assets/images/menu/circuit.png">
    function create_default_slot_6$1(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let current;
    	let each_value = /*$loadedEditorCircuits*/ ctx[1];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*circuit*/ ctx[14]._id;
    	validate_each_keys(ctx, each_value, get_each_context$8, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$8(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$8(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*selectedCircuitId, $loadedEditorCircuits, selectCircuit*/ 7) {
    				each_value = /*$loadedEditorCircuits*/ ctx[1];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$8, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$8, each_1_anchor, get_each_context$8);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$1.name,
    		type: "slot",
    		source: "(122:6) <Cell          title=\\\"Circuits\\\"          color=\\\"orange\\\"          titleImagePath=\\\"assets/images/menu/circuit.png\\\">",
    		ctx
    	});

    	return block;
    }

    // (139:8) {#if selectedCircuitId}
    function create_if_block$9(ctx) {
    	let div;
    	let pointerzbutton;
    	let t;
    	let pointerzconfirm;
    	let div_transition;
    	let current;

    	pointerzbutton = new PointerzButton({
    			props: {
    				buttonColor: "darkBlue",
    				important: true,
    				elementsPerRow: "1",
    				imagePath: "assets/images/menu/edit.png",
    				animateImage: "false",
    				imageHeight: "16px",
    				$$slots: { default: [create_default_slot_5$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pointerzbutton.$on("click", /*editSelectedEditorCircuit*/ ctx[5]);

    	pointerzconfirm = new PointerzConfirm({
    			props: {
    				confirmTitle: "Delete",
    				cancelTitle: "Cancel",
    				$$slots: {
    					description: [
    						create_description_slot$1,
    						({ confirm: confirmThis }) => ({ 13: confirmThis }),
    						({ confirm: confirmThis }) => confirmThis ? 8192 : 0
    					],
    					title: [
    						create_title_slot$1,
    						({ confirm: confirmThis }) => ({ 13: confirmThis }),
    						({ confirm: confirmThis }) => confirmThis ? 8192 : 0
    					],
    					default: [
    						create_default_slot_3$1,
    						({ confirm: confirmThis }) => ({ 13: confirmThis }),
    						({ confirm: confirmThis }) => confirmThis ? 8192 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(pointerzbutton.$$.fragment);
    			t = space();
    			create_component(pointerzconfirm.$$.fragment);
    			set_style(div, "margin-bottom", "16px");
    			add_location(div, file$i, 139, 10, 4015);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(pointerzbutton, div, null);
    			append_dev(div, t);
    			mount_component(pointerzconfirm, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pointerzbutton_changes = {};

    			if (dirty & /*$$scope*/ 131072) {
    				pointerzbutton_changes.$$scope = { dirty, ctx };
    			}

    			pointerzbutton.$set(pointerzbutton_changes);
    			const pointerzconfirm_changes = {};

    			if (dirty & /*$$scope, confirmThis*/ 139264) {
    				pointerzconfirm_changes.$$scope = { dirty, ctx };
    			}

    			pointerzconfirm.$set(pointerzconfirm_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerzbutton.$$.fragment, local);
    			transition_in(pointerzconfirm.$$.fragment, local);

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {}, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerzbutton.$$.fragment, local);
    			transition_out(pointerzconfirm.$$.fragment, local);
    			if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {}, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(pointerzbutton);
    			destroy_component(pointerzconfirm);
    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(139:8) {#if selectedCircuitId}",
    		ctx
    	});

    	return block;
    }

    // (141:12) <PointerzButton                buttonColor="darkBlue"                important                elementsPerRow="1"                imagePath="assets/images/menu/edit.png"                animateImage="false"                imageHeight="16px"                on:click={editSelectedEditorCircuit}>
    function create_default_slot_5$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Edit");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$1.name,
    		type: "slot",
    		source: "(141:12) <PointerzButton                buttonColor=\\\"darkBlue\\\"                important                elementsPerRow=\\\"1\\\"                imagePath=\\\"assets/images/menu/edit.png\\\"                animateImage=\\\"false\\\"                imageHeight=\\\"16px\\\"                on:click={editSelectedEditorCircuit}>",
    		ctx
    	});

    	return block;
    }

    // (155:14) <PointerzButton                  buttonColor="darkRed"                  important                  elementsPerRow="1"                  imagePath="assets/images/menu/delete.png"                  animateImage="false"                  imageHeight="16px"                  noSound                  on:click={() => confirmThis(deleteEditorCircuit)}>
    function create_default_slot_4$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Delete");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$1.name,
    		type: "slot",
    		source: "(155:14) <PointerzButton                  buttonColor=\\\"darkRed\\\"                  important                  elementsPerRow=\\\"1\\\"                  imagePath=\\\"assets/images/menu/delete.png\\\"                  animateImage=\\\"false\\\"                  imageHeight=\\\"16px\\\"                  noSound                  on:click={() => confirmThis(deleteEditorCircuit)}>",
    		ctx
    	});

    	return block;
    }

    // (151:12) <PointerzConfirm                let:confirm={confirmThis}                confirmTitle="Delete"                cancelTitle="Cancel">
    function create_default_slot_3$1(ctx) {
    	let pointerzbutton;
    	let current;

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[7](/*confirmThis*/ ctx[13]);
    	}

    	pointerzbutton = new PointerzButton({
    			props: {
    				buttonColor: "darkRed",
    				important: true,
    				elementsPerRow: "1",
    				imagePath: "assets/images/menu/delete.png",
    				animateImage: "false",
    				imageHeight: "16px",
    				noSound: true,
    				$$slots: { default: [create_default_slot_4$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pointerzbutton.$on("click", click_handler_1);

    	const block = {
    		c: function create() {
    			create_component(pointerzbutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pointerzbutton, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const pointerzbutton_changes = {};

    			if (dirty & /*$$scope*/ 131072) {
    				pointerzbutton_changes.$$scope = { dirty, ctx };
    			}

    			pointerzbutton.$set(pointerzbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerzbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerzbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pointerzbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$1.name,
    		type: "slot",
    		source: "(151:12) <PointerzConfirm                let:confirm={confirmThis}                confirmTitle=\\\"Delete\\\"                cancelTitle=\\\"Cancel\\\">",
    		ctx
    	});

    	return block;
    }

    // (166:14) 
    function create_title_slot$1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Do you really want to delete this circuit ?";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$i, 165, 14, 4998);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$1.name,
    		type: "slot",
    		source: "(166:14) ",
    		ctx
    	});

    	return block;
    }

    // (169:14) 
    function create_description_slot$1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "slot", "description");
    			add_location(span, file$i, 168, 14, 5117);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_description_slot$1.name,
    		type: "slot",
    		source: "(169:14) ",
    		ctx
    	});

    	return block;
    }

    // (173:8) <PointerzButton            buttonColor="darkGreen"            important            elementsPerRow="1"            lastRow            imagePath="assets/images/menu/add.png"            animateImage="false"            imageHeight="16px"            on:click={createNewCircuit}>
    function create_default_slot_2$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("New");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(173:8) <PointerzButton            buttonColor=\\\"darkGreen\\\"            important            elementsPerRow=\\\"1\\\"            lastRow            imagePath=\\\"assets/images/menu/add.png\\\"            animateImage=\\\"false\\\"            imageHeight=\\\"16px\\\"            on:click={createNewCircuit}>",
    		ctx
    	});

    	return block;
    }

    // (138:6) <Cell>
    function create_default_slot_1$2(ctx) {
    	let t;
    	let pointerzbutton;
    	let current;
    	let if_block = /*selectedCircuitId*/ ctx[0] && create_if_block$9(ctx);

    	pointerzbutton = new PointerzButton({
    			props: {
    				buttonColor: "darkGreen",
    				important: true,
    				elementsPerRow: "1",
    				lastRow: true,
    				imagePath: "assets/images/menu/add.png",
    				animateImage: "false",
    				imageHeight: "16px",
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pointerzbutton.$on("click", /*createNewCircuit*/ ctx[3]);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			create_component(pointerzbutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(pointerzbutton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*selectedCircuitId*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*selectedCircuitId*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$9(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const pointerzbutton_changes = {};

    			if (dirty & /*$$scope*/ 131072) {
    				pointerzbutton_changes.$$scope = { dirty, ctx };
    			}

    			pointerzbutton.$set(pointerzbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(pointerzbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(pointerzbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(pointerzbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(138:6) <Cell>",
    		ctx
    	});

    	return block;
    }

    // (114:0) <AppLayout>
    function create_default_slot$6(ctx) {
    	let offlineredirect;
    	let t0;
    	let div2;
    	let backbutton;
    	let t1;
    	let div0;
    	let cell0;
    	let t2;
    	let div1;
    	let cell1;
    	let div2_intro;
    	let div2_outro;
    	let current;
    	offlineredirect = new OfflineRedirect({ $$inline: true });

    	backbutton = new BackButton({
    			props: { backHref: "/privatemenu" },
    			$$inline: true
    		});

    	cell0 = new Cell({
    			props: {
    				title: "Circuits",
    				color: "orange",
    				titleImagePath: "assets/images/menu/circuit.png",
    				$$slots: { default: [create_default_slot_6$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	cell1 = new Cell({
    			props: {
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(offlineredirect.$$.fragment);
    			t0 = space();
    			div2 = element("div");
    			create_component(backbutton.$$.fragment);
    			t1 = space();
    			div0 = element("div");
    			create_component(cell0.$$.fragment);
    			t2 = space();
    			div1 = element("div");
    			create_component(cell1.$$.fragment);
    			attr_dev(div0, "class", "circuitsContainer svelte-1lntuta");
    			add_location(div0, file$i, 120, 4, 3395);
    			attr_dev(div1, "class", "actionsContainer svelte-1lntuta");
    			add_location(div1, file$i, 136, 4, 3926);
    			attr_dev(div2, "id", "menuContainer");
    			attr_dev(div2, "class", "svelte-1lntuta");
    			add_location(div2, file$i, 115, 2, 3238);
    		},
    		m: function mount(target, anchor) {
    			mount_component(offlineredirect, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div2, anchor);
    			mount_component(backbutton, div2, null);
    			append_dev(div2, t1);
    			append_dev(div2, div0);
    			mount_component(cell0, div0, null);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			mount_component(cell1, div1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const cell0_changes = {};

    			if (dirty & /*$$scope, $loadedEditorCircuits, selectedCircuitId*/ 131075) {
    				cell0_changes.$$scope = { dirty, ctx };
    			}

    			cell0.$set(cell0_changes);
    			const cell1_changes = {};

    			if (dirty & /*$$scope, selectedCircuitId*/ 131073) {
    				cell1_changes.$$scope = { dirty, ctx };
    			}

    			cell1.$set(cell1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(offlineredirect.$$.fragment, local);
    			transition_in(backbutton.$$.fragment, local);
    			transition_in(cell0.$$.fragment, local);
    			transition_in(cell1.$$.fragment, local);

    			add_render_callback(() => {
    				if (div2_outro) div2_outro.end(1);
    				div2_intro = create_in_transition(div2, fly, { delay: 400, duration: 400 });
    				div2_intro.start();
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(offlineredirect.$$.fragment, local);
    			transition_out(backbutton.$$.fragment, local);
    			transition_out(cell0.$$.fragment, local);
    			transition_out(cell1.$$.fragment, local);
    			if (div2_intro) div2_intro.invalidate();
    			div2_outro = create_out_transition(div2, fade, { duration: 400 });
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(offlineredirect, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div2);
    			destroy_component(backbutton);
    			destroy_component(cell0);
    			destroy_component(cell1);
    			if (detaching && div2_outro) div2_outro.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(114:0) <AppLayout>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let applayout;
    	let current;

    	applayout = new AppLayout({
    			props: {
    				$$slots: { default: [create_default_slot$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(applayout.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(applayout, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const applayout_changes = {};

    			if (dirty & /*$$scope, selectedCircuitId, $loadedEditorCircuits*/ 131075) {
    				applayout_changes.$$scope = { dirty, ctx };
    			}

    			applayout.$set(applayout_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(applayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(applayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(applayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const defaultNewCircuitName = "New circuit";

    function instance$j($$self, $$props, $$invalidate) {
    	let selectedCircuit;
    	let $passedData;
    	let $loadedEditorCircuits;
    	let $infoInfo;
    	let $infoError;
    	validate_store(passedData, 'passedData');
    	component_subscribe($$self, passedData, $$value => $$invalidate(10, $passedData = $$value));
    	validate_store(loadedEditorCircuits, 'loadedEditorCircuits');
    	component_subscribe($$self, loadedEditorCircuits, $$value => $$invalidate(1, $loadedEditorCircuits = $$value));
    	validate_store(infoInfo, 'infoInfo');
    	component_subscribe($$self, infoInfo, $$value => $$invalidate(11, $infoInfo = $$value));
    	validate_store(infoError, 'infoError');
    	component_subscribe($$self, infoError, $$value => $$invalidate(12, $infoError = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EditorMenu', slots, []);
    	let selectedCircuitId;

    	function selectCircuit(id) {
    		Client$1.phaser.playSound("buttonSelection");
    		$$invalidate(0, selectedCircuitId = id);
    	}

    	function createNewCircuit() {
    		let newCircuitName = defaultNewCircuitName;
    		let circuitNewId = 0;

    		while ($loadedEditorCircuits.find(circuit => circuit.name == newCircuitName)) {
    			circuitNewId++;
    			newCircuitName = defaultNewCircuitName + " (" + circuitNewId + ")";
    		}

    		Client$1.socket.createNewEditorCircuit(newCircuitName);
    	}

    	function deleteEditorCircuit() {
    		let selectedCircuit = $loadedEditorCircuits.find(circuit => circuit._id == selectedCircuitId);

    		if (!selectedCircuit) {
    			return;
    		}

    		Client$1.socket.deleteEditorCircuit(selectedCircuitId);
    	}

    	function editSelectedEditorCircuit() {
    		if (!selectCircuit) {
    			set_store_value(infoError, $infoError = "You did not select a circuit", $infoError);
    			return;
    		}

    		Client$1.pushRoute("/editor");
    		Client$1.editor.initialize(selectedCircuit);
    	}

    	Client$1.svelte.updateEditorCircuitCreated = function ({ retError, retInfo, newEditorCircuit }) {
    		if (retError) {
    			set_store_value(infoError, $infoError = retError, $infoError);
    		} else {
    			set_store_value(infoInfo, $infoInfo = retInfo, $infoInfo);
    			Client$1.svelte.updateLoadedEditorCircuits([newEditorCircuit, ...$loadedEditorCircuits]);
    			selectCircuit(newEditorCircuit._id);
    		}
    	};

    	Client$1.svelte.updateEditorCircuitDeleted = function ({ retError, retInfo, deletedEditorCircuitId }) {
    		if (retError) {
    			set_store_value(infoError, $infoError = retError, $infoError);
    		} else {
    			set_store_value(infoInfo, $infoInfo = retInfo, $infoInfo);
    			let tempLoadedEditorCircuits = [...$loadedEditorCircuits];
    			tempLoadedEditorCircuits.splice(tempLoadedEditorCircuits.findIndex(circuit => circuit._id == deletedEditorCircuitId), 1);
    			Client$1.svelte.updateLoadedEditorCircuits(tempLoadedEditorCircuits);
    		}
    	};

    	Client$1.svelte.updateLoadedEditorCircuits = function (editorCircuits) {
    		if (!editorCircuits) {
    			return;
    		}

    		set_store_value(loadedEditorCircuits, $loadedEditorCircuits = editorCircuits.sort((a, b) => b.creationDate - a.creationDate), $loadedEditorCircuits);
    	};

    	Client$1.svelte.updateLoadedEditorCircuits($passedData.editorCircuits);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EditorMenu> was created with unknown prop '${key}'`);
    	});

    	const click_handler = circuit => selectCircuit(circuit._id);
    	const click_handler_1 = confirmThis => confirmThis(deleteEditorCircuit);

    	$$self.$capture_state = () => ({
    		fly,
    		fade,
    		slide,
    		push,
    		Client: Client$1,
    		loadedEditorCircuits,
    		passedData,
    		infoError,
    		infoInfo,
    		PointerzConfirm,
    		PointerzButton,
    		AppLayout,
    		Cell,
    		TextBlock,
    		BackButton,
    		OfflineRedirect,
    		defaultNewCircuitName,
    		selectedCircuitId,
    		selectCircuit,
    		createNewCircuit,
    		deleteEditorCircuit,
    		editSelectedEditorCircuit,
    		selectedCircuit,
    		$passedData,
    		$loadedEditorCircuits,
    		$infoInfo,
    		$infoError
    	});

    	$$self.$inject_state = $$props => {
    		if ('selectedCircuitId' in $$props) $$invalidate(0, selectedCircuitId = $$props.selectedCircuitId);
    		if ('selectedCircuit' in $$props) selectedCircuit = $$props.selectedCircuit;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$loadedEditorCircuits, selectedCircuitId*/ 3) {
    			selectedCircuit = $loadedEditorCircuits.find(circuit => circuit._id == selectedCircuitId);
    		}
    	};

    	return [
    		selectedCircuitId,
    		$loadedEditorCircuits,
    		selectCircuit,
    		createNewCircuit,
    		deleteEditorCircuit,
    		editSelectedEditorCircuit,
    		click_handler,
    		click_handler_1
    	];
    }

    class EditorMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EditorMenu",
    			options,
    			id: create_fragment$j.name
    		});
    	}
    }

    function flip(node, { from, to }, params = {}) {
        const style = getComputedStyle(node);
        const transform = style.transform === 'none' ? '' : style.transform;
        const [ox, oy] = style.transformOrigin.split(' ').map(parseFloat);
        const dx = (from.left + from.width * ox / to.width) - (to.left + ox);
        const dy = (from.top + from.height * oy / to.height) - (to.top + oy);
        const { delay = 0, duration = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params;
        return {
            delay,
            duration: is_function(duration) ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,
            easing,
            css: (t, u) => {
                const x = u * dx;
                const y = u * dy;
                const sx = t + u * from.width / to.width;
                const sy = t + u * from.height / to.height;
                return `transform: ${transform} translate(${x}px, ${y}px) scale(${sx}, ${sy});`;
            }
        };
    }

    function isOutOfViewport (parent, container) {
        const parentBounding = parent.getBoundingClientRect();
        const boundingContainer = container.getBoundingClientRect();
        const out = {};

        out.top = parentBounding.top < 0;
        out.left = parentBounding.left < 0;
        out.bottom =
            parentBounding.bottom + boundingContainer.height >
            (window.innerHeight || document.documentElement.clientHeight);

        out.right =
            parentBounding.right >
            (window.innerWidth || document.documentElement.clientWidth);
        out.any = out.top || out.left || out.bottom || out.right;

        return out;
    }

    /* node_modules\svelte-select\src\Item.svelte generated by Svelte v3.50.1 */

    const file$h = "node_modules\\svelte-select\\src\\Item.svelte";

    function create_fragment$i(ctx) {
    	let div;
    	let raw_value = /*getOptionLabel*/ ctx[0](/*item*/ ctx[1], /*filterText*/ ctx[2]) + "";
    	let div_class_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", div_class_value = "item " + /*itemClasses*/ ctx[3] + " svelte-3e0qet");
    			add_location(div, file$h, 78, 0, 1837);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			div.innerHTML = raw_value;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*getOptionLabel, item, filterText*/ 7 && raw_value !== (raw_value = /*getOptionLabel*/ ctx[0](/*item*/ ctx[1], /*filterText*/ ctx[2]) + "")) div.innerHTML = raw_value;
    			if (dirty & /*itemClasses*/ 8 && div_class_value !== (div_class_value = "item " + /*itemClasses*/ ctx[3] + " svelte-3e0qet")) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Item', slots, []);
    	let { isActive = false } = $$props;
    	let { isFirst = false } = $$props;
    	let { isHover = false } = $$props;
    	let { isSelectable = false } = $$props;
    	let { getOptionLabel = undefined } = $$props;
    	let { item = undefined } = $$props;
    	let { filterText = '' } = $$props;
    	let itemClasses = '';

    	const writable_props = [
    		'isActive',
    		'isFirst',
    		'isHover',
    		'isSelectable',
    		'getOptionLabel',
    		'item',
    		'filterText'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Item> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('isActive' in $$props) $$invalidate(4, isActive = $$props.isActive);
    		if ('isFirst' in $$props) $$invalidate(5, isFirst = $$props.isFirst);
    		if ('isHover' in $$props) $$invalidate(6, isHover = $$props.isHover);
    		if ('isSelectable' in $$props) $$invalidate(7, isSelectable = $$props.isSelectable);
    		if ('getOptionLabel' in $$props) $$invalidate(0, getOptionLabel = $$props.getOptionLabel);
    		if ('item' in $$props) $$invalidate(1, item = $$props.item);
    		if ('filterText' in $$props) $$invalidate(2, filterText = $$props.filterText);
    	};

    	$$self.$capture_state = () => ({
    		isActive,
    		isFirst,
    		isHover,
    		isSelectable,
    		getOptionLabel,
    		item,
    		filterText,
    		itemClasses
    	});

    	$$self.$inject_state = $$props => {
    		if ('isActive' in $$props) $$invalidate(4, isActive = $$props.isActive);
    		if ('isFirst' in $$props) $$invalidate(5, isFirst = $$props.isFirst);
    		if ('isHover' in $$props) $$invalidate(6, isHover = $$props.isHover);
    		if ('isSelectable' in $$props) $$invalidate(7, isSelectable = $$props.isSelectable);
    		if ('getOptionLabel' in $$props) $$invalidate(0, getOptionLabel = $$props.getOptionLabel);
    		if ('item' in $$props) $$invalidate(1, item = $$props.item);
    		if ('filterText' in $$props) $$invalidate(2, filterText = $$props.filterText);
    		if ('itemClasses' in $$props) $$invalidate(3, itemClasses = $$props.itemClasses);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*isActive, isFirst, isHover, item, isSelectable*/ 242) {
    			{
    				const classes = [];

    				if (isActive) {
    					classes.push('active');
    				}

    				if (isFirst) {
    					classes.push('first');
    				}

    				if (isHover) {
    					classes.push('hover');
    				}

    				if (item.isGroupHeader) {
    					classes.push('groupHeader');
    				}

    				if (item.isGroupItem) {
    					classes.push('groupItem');
    				}

    				if (!isSelectable) {
    					classes.push('notSelectable');
    				}

    				$$invalidate(3, itemClasses = classes.join(' '));
    			}
    		}
    	};

    	return [
    		getOptionLabel,
    		item,
    		filterText,
    		itemClasses,
    		isActive,
    		isFirst,
    		isHover,
    		isSelectable
    	];
    }

    class Item extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$i, create_fragment$i, safe_not_equal, {
    			isActive: 4,
    			isFirst: 5,
    			isHover: 6,
    			isSelectable: 7,
    			getOptionLabel: 0,
    			item: 1,
    			filterText: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Item",
    			options,
    			id: create_fragment$i.name
    		});
    	}

    	get isActive() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isActive(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isFirst() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isFirst(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isHover() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isHover(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isSelectable() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isSelectable(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getOptionLabel() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getOptionLabel(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get item() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filterText() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filterText(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-select\src\List.svelte generated by Svelte v3.50.1 */
    const file$g = "node_modules\\svelte-select\\src\\List.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[41] = list[i];
    	child_ctx[42] = i;
    	return child_ctx;
    }

    // (309:4) {:else}
    function create_else_block$4(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*items*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	let each_1_else = null;

    	if (!each_value.length) {
    		each_1_else = create_else_block_2(ctx);
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();

    			if (each_1_else) {
    				each_1_else.c();
    			}
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);

    			if (each_1_else) {
    				each_1_else.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*getGroupHeaderLabel, items, handleHover, handleClick, Item, filterText, getOptionLabel, value, optionIdentifier, hoverItemIndex, noOptionsMessage, hideEmptyState*/ 114390) {
    				each_value = /*items*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();

    				if (!each_value.length && each_1_else) {
    					each_1_else.p(ctx, dirty);
    				} else if (!each_value.length) {
    					each_1_else = create_else_block_2(ctx);
    					each_1_else.c();
    					each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
    				} else if (each_1_else) {
    					each_1_else.d(1);
    					each_1_else = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    			if (each_1_else) each_1_else.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(309:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (286:4) {#if isVirtualList}
    function create_if_block$8(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*VirtualList*/ ctx[3];

    	function switch_props(ctx) {
    		return {
    			props: {
    				items: /*items*/ ctx[1],
    				itemHeight: /*itemHeight*/ ctx[8],
    				$$slots: {
    					default: [
    						create_default_slot$5,
    						({ item, i }) => ({ 41: item, 42: i }),
    						({ item, i }) => [0, (item ? 1024 : 0) | (i ? 2048 : 0)]
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty[0] & /*items*/ 2) switch_instance_changes.items = /*items*/ ctx[1];
    			if (dirty[0] & /*itemHeight*/ 256) switch_instance_changes.itemHeight = /*itemHeight*/ ctx[8];

    			if (dirty[0] & /*Item, filterText, getOptionLabel, value, optionIdentifier, hoverItemIndex, items*/ 9814 | dirty[1] & /*$$scope, i, item*/ 11264) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*VirtualList*/ ctx[3])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(286:4) {#if isVirtualList}",
    		ctx
    	});

    	return block;
    }

    // (331:8) {:else}
    function create_else_block_2(ctx) {
    	let if_block_anchor;
    	let if_block = !/*hideEmptyState*/ ctx[11] && create_if_block_2$3(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (!/*hideEmptyState*/ ctx[11]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$3(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(331:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (332:12) {#if !hideEmptyState}
    function create_if_block_2$3(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*noOptionsMessage*/ ctx[12]);
    			attr_dev(div, "class", "empty svelte-1uyqfml");
    			add_location(div, file$g, 332, 16, 10333);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*noOptionsMessage*/ 4096) set_data_dev(t, /*noOptionsMessage*/ ctx[12]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(332:12) {#if !hideEmptyState}",
    		ctx
    	});

    	return block;
    }

    // (313:12) {:else}
    function create_else_block_1(ctx) {
    	let div;
    	let switch_instance;
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*Item*/ ctx[4];

    	function switch_props(ctx) {
    		return {
    			props: {
    				item: /*item*/ ctx[41],
    				filterText: /*filterText*/ ctx[13],
    				getOptionLabel: /*getOptionLabel*/ ctx[6],
    				isFirst: isItemFirst(/*i*/ ctx[42]),
    				isActive: isItemActive(/*item*/ ctx[41], /*value*/ ctx[9], /*optionIdentifier*/ ctx[10]),
    				isHover: isItemHover(/*hoverItemIndex*/ ctx[2], /*item*/ ctx[41], /*i*/ ctx[42], /*items*/ ctx[1]),
    				isSelectable: isItemSelectable(/*item*/ ctx[41])
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	function mouseover_handler_1() {
    		return /*mouseover_handler_1*/ ctx[29](/*i*/ ctx[42]);
    	}

    	function focus_handler_1() {
    		return /*focus_handler_1*/ ctx[30](/*i*/ ctx[42]);
    	}

    	function click_handler_1(...args) {
    		return /*click_handler_1*/ ctx[31](/*item*/ ctx[41], /*i*/ ctx[42], ...args);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			t = space();
    			attr_dev(div, "class", "listItem");
    			attr_dev(div, "tabindex", "-1");
    			add_location(div, file$g, 313, 16, 9513);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			append_dev(div, t);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "mouseover", mouseover_handler_1, false, false, false),
    					listen_dev(div, "focus", focus_handler_1, false, false, false),
    					listen_dev(div, "click", click_handler_1, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const switch_instance_changes = {};
    			if (dirty[0] & /*items*/ 2) switch_instance_changes.item = /*item*/ ctx[41];
    			if (dirty[0] & /*filterText*/ 8192) switch_instance_changes.filterText = /*filterText*/ ctx[13];
    			if (dirty[0] & /*getOptionLabel*/ 64) switch_instance_changes.getOptionLabel = /*getOptionLabel*/ ctx[6];
    			if (dirty[0] & /*items, value, optionIdentifier*/ 1538) switch_instance_changes.isActive = isItemActive(/*item*/ ctx[41], /*value*/ ctx[9], /*optionIdentifier*/ ctx[10]);
    			if (dirty[0] & /*hoverItemIndex, items*/ 6) switch_instance_changes.isHover = isItemHover(/*hoverItemIndex*/ ctx[2], /*item*/ ctx[41], /*i*/ ctx[42], /*items*/ ctx[1]);
    			if (dirty[0] & /*items*/ 2) switch_instance_changes.isSelectable = isItemSelectable(/*item*/ ctx[41]);

    			if (switch_value !== (switch_value = /*Item*/ ctx[4])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, t);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(313:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (311:12) {#if item.isGroupHeader && !item.isSelectable}
    function create_if_block_1$6(ctx) {
    	let div;
    	let t_value = /*getGroupHeaderLabel*/ ctx[7](/*item*/ ctx[41]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "listGroupTitle svelte-1uyqfml");
    			add_location(div, file$g, 311, 16, 9415);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*getGroupHeaderLabel, items*/ 130 && t_value !== (t_value = /*getGroupHeaderLabel*/ ctx[7](/*item*/ ctx[41]) + "")) set_data_dev(t, t_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(311:12) {#if item.isGroupHeader && !item.isSelectable}",
    		ctx
    	});

    	return block;
    }

    // (310:8) {#each items as item, i}
    function create_each_block$7(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$6, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*item*/ ctx[41].isGroupHeader && !/*item*/ ctx[41].isSelectable) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(310:8) {#each items as item, i}",
    		ctx
    	});

    	return block;
    }

    // (287:8) <svelte:component             this={VirtualList}             {items}             {itemHeight}             let:item             let:i>
    function create_default_slot$5(ctx) {
    	let div;
    	let switch_instance;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*Item*/ ctx[4];

    	function switch_props(ctx) {
    		return {
    			props: {
    				item: /*item*/ ctx[41],
    				filterText: /*filterText*/ ctx[13],
    				getOptionLabel: /*getOptionLabel*/ ctx[6],
    				isFirst: isItemFirst(/*i*/ ctx[42]),
    				isActive: isItemActive(/*item*/ ctx[41], /*value*/ ctx[9], /*optionIdentifier*/ ctx[10]),
    				isHover: isItemHover(/*hoverItemIndex*/ ctx[2], /*item*/ ctx[41], /*i*/ ctx[42], /*items*/ ctx[1]),
    				isSelectable: isItemSelectable(/*item*/ ctx[41])
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	function mouseover_handler() {
    		return /*mouseover_handler*/ ctx[26](/*i*/ ctx[42]);
    	}

    	function focus_handler() {
    		return /*focus_handler*/ ctx[27](/*i*/ ctx[42]);
    	}

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[28](/*item*/ ctx[41], /*i*/ ctx[42], ...args);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(div, "class", "listItem");
    			add_location(div, file$g, 292, 12, 8621);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "mouseover", mouseover_handler, false, false, false),
    					listen_dev(div, "focus", focus_handler, false, false, false),
    					listen_dev(div, "click", click_handler, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const switch_instance_changes = {};
    			if (dirty[1] & /*item*/ 1024) switch_instance_changes.item = /*item*/ ctx[41];
    			if (dirty[0] & /*filterText*/ 8192) switch_instance_changes.filterText = /*filterText*/ ctx[13];
    			if (dirty[0] & /*getOptionLabel*/ 64) switch_instance_changes.getOptionLabel = /*getOptionLabel*/ ctx[6];
    			if (dirty[1] & /*i*/ 2048) switch_instance_changes.isFirst = isItemFirst(/*i*/ ctx[42]);
    			if (dirty[0] & /*value, optionIdentifier*/ 1536 | dirty[1] & /*item*/ 1024) switch_instance_changes.isActive = isItemActive(/*item*/ ctx[41], /*value*/ ctx[9], /*optionIdentifier*/ ctx[10]);
    			if (dirty[0] & /*hoverItemIndex, items*/ 6 | dirty[1] & /*item, i*/ 3072) switch_instance_changes.isHover = isItemHover(/*hoverItemIndex*/ ctx[2], /*item*/ ctx[41], /*i*/ ctx[42], /*items*/ ctx[1]);
    			if (dirty[1] & /*item*/ 1024) switch_instance_changes.isSelectable = isItemSelectable(/*item*/ ctx[41]);

    			if (switch_value !== (switch_value = /*Item*/ ctx[4])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(287:8) <svelte:component             this={VirtualList}             {items}             {itemHeight}             let:item             let:i>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block$8, create_else_block$4];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*isVirtualList*/ ctx[5]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "listContainer svelte-1uyqfml");
    			attr_dev(div, "style", /*listStyle*/ ctx[14]);
    			toggle_class(div, "virtualList", /*isVirtualList*/ ctx[5]);
    			add_location(div, file$g, 280, 0, 8325);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			/*div_binding*/ ctx[32](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(window, "keydown", /*handleKeyDown*/ ctx[17], false, false, false),
    					listen_dev(window, "resize", /*computePlacement*/ ctx[18], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}

    			if (!current || dirty[0] & /*listStyle*/ 16384) {
    				attr_dev(div, "style", /*listStyle*/ ctx[14]);
    			}

    			if (!current || dirty[0] & /*isVirtualList*/ 32) {
    				toggle_class(div, "virtualList", /*isVirtualList*/ ctx[5]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    			/*div_binding*/ ctx[32](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function isItemActive(item, value, optionIdentifier) {
    	return value && value[optionIdentifier] === item[optionIdentifier];
    }

    function isItemFirst(itemIndex) {
    	return itemIndex === 0;
    }

    function isItemHover(hoverItemIndex, item, itemIndex, items) {
    	return isItemSelectable(item) && (hoverItemIndex === itemIndex || items.length === 1);
    }

    function isItemSelectable(item) {
    	return item.isGroupHeader && item.isSelectable || item.selectable || !item.hasOwnProperty('selectable'); // Default; if `selectable` was not specified, the object is selectable
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('List', slots, []);
    	const dispatch = createEventDispatcher();
    	let { container = undefined } = $$props;
    	let { VirtualList = null } = $$props;
    	let { Item: Item$1 = Item } = $$props;
    	let { isVirtualList = false } = $$props;
    	let { items = [] } = $$props;
    	let { labelIdentifier = 'label' } = $$props;

    	let { getOptionLabel = (option, filterText) => {
    		if (option) return option.isCreator
    		? `Create \"${filterText}\"`
    		: option[labelIdentifier];
    	} } = $$props;

    	let { getGroupHeaderLabel = null } = $$props;
    	let { itemHeight = 40 } = $$props;
    	let { hoverItemIndex = 0 } = $$props;
    	let { value = undefined } = $$props;
    	let { optionIdentifier = 'value' } = $$props;
    	let { hideEmptyState = false } = $$props;
    	let { noOptionsMessage = 'No options' } = $$props;
    	let { isMulti = false } = $$props;
    	let { activeItemIndex = 0 } = $$props;
    	let { filterText = '' } = $$props;
    	let { parent = null } = $$props;
    	let { listPlacement = null } = $$props;
    	let { listAutoWidth = null } = $$props;
    	let { listOffset = 5 } = $$props;
    	let isScrollingTimer = 0;
    	let isScrolling = false;
    	let prev_items;

    	onMount(() => {
    		if (items.length > 0 && !isMulti && value) {
    			const _hoverItemIndex = items.findIndex(item => item[optionIdentifier] === value[optionIdentifier]);

    			if (_hoverItemIndex) {
    				$$invalidate(2, hoverItemIndex = _hoverItemIndex);
    			}
    		}

    		scrollToActiveItem('active');

    		container.addEventListener(
    			'scroll',
    			() => {
    				clearTimeout(isScrollingTimer);

    				isScrollingTimer = setTimeout(
    					() => {
    						isScrolling = false;
    					},
    					100
    				);
    			},
    			false
    		);
    	});

    	beforeUpdate(() => {
    		if (!items) $$invalidate(1, items = []);

    		if (items !== prev_items && items.length > 0) {
    			$$invalidate(2, hoverItemIndex = 0);
    		}

    		prev_items = items;
    	});

    	function handleSelect(item) {
    		if (item.isCreator) return;
    		dispatch('itemSelected', item);
    	}

    	function handleHover(i) {
    		if (isScrolling) return;
    		$$invalidate(2, hoverItemIndex = i);
    	}

    	function handleClick(args) {
    		const { item, i, event } = args;
    		event.stopPropagation();
    		if (value && !isMulti && value[optionIdentifier] === item[optionIdentifier]) return closeList();

    		if (item.isCreator) {
    			dispatch('itemCreated', filterText);
    		} else if (isItemSelectable(item)) {
    			$$invalidate(19, activeItemIndex = i);
    			$$invalidate(2, hoverItemIndex = i);
    			handleSelect(item);
    		}
    	}

    	function closeList() {
    		dispatch('closeList');
    	}

    	async function updateHoverItem(increment) {
    		if (isVirtualList) return;
    		let isNonSelectableItem = true;

    		while (isNonSelectableItem) {
    			if (increment > 0 && hoverItemIndex === items.length - 1) {
    				$$invalidate(2, hoverItemIndex = 0);
    			} else if (increment < 0 && hoverItemIndex === 0) {
    				$$invalidate(2, hoverItemIndex = items.length - 1);
    			} else {
    				$$invalidate(2, hoverItemIndex = hoverItemIndex + increment);
    			}

    			isNonSelectableItem = !isItemSelectable(items[hoverItemIndex]);
    		}

    		await tick();
    		scrollToActiveItem('hover');
    	}

    	function handleKeyDown(e) {
    		switch (e.key) {
    			case 'Escape':
    				e.preventDefault();
    				closeList();
    				break;
    			case 'ArrowDown':
    				e.preventDefault();
    				items.length && updateHoverItem(1);
    				break;
    			case 'ArrowUp':
    				e.preventDefault();
    				items.length && updateHoverItem(-1);
    				break;
    			case 'Enter':
    				e.preventDefault();
    				if (items.length === 0) break;
    				const hoverItem = items[hoverItemIndex];
    				if (value && !isMulti && value[optionIdentifier] === hoverItem[optionIdentifier]) {
    					closeList();
    					break;
    				}
    				if (hoverItem.isCreator) {
    					dispatch('itemCreated', filterText);
    				} else {
    					$$invalidate(19, activeItemIndex = hoverItemIndex);
    					handleSelect(items[hoverItemIndex]);
    				}
    				break;
    			case 'Tab':
    				e.preventDefault();
    				if (items.length === 0) {
    					return closeList();
    				}
    				if (value && value[optionIdentifier] === items[hoverItemIndex][optionIdentifier]) return closeList();
    				$$invalidate(19, activeItemIndex = hoverItemIndex);
    				handleSelect(items[hoverItemIndex]);
    				break;
    		}
    	}

    	function scrollToActiveItem(className) {
    		if (isVirtualList || !container) return;
    		let offsetBounding;
    		const focusedElemBounding = container.querySelector(`.listItem .${className}`);

    		if (focusedElemBounding) {
    			offsetBounding = container.getBoundingClientRect().bottom - focusedElemBounding.getBoundingClientRect().bottom;
    		}

    		$$invalidate(0, container.scrollTop -= offsetBounding, container);
    	}

    	let listStyle;

    	function computePlacement() {
    		const { height, width } = parent.getBoundingClientRect();
    		$$invalidate(14, listStyle = '');
    		$$invalidate(14, listStyle += `min-width:${width}px;width:${listAutoWidth ? 'auto' : '100%'};`);

    		if (listPlacement === 'top' || listPlacement === 'auto' && isOutOfViewport(parent, container).bottom) {
    			$$invalidate(14, listStyle += `bottom:${height + listOffset}px;`);
    		} else {
    			$$invalidate(14, listStyle += `top:${height + listOffset}px;`);
    		}
    	}

    	const writable_props = [
    		'container',
    		'VirtualList',
    		'Item',
    		'isVirtualList',
    		'items',
    		'labelIdentifier',
    		'getOptionLabel',
    		'getGroupHeaderLabel',
    		'itemHeight',
    		'hoverItemIndex',
    		'value',
    		'optionIdentifier',
    		'hideEmptyState',
    		'noOptionsMessage',
    		'isMulti',
    		'activeItemIndex',
    		'filterText',
    		'parent',
    		'listPlacement',
    		'listAutoWidth',
    		'listOffset'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<List> was created with unknown prop '${key}'`);
    	});

    	const mouseover_handler = i => handleHover(i);
    	const focus_handler = i => handleHover(i);
    	const click_handler = (item, i, event) => handleClick({ item, i, event });
    	const mouseover_handler_1 = i => handleHover(i);
    	const focus_handler_1 = i => handleHover(i);
    	const click_handler_1 = (item, i, event) => handleClick({ item, i, event });

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			container = $$value;
    			$$invalidate(0, container);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('container' in $$props) $$invalidate(0, container = $$props.container);
    		if ('VirtualList' in $$props) $$invalidate(3, VirtualList = $$props.VirtualList);
    		if ('Item' in $$props) $$invalidate(4, Item$1 = $$props.Item);
    		if ('isVirtualList' in $$props) $$invalidate(5, isVirtualList = $$props.isVirtualList);
    		if ('items' in $$props) $$invalidate(1, items = $$props.items);
    		if ('labelIdentifier' in $$props) $$invalidate(20, labelIdentifier = $$props.labelIdentifier);
    		if ('getOptionLabel' in $$props) $$invalidate(6, getOptionLabel = $$props.getOptionLabel);
    		if ('getGroupHeaderLabel' in $$props) $$invalidate(7, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
    		if ('itemHeight' in $$props) $$invalidate(8, itemHeight = $$props.itemHeight);
    		if ('hoverItemIndex' in $$props) $$invalidate(2, hoverItemIndex = $$props.hoverItemIndex);
    		if ('value' in $$props) $$invalidate(9, value = $$props.value);
    		if ('optionIdentifier' in $$props) $$invalidate(10, optionIdentifier = $$props.optionIdentifier);
    		if ('hideEmptyState' in $$props) $$invalidate(11, hideEmptyState = $$props.hideEmptyState);
    		if ('noOptionsMessage' in $$props) $$invalidate(12, noOptionsMessage = $$props.noOptionsMessage);
    		if ('isMulti' in $$props) $$invalidate(21, isMulti = $$props.isMulti);
    		if ('activeItemIndex' in $$props) $$invalidate(19, activeItemIndex = $$props.activeItemIndex);
    		if ('filterText' in $$props) $$invalidate(13, filterText = $$props.filterText);
    		if ('parent' in $$props) $$invalidate(22, parent = $$props.parent);
    		if ('listPlacement' in $$props) $$invalidate(23, listPlacement = $$props.listPlacement);
    		if ('listAutoWidth' in $$props) $$invalidate(24, listAutoWidth = $$props.listAutoWidth);
    		if ('listOffset' in $$props) $$invalidate(25, listOffset = $$props.listOffset);
    	};

    	$$self.$capture_state = () => ({
    		beforeUpdate,
    		createEventDispatcher,
    		onMount,
    		tick,
    		isOutOfViewport,
    		ItemComponent: Item,
    		dispatch,
    		container,
    		VirtualList,
    		Item: Item$1,
    		isVirtualList,
    		items,
    		labelIdentifier,
    		getOptionLabel,
    		getGroupHeaderLabel,
    		itemHeight,
    		hoverItemIndex,
    		value,
    		optionIdentifier,
    		hideEmptyState,
    		noOptionsMessage,
    		isMulti,
    		activeItemIndex,
    		filterText,
    		parent,
    		listPlacement,
    		listAutoWidth,
    		listOffset,
    		isScrollingTimer,
    		isScrolling,
    		prev_items,
    		handleSelect,
    		handleHover,
    		handleClick,
    		closeList,
    		updateHoverItem,
    		handleKeyDown,
    		scrollToActiveItem,
    		isItemActive,
    		isItemFirst,
    		isItemHover,
    		isItemSelectable,
    		listStyle,
    		computePlacement
    	});

    	$$self.$inject_state = $$props => {
    		if ('container' in $$props) $$invalidate(0, container = $$props.container);
    		if ('VirtualList' in $$props) $$invalidate(3, VirtualList = $$props.VirtualList);
    		if ('Item' in $$props) $$invalidate(4, Item$1 = $$props.Item);
    		if ('isVirtualList' in $$props) $$invalidate(5, isVirtualList = $$props.isVirtualList);
    		if ('items' in $$props) $$invalidate(1, items = $$props.items);
    		if ('labelIdentifier' in $$props) $$invalidate(20, labelIdentifier = $$props.labelIdentifier);
    		if ('getOptionLabel' in $$props) $$invalidate(6, getOptionLabel = $$props.getOptionLabel);
    		if ('getGroupHeaderLabel' in $$props) $$invalidate(7, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
    		if ('itemHeight' in $$props) $$invalidate(8, itemHeight = $$props.itemHeight);
    		if ('hoverItemIndex' in $$props) $$invalidate(2, hoverItemIndex = $$props.hoverItemIndex);
    		if ('value' in $$props) $$invalidate(9, value = $$props.value);
    		if ('optionIdentifier' in $$props) $$invalidate(10, optionIdentifier = $$props.optionIdentifier);
    		if ('hideEmptyState' in $$props) $$invalidate(11, hideEmptyState = $$props.hideEmptyState);
    		if ('noOptionsMessage' in $$props) $$invalidate(12, noOptionsMessage = $$props.noOptionsMessage);
    		if ('isMulti' in $$props) $$invalidate(21, isMulti = $$props.isMulti);
    		if ('activeItemIndex' in $$props) $$invalidate(19, activeItemIndex = $$props.activeItemIndex);
    		if ('filterText' in $$props) $$invalidate(13, filterText = $$props.filterText);
    		if ('parent' in $$props) $$invalidate(22, parent = $$props.parent);
    		if ('listPlacement' in $$props) $$invalidate(23, listPlacement = $$props.listPlacement);
    		if ('listAutoWidth' in $$props) $$invalidate(24, listAutoWidth = $$props.listAutoWidth);
    		if ('listOffset' in $$props) $$invalidate(25, listOffset = $$props.listOffset);
    		if ('isScrollingTimer' in $$props) isScrollingTimer = $$props.isScrollingTimer;
    		if ('isScrolling' in $$props) isScrolling = $$props.isScrolling;
    		if ('prev_items' in $$props) prev_items = $$props.prev_items;
    		if ('listStyle' in $$props) $$invalidate(14, listStyle = $$props.listStyle);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*parent, container*/ 4194305) {
    			{
    				if (parent && container) computePlacement();
    			}
    		}
    	};

    	return [
    		container,
    		items,
    		hoverItemIndex,
    		VirtualList,
    		Item$1,
    		isVirtualList,
    		getOptionLabel,
    		getGroupHeaderLabel,
    		itemHeight,
    		value,
    		optionIdentifier,
    		hideEmptyState,
    		noOptionsMessage,
    		filterText,
    		listStyle,
    		handleHover,
    		handleClick,
    		handleKeyDown,
    		computePlacement,
    		activeItemIndex,
    		labelIdentifier,
    		isMulti,
    		parent,
    		listPlacement,
    		listAutoWidth,
    		listOffset,
    		mouseover_handler,
    		focus_handler,
    		click_handler,
    		mouseover_handler_1,
    		focus_handler_1,
    		click_handler_1,
    		div_binding
    	];
    }

    class List extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$h,
    			create_fragment$h,
    			safe_not_equal,
    			{
    				container: 0,
    				VirtualList: 3,
    				Item: 4,
    				isVirtualList: 5,
    				items: 1,
    				labelIdentifier: 20,
    				getOptionLabel: 6,
    				getGroupHeaderLabel: 7,
    				itemHeight: 8,
    				hoverItemIndex: 2,
    				value: 9,
    				optionIdentifier: 10,
    				hideEmptyState: 11,
    				noOptionsMessage: 12,
    				isMulti: 21,
    				activeItemIndex: 19,
    				filterText: 13,
    				parent: 22,
    				listPlacement: 23,
    				listAutoWidth: 24,
    				listOffset: 25
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "List",
    			options,
    			id: create_fragment$h.name
    		});
    	}

    	get container() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set container(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get VirtualList() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set VirtualList(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Item() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Item(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isVirtualList() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isVirtualList(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get items() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelIdentifier() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelIdentifier(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getOptionLabel() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getOptionLabel(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getGroupHeaderLabel() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getGroupHeaderLabel(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get itemHeight() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set itemHeight(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hoverItemIndex() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hoverItemIndex(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get optionIdentifier() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set optionIdentifier(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideEmptyState() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideEmptyState(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noOptionsMessage() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noOptionsMessage(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isMulti() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isMulti(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activeItemIndex() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set activeItemIndex(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filterText() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filterText(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get parent() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set parent(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get listPlacement() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set listPlacement(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get listAutoWidth() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set listAutoWidth(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get listOffset() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set listOffset(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-select\src\Selection.svelte generated by Svelte v3.50.1 */

    const file$f = "node_modules\\svelte-select\\src\\Selection.svelte";

    function create_fragment$g(ctx) {
    	let div;
    	let raw_value = /*getSelectionLabel*/ ctx[0](/*item*/ ctx[1]) + "";

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "selection svelte-pu1q1n");
    			add_location(div, file$f, 13, 0, 230);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			div.innerHTML = raw_value;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*getSelectionLabel, item*/ 3 && raw_value !== (raw_value = /*getSelectionLabel*/ ctx[0](/*item*/ ctx[1]) + "")) div.innerHTML = raw_value;		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Selection', slots, []);
    	let { getSelectionLabel = undefined } = $$props;
    	let { item = undefined } = $$props;
    	const writable_props = ['getSelectionLabel', 'item'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Selection> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('getSelectionLabel' in $$props) $$invalidate(0, getSelectionLabel = $$props.getSelectionLabel);
    		if ('item' in $$props) $$invalidate(1, item = $$props.item);
    	};

    	$$self.$capture_state = () => ({ getSelectionLabel, item });

    	$$self.$inject_state = $$props => {
    		if ('getSelectionLabel' in $$props) $$invalidate(0, getSelectionLabel = $$props.getSelectionLabel);
    		if ('item' in $$props) $$invalidate(1, item = $$props.item);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [getSelectionLabel, item];
    }

    class Selection extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, { getSelectionLabel: 0, item: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Selection",
    			options,
    			id: create_fragment$g.name
    		});
    	}

    	get getSelectionLabel() {
    		throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getSelectionLabel(value) {
    		throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get item() {
    		throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-select\src\MultiSelection.svelte generated by Svelte v3.50.1 */
    const file$e = "node_modules\\svelte-select\\src\\MultiSelection.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	child_ctx[11] = i;
    	return child_ctx;
    }

    // (87:8) {#if !isDisabled && !multiFullItemClearable}
    function create_if_block$7(ctx) {
    	let div;
    	let svg;
    	let path;
    	let mounted;
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[6](/*i*/ ctx[11], ...args);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124 l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z");
    			add_location(path, file$e, 97, 20, 3027);
    			attr_dev(svg, "width", "100%");
    			attr_dev(svg, "height", "100%");
    			attr_dev(svg, "viewBox", "-2 -2 50 50");
    			attr_dev(svg, "focusable", "false");
    			attr_dev(svg, "aria-hidden", "true");
    			attr_dev(svg, "role", "presentation");
    			attr_dev(svg, "class", "svelte-liu9pa");
    			add_location(svg, file$e, 90, 16, 2775);
    			attr_dev(div, "class", "multiSelectItem_clear svelte-liu9pa");
    			add_location(div, file$e, 87, 12, 2647);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, path);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(87:8) {#if !isDisabled && !multiFullItemClearable}",
    		ctx
    	});

    	return block;
    }

    // (77:0) {#each value as item, i}
    function create_each_block$6(ctx) {
    	let div1;
    	let div0;
    	let raw_value = /*getSelectionLabel*/ ctx[4](/*item*/ ctx[9]) + "";
    	let t0;
    	let t1;
    	let div1_class_value;
    	let mounted;
    	let dispose;
    	let if_block = !/*isDisabled*/ ctx[2] && !/*multiFullItemClearable*/ ctx[3] && create_if_block$7(ctx);

    	function click_handler_1(...args) {
    		return /*click_handler_1*/ ctx[7](/*i*/ ctx[11], ...args);
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			attr_dev(div0, "class", "multiSelectItem_label svelte-liu9pa");
    			add_location(div0, file$e, 83, 8, 2487);
    			attr_dev(div1, "class", div1_class_value = "multiSelectItem " + (/*activeValue*/ ctx[1] === /*i*/ ctx[11] ? 'active' : '') + " " + (/*isDisabled*/ ctx[2] ? 'disabled' : '') + " svelte-liu9pa");
    			add_location(div1, file$e, 77, 4, 2256);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			div0.innerHTML = raw_value;
    			append_dev(div1, t0);
    			if (if_block) if_block.m(div1, null);
    			append_dev(div1, t1);

    			if (!mounted) {
    				dispose = listen_dev(div1, "click", click_handler_1, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*getSelectionLabel, value*/ 17 && raw_value !== (raw_value = /*getSelectionLabel*/ ctx[4](/*item*/ ctx[9]) + "")) div0.innerHTML = raw_value;
    			if (!/*isDisabled*/ ctx[2] && !/*multiFullItemClearable*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$7(ctx);
    					if_block.c();
    					if_block.m(div1, t1);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*activeValue, isDisabled*/ 6 && div1_class_value !== (div1_class_value = "multiSelectItem " + (/*activeValue*/ ctx[1] === /*i*/ ctx[11] ? 'active' : '') + " " + (/*isDisabled*/ ctx[2] ? 'disabled' : '') + " svelte-liu9pa")) {
    				attr_dev(div1, "class", div1_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(77:0) {#each value as item, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let each_1_anchor;
    	let each_value = /*value*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*activeValue, isDisabled, multiFullItemClearable, handleClear, getSelectionLabel, value*/ 63) {
    				each_value = /*value*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MultiSelection', slots, []);
    	const dispatch = createEventDispatcher();
    	let { value = [] } = $$props;
    	let { activeValue = undefined } = $$props;
    	let { isDisabled = false } = $$props;
    	let { multiFullItemClearable = false } = $$props;
    	let { getSelectionLabel = undefined } = $$props;

    	function handleClear(i, event) {
    		event.stopPropagation();
    		dispatch('multiItemClear', { i });
    	}

    	const writable_props = [
    		'value',
    		'activeValue',
    		'isDisabled',
    		'multiFullItemClearable',
    		'getSelectionLabel'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MultiSelection> was created with unknown prop '${key}'`);
    	});

    	const click_handler = (i, event) => handleClear(i, event);
    	const click_handler_1 = (i, event) => multiFullItemClearable ? handleClear(i, event) : {};

    	$$self.$$set = $$props => {
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    		if ('activeValue' in $$props) $$invalidate(1, activeValue = $$props.activeValue);
    		if ('isDisabled' in $$props) $$invalidate(2, isDisabled = $$props.isDisabled);
    		if ('multiFullItemClearable' in $$props) $$invalidate(3, multiFullItemClearable = $$props.multiFullItemClearable);
    		if ('getSelectionLabel' in $$props) $$invalidate(4, getSelectionLabel = $$props.getSelectionLabel);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		dispatch,
    		value,
    		activeValue,
    		isDisabled,
    		multiFullItemClearable,
    		getSelectionLabel,
    		handleClear
    	});

    	$$self.$inject_state = $$props => {
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    		if ('activeValue' in $$props) $$invalidate(1, activeValue = $$props.activeValue);
    		if ('isDisabled' in $$props) $$invalidate(2, isDisabled = $$props.isDisabled);
    		if ('multiFullItemClearable' in $$props) $$invalidate(3, multiFullItemClearable = $$props.multiFullItemClearable);
    		if ('getSelectionLabel' in $$props) $$invalidate(4, getSelectionLabel = $$props.getSelectionLabel);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		value,
    		activeValue,
    		isDisabled,
    		multiFullItemClearable,
    		getSelectionLabel,
    		handleClear,
    		click_handler,
    		click_handler_1
    	];
    }

    class MultiSelection extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$f, create_fragment$f, safe_not_equal, {
    			value: 0,
    			activeValue: 1,
    			isDisabled: 2,
    			multiFullItemClearable: 3,
    			getSelectionLabel: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MultiSelection",
    			options,
    			id: create_fragment$f.name
    		});
    	}

    	get value() {
    		throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activeValue() {
    		throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set activeValue(value) {
    		throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isDisabled() {
    		throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isDisabled(value) {
    		throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get multiFullItemClearable() {
    		throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set multiFullItemClearable(value) {
    		throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getSelectionLabel() {
    		throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getSelectionLabel(value) {
    		throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-select\src\VirtualList.svelte generated by Svelte v3.50.1 */
    const file$d = "node_modules\\svelte-select\\src\\VirtualList.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[23] = list[i];
    	return child_ctx;
    }

    const get_default_slot_changes = dirty => ({
    	item: dirty & /*visible*/ 32,
    	i: dirty & /*visible*/ 32,
    	hoverItemIndex: dirty & /*hoverItemIndex*/ 2
    });

    const get_default_slot_context = ctx => ({
    	item: /*row*/ ctx[23].data,
    	i: /*row*/ ctx[23].index,
    	hoverItemIndex: /*hoverItemIndex*/ ctx[1]
    });

    // (154:69) Missing template
    function fallback_block(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Missing template");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block.name,
    		type: "fallback",
    		source: "(154:69) Missing template",
    		ctx
    	});

    	return block;
    }

    // (152:8) {#each visible as row (row.index)}
    function create_each_block$5(key_1, ctx) {
    	let svelte_virtual_list_row;
    	let t;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[15].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], get_default_slot_context);
    	const default_slot_or_fallback = default_slot || fallback_block(ctx);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			svelte_virtual_list_row = element("svelte-virtual-list-row");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			t = space();
    			set_custom_element_data(svelte_virtual_list_row, "class", "svelte-g2cagw");
    			add_location(svelte_virtual_list_row, file$d, 152, 12, 3778);
    			this.first = svelte_virtual_list_row;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svelte_virtual_list_row, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(svelte_virtual_list_row, null);
    			}

    			append_dev(svelte_virtual_list_row, t);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope, visible, hoverItemIndex*/ 16418)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[14],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[14])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, get_default_slot_changes),
    						get_default_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svelte_virtual_list_row);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(152:8) {#each visible as row (row.index)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let svelte_virtual_list_viewport;
    	let svelte_virtual_list_contents;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let svelte_virtual_list_viewport_resize_listener;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*visible*/ ctx[5];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*row*/ ctx[23].index;
    	validate_each_keys(ctx, each_value, get_each_context$5, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$5(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$5(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			svelte_virtual_list_viewport = element("svelte-virtual-list-viewport");
    			svelte_virtual_list_contents = element("svelte-virtual-list-contents");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(svelte_virtual_list_contents, "padding-top", /*top*/ ctx[6] + "px");
    			set_style(svelte_virtual_list_contents, "padding-bottom", /*bottom*/ ctx[7] + "px");
    			set_custom_element_data(svelte_virtual_list_contents, "class", "svelte-g2cagw");
    			add_location(svelte_virtual_list_contents, file$d, 148, 4, 3597);
    			set_style(svelte_virtual_list_viewport, "height", /*height*/ ctx[0]);
    			set_custom_element_data(svelte_virtual_list_viewport, "class", "svelte-g2cagw");
    			add_render_callback(() => /*svelte_virtual_list_viewport_elementresize_handler*/ ctx[18].call(svelte_virtual_list_viewport));
    			add_location(svelte_virtual_list_viewport, file$d, 143, 0, 3437);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svelte_virtual_list_viewport, anchor);
    			append_dev(svelte_virtual_list_viewport, svelte_virtual_list_contents);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(svelte_virtual_list_contents, null);
    			}

    			/*svelte_virtual_list_contents_binding*/ ctx[16](svelte_virtual_list_contents);
    			/*svelte_virtual_list_viewport_binding*/ ctx[17](svelte_virtual_list_viewport);
    			svelte_virtual_list_viewport_resize_listener = add_resize_listener(svelte_virtual_list_viewport, /*svelte_virtual_list_viewport_elementresize_handler*/ ctx[18].bind(svelte_virtual_list_viewport));
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(svelte_virtual_list_viewport, "scroll", /*handle_scroll*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$$scope, visible, hoverItemIndex*/ 16418) {
    				each_value = /*visible*/ ctx[5];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$5, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, svelte_virtual_list_contents, outro_and_destroy_block, create_each_block$5, null, get_each_context$5);
    				check_outros();
    			}

    			if (!current || dirty & /*top*/ 64) {
    				set_style(svelte_virtual_list_contents, "padding-top", /*top*/ ctx[6] + "px");
    			}

    			if (!current || dirty & /*bottom*/ 128) {
    				set_style(svelte_virtual_list_contents, "padding-bottom", /*bottom*/ ctx[7] + "px");
    			}

    			if (!current || dirty & /*height*/ 1) {
    				set_style(svelte_virtual_list_viewport, "height", /*height*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svelte_virtual_list_viewport);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			/*svelte_virtual_list_contents_binding*/ ctx[16](null);
    			/*svelte_virtual_list_viewport_binding*/ ctx[17](null);
    			svelte_virtual_list_viewport_resize_listener();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('VirtualList', slots, ['default']);
    	let { items = undefined } = $$props;
    	let { height = '100%' } = $$props;
    	let { itemHeight = 40 } = $$props;
    	let { hoverItemIndex = 0 } = $$props;
    	let { start = 0 } = $$props;
    	let { end = 0 } = $$props;
    	let height_map = [];
    	let rows;
    	let viewport;
    	let contents;
    	let viewport_height = 0;
    	let visible;
    	let mounted;
    	let top = 0;
    	let bottom = 0;
    	let average_height;

    	async function refresh(items, viewport_height, itemHeight) {
    		const { scrollTop } = viewport;
    		await tick();
    		let content_height = top - scrollTop;
    		let i = start;

    		while (content_height < viewport_height && i < items.length) {
    			let row = rows[i - start];

    			if (!row) {
    				$$invalidate(10, end = i + 1);
    				await tick();
    				row = rows[i - start];
    			}

    			const row_height = height_map[i] = itemHeight || row.offsetHeight;
    			content_height += row_height;
    			i += 1;
    		}

    		$$invalidate(10, end = i);
    		const remaining = items.length - end;
    		average_height = (top + content_height) / end;
    		$$invalidate(7, bottom = remaining * average_height);
    		height_map.length = items.length;
    		if (viewport) $$invalidate(3, viewport.scrollTop = 0, viewport);
    	}

    	async function handle_scroll() {
    		const { scrollTop } = viewport;
    		const old_start = start;

    		for (let v = 0; v < rows.length; v += 1) {
    			height_map[start + v] = itemHeight || rows[v].offsetHeight;
    		}

    		let i = 0;
    		let y = 0;

    		while (i < items.length) {
    			const row_height = height_map[i] || average_height;

    			if (y + row_height > scrollTop) {
    				$$invalidate(9, start = i);
    				$$invalidate(6, top = y);
    				break;
    			}

    			y += row_height;
    			i += 1;
    		}

    		while (i < items.length) {
    			y += height_map[i] || average_height;
    			i += 1;
    			if (y > scrollTop + viewport_height) break;
    		}

    		$$invalidate(10, end = i);
    		const remaining = items.length - end;
    		average_height = y / end;
    		while (i < items.length) height_map[i++] = average_height;
    		$$invalidate(7, bottom = remaining * average_height);

    		if (start < old_start) {
    			await tick();
    			let expected_height = 0;
    			let actual_height = 0;

    			for (let i = start; i < old_start; i += 1) {
    				if (rows[i - start]) {
    					expected_height += height_map[i];
    					actual_height += itemHeight || rows[i - start].offsetHeight;
    				}
    			}

    			const d = actual_height - expected_height;
    			viewport.scrollTo(0, scrollTop + d);
    		}
    	}

    	onMount(() => {
    		rows = contents.getElementsByTagName('svelte-virtual-list-row');
    		$$invalidate(13, mounted = true);
    	});

    	const writable_props = ['items', 'height', 'itemHeight', 'hoverItemIndex', 'start', 'end'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<VirtualList> was created with unknown prop '${key}'`);
    	});

    	function svelte_virtual_list_contents_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			contents = $$value;
    			$$invalidate(4, contents);
    		});
    	}

    	function svelte_virtual_list_viewport_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			viewport = $$value;
    			$$invalidate(3, viewport);
    		});
    	}

    	function svelte_virtual_list_viewport_elementresize_handler() {
    		viewport_height = this.offsetHeight;
    		$$invalidate(2, viewport_height);
    	}

    	$$self.$$set = $$props => {
    		if ('items' in $$props) $$invalidate(11, items = $$props.items);
    		if ('height' in $$props) $$invalidate(0, height = $$props.height);
    		if ('itemHeight' in $$props) $$invalidate(12, itemHeight = $$props.itemHeight);
    		if ('hoverItemIndex' in $$props) $$invalidate(1, hoverItemIndex = $$props.hoverItemIndex);
    		if ('start' in $$props) $$invalidate(9, start = $$props.start);
    		if ('end' in $$props) $$invalidate(10, end = $$props.end);
    		if ('$$scope' in $$props) $$invalidate(14, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		tick,
    		items,
    		height,
    		itemHeight,
    		hoverItemIndex,
    		start,
    		end,
    		height_map,
    		rows,
    		viewport,
    		contents,
    		viewport_height,
    		visible,
    		mounted,
    		top,
    		bottom,
    		average_height,
    		refresh,
    		handle_scroll
    	});

    	$$self.$inject_state = $$props => {
    		if ('items' in $$props) $$invalidate(11, items = $$props.items);
    		if ('height' in $$props) $$invalidate(0, height = $$props.height);
    		if ('itemHeight' in $$props) $$invalidate(12, itemHeight = $$props.itemHeight);
    		if ('hoverItemIndex' in $$props) $$invalidate(1, hoverItemIndex = $$props.hoverItemIndex);
    		if ('start' in $$props) $$invalidate(9, start = $$props.start);
    		if ('end' in $$props) $$invalidate(10, end = $$props.end);
    		if ('height_map' in $$props) height_map = $$props.height_map;
    		if ('rows' in $$props) rows = $$props.rows;
    		if ('viewport' in $$props) $$invalidate(3, viewport = $$props.viewport);
    		if ('contents' in $$props) $$invalidate(4, contents = $$props.contents);
    		if ('viewport_height' in $$props) $$invalidate(2, viewport_height = $$props.viewport_height);
    		if ('visible' in $$props) $$invalidate(5, visible = $$props.visible);
    		if ('mounted' in $$props) $$invalidate(13, mounted = $$props.mounted);
    		if ('top' in $$props) $$invalidate(6, top = $$props.top);
    		if ('bottom' in $$props) $$invalidate(7, bottom = $$props.bottom);
    		if ('average_height' in $$props) average_height = $$props.average_height;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*items, start, end*/ 3584) {
    			$$invalidate(5, visible = items.slice(start, end).map((data, i) => {
    				return { index: i + start, data };
    			}));
    		}

    		if ($$self.$$.dirty & /*mounted, items, viewport_height, itemHeight*/ 14340) {
    			if (mounted) refresh(items, viewport_height, itemHeight);
    		}
    	};

    	return [
    		height,
    		hoverItemIndex,
    		viewport_height,
    		viewport,
    		contents,
    		visible,
    		top,
    		bottom,
    		handle_scroll,
    		start,
    		end,
    		items,
    		itemHeight,
    		mounted,
    		$$scope,
    		slots,
    		svelte_virtual_list_contents_binding,
    		svelte_virtual_list_viewport_binding,
    		svelte_virtual_list_viewport_elementresize_handler
    	];
    }

    class VirtualList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$e, create_fragment$e, safe_not_equal, {
    			items: 11,
    			height: 0,
    			itemHeight: 12,
    			hoverItemIndex: 1,
    			start: 9,
    			end: 10
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "VirtualList",
    			options,
    			id: create_fragment$e.name
    		});
    	}

    	get items() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get itemHeight() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set itemHeight(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hoverItemIndex() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hoverItemIndex(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get start() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set start(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get end() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set end(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-select\src\ClearIcon.svelte generated by Svelte v3.50.1 */

    const file$c = "node_modules\\svelte-select\\src\\ClearIcon.svelte";

    function create_fragment$d(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "fill", "currentColor");
    			attr_dev(path, "d", "M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124\n    l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z");
    			add_location(path, file$c, 8, 4, 141);
    			attr_dev(svg, "width", "100%");
    			attr_dev(svg, "height", "100%");
    			attr_dev(svg, "viewBox", "-2 -2 50 50");
    			attr_dev(svg, "focusable", "false");
    			attr_dev(svg, "aria-hidden", "true");
    			attr_dev(svg, "role", "presentation");
    			add_location(svg, file$c, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ClearIcon', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ClearIcon> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class ClearIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ClearIcon",
    			options,
    			id: create_fragment$d.name
    		});
    	}
    }

    function debounce(func, wait, immediate) {
        let timeout;

        return function executedFunction() {
            let context = this;
            let args = arguments;

            let later = function () {
                timeout = null;
                if (!immediate) func.apply(context, args);
            };

            let callNow = immediate && !timeout;

            clearTimeout(timeout);

            timeout = setTimeout(later, wait);

            if (callNow) func.apply(context, args);
        };
    }

    /* node_modules\svelte-select\src\Select.svelte generated by Svelte v3.50.1 */

    const { Object: Object_1, console: console_1$1 } = globals;
    const file$b = "node_modules\\svelte-select\\src\\Select.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[103] = list[i];
    	return child_ctx;
    }

    // (876:8) {#if isFocused}
    function create_if_block_10(ctx) {
    	let span0;
    	let t0;
    	let t1;
    	let span1;
    	let t2;

    	const block = {
    		c: function create() {
    			span0 = element("span");
    			t0 = text(/*ariaSelection*/ ctx[33]);
    			t1 = space();
    			span1 = element("span");
    			t2 = text(/*ariaContext*/ ctx[32]);
    			attr_dev(span0, "id", "aria-selection");
    			add_location(span0, file$b, 876, 12, 23842);
    			attr_dev(span1, "id", "aria-context");
    			add_location(span1, file$b, 877, 12, 23903);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span0, anchor);
    			append_dev(span0, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, span1, anchor);
    			append_dev(span1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[1] & /*ariaSelection*/ 4) set_data_dev(t0, /*ariaSelection*/ ctx[33]);
    			if (dirty[1] & /*ariaContext*/ 2) set_data_dev(t2, /*ariaContext*/ ctx[32]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(span1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10.name,
    		type: "if",
    		source: "(876:8) {#if isFocused}",
    		ctx
    	});

    	return block;
    }

    // (884:4) {#if Icon}
    function create_if_block_9(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*iconProps*/ ctx[18]];
    	var switch_value = /*Icon*/ ctx[17];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty[0] & /*iconProps*/ 262144)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*iconProps*/ ctx[18])])
    			: {};

    			if (switch_value !== (switch_value = /*Icon*/ ctx[17])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9.name,
    		type: "if",
    		source: "(884:4) {#if Icon}",
    		ctx
    	});

    	return block;
    }

    // (888:4) {#if showMultiSelect}
    function create_if_block_8(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*MultiSelection*/ ctx[26];

    	function switch_props(ctx) {
    		return {
    			props: {
    				value: /*value*/ ctx[2],
    				getSelectionLabel: /*getSelectionLabel*/ ctx[12],
    				activeValue: /*activeValue*/ ctx[30],
    				isDisabled: /*isDisabled*/ ctx[9],
    				multiFullItemClearable: /*multiFullItemClearable*/ ctx[8]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    		switch_instance.$on("multiItemClear", /*handleMultiItemClear*/ ctx[38]);
    		switch_instance.$on("focus", /*handleFocus*/ ctx[40]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty[0] & /*value*/ 4) switch_instance_changes.value = /*value*/ ctx[2];
    			if (dirty[0] & /*getSelectionLabel*/ 4096) switch_instance_changes.getSelectionLabel = /*getSelectionLabel*/ ctx[12];
    			if (dirty[0] & /*activeValue*/ 1073741824) switch_instance_changes.activeValue = /*activeValue*/ ctx[30];
    			if (dirty[0] & /*isDisabled*/ 512) switch_instance_changes.isDisabled = /*isDisabled*/ ctx[9];
    			if (dirty[0] & /*multiFullItemClearable*/ 256) switch_instance_changes.multiFullItemClearable = /*multiFullItemClearable*/ ctx[8];

    			if (switch_value !== (switch_value = /*MultiSelection*/ ctx[26])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					switch_instance.$on("multiItemClear", /*handleMultiItemClear*/ ctx[38]);
    					switch_instance.$on("focus", /*handleFocus*/ ctx[40]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(888:4) {#if showMultiSelect}",
    		ctx
    	});

    	return block;
    }

    // (910:4) {#if !isMulti && showSelectedItem}
    function create_if_block_7(ctx) {
    	let div;
    	let switch_instance;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*Selection*/ ctx[25];

    	function switch_props(ctx) {
    		return {
    			props: {
    				item: /*value*/ ctx[2],
    				getSelectionLabel: /*getSelectionLabel*/ ctx[12]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(div, "class", "selectedItem svelte-17l1npl");
    			add_location(div, file$b, 910, 8, 24725);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "focus", /*handleFocus*/ ctx[40], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty[0] & /*value*/ 4) switch_instance_changes.item = /*value*/ ctx[2];
    			if (dirty[0] & /*getSelectionLabel*/ 4096) switch_instance_changes.getSelectionLabel = /*getSelectionLabel*/ ctx[12];

    			if (switch_value !== (switch_value = /*Selection*/ ctx[25])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(910:4) {#if !isMulti && showSelectedItem}",
    		ctx
    	});

    	return block;
    }

    // (919:4) {#if showClearIcon}
    function create_if_block_6(ctx) {
    	let div;
    	let switch_instance;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*ClearIcon*/ ctx[23];

    	function switch_props(ctx) {
    		return { $$inline: true };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(div, "class", "clearSelect svelte-17l1npl");
    			attr_dev(div, "aria-hidden", "true");
    			add_location(div, file$b, 919, 8, 24964);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", prevent_default(/*handleClear*/ ctx[27]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (switch_value !== (switch_value = /*ClearIcon*/ ctx[23])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(919:4) {#if showClearIcon}",
    		ctx
    	});

    	return block;
    }

    // (928:4) {#if !showClearIcon && (showIndicator || (showChevron && !value) || (!isSearchable && !isDisabled && !isWaiting && ((showSelectedItem && !isClearable) || !showSelectedItem)))}
    function create_if_block_4$1(ctx) {
    	let div;

    	function select_block_type(ctx, dirty) {
    		if (/*indicatorSvg*/ ctx[22]) return create_if_block_5$1;
    		return create_else_block$3;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "indicator svelte-17l1npl");
    			attr_dev(div, "aria-hidden", "true");
    			add_location(div, file$b, 928, 8, 25347);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(928:4) {#if !showClearIcon && (showIndicator || (showChevron && !value) || (!isSearchable && !isDisabled && !isWaiting && ((showSelectedItem && !isClearable) || !showSelectedItem)))}",
    		ctx
    	});

    	return block;
    }

    // (932:12) {:else}
    function create_else_block$3(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747\n          3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0\n          1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502\n          0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0\n          0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z");
    			add_location(path, file$b, 938, 20, 25704);
    			attr_dev(svg, "width", "100%");
    			attr_dev(svg, "height", "100%");
    			attr_dev(svg, "viewBox", "0 0 20 20");
    			attr_dev(svg, "focusable", "false");
    			attr_dev(svg, "aria-hidden", "true");
    			attr_dev(svg, "class", "svelte-17l1npl");
    			add_location(svg, file$b, 932, 16, 25494);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(932:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (930:12) {#if indicatorSvg}
    function create_if_block_5$1(ctx) {
    	let html_tag;
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag(false);
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(/*indicatorSvg*/ ctx[22], target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*indicatorSvg*/ 4194304) html_tag.p(/*indicatorSvg*/ ctx[22]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(930:12) {#if indicatorSvg}",
    		ctx
    	});

    	return block;
    }

    // (950:4) {#if isWaiting}
    function create_if_block_3$1(ctx) {
    	let div;
    	let svg;
    	let circle;

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			circle = svg_element("circle");
    			attr_dev(circle, "class", "spinner_path svelte-17l1npl");
    			attr_dev(circle, "cx", "50");
    			attr_dev(circle, "cy", "50");
    			attr_dev(circle, "r", "20");
    			attr_dev(circle, "fill", "none");
    			attr_dev(circle, "stroke", "currentColor");
    			attr_dev(circle, "stroke-width", "5");
    			attr_dev(circle, "stroke-miterlimit", "10");
    			add_location(circle, file$b, 952, 16, 26253);
    			attr_dev(svg, "class", "spinner_icon svelte-17l1npl");
    			attr_dev(svg, "viewBox", "25 25 50 50");
    			add_location(svg, file$b, 951, 12, 26188);
    			attr_dev(div, "class", "spinner svelte-17l1npl");
    			add_location(div, file$b, 950, 8, 26154);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, circle);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(950:4) {#if isWaiting}",
    		ctx
    	});

    	return block;
    }

    // (966:4) {#if listOpen}
    function create_if_block_2$2(ctx) {
    	let switch_instance;
    	let updating_hoverItemIndex;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*listProps*/ ctx[34]];

    	function switch_instance_hoverItemIndex_binding(value) {
    		/*switch_instance_hoverItemIndex_binding*/ ctx[84](value);
    	}

    	var switch_value = /*List*/ ctx[24];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		if (/*hoverItemIndex*/ ctx[28] !== void 0) {
    			switch_instance_props.hoverItemIndex = /*hoverItemIndex*/ ctx[28];
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    		binding_callbacks.push(() => bind(switch_instance, 'hoverItemIndex', switch_instance_hoverItemIndex_binding));
    		switch_instance.$on("itemSelected", /*itemSelected*/ ctx[43]);
    		switch_instance.$on("itemCreated", /*itemCreated*/ ctx[44]);
    		switch_instance.$on("closeList", /*closeList*/ ctx[45]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty[1] & /*listProps*/ 8)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*listProps*/ ctx[34])])
    			: {};

    			if (!updating_hoverItemIndex && dirty[0] & /*hoverItemIndex*/ 268435456) {
    				updating_hoverItemIndex = true;
    				switch_instance_changes.hoverItemIndex = /*hoverItemIndex*/ ctx[28];
    				add_flush_callback(() => updating_hoverItemIndex = false);
    			}

    			if (switch_value !== (switch_value = /*List*/ ctx[24])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					binding_callbacks.push(() => bind(switch_instance, 'hoverItemIndex', switch_instance_hoverItemIndex_binding));
    					switch_instance.$on("itemSelected", /*itemSelected*/ ctx[43]);
    					switch_instance.$on("itemCreated", /*itemCreated*/ ctx[44]);
    					switch_instance.$on("closeList", /*closeList*/ ctx[45]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(966:4) {#if listOpen}",
    		ctx
    	});

    	return block;
    }

    // (976:4) {#if !isMulti || (isMulti && !showMultiSelect)}
    function create_if_block_1$5(ctx) {
    	let input_1;
    	let input_1_name_value;
    	let input_1_value_value;

    	const block = {
    		c: function create() {
    			input_1 = element("input");
    			attr_dev(input_1, "name", input_1_name_value = /*inputAttributes*/ ctx[16].name);
    			attr_dev(input_1, "type", "hidden");

    			input_1.value = input_1_value_value = /*value*/ ctx[2]
    			? /*getSelectionLabel*/ ctx[12](/*value*/ ctx[2])
    			: null;

    			attr_dev(input_1, "class", "svelte-17l1npl");
    			add_location(input_1, file$b, 976, 8, 26910);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input_1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*inputAttributes*/ 65536 && input_1_name_value !== (input_1_name_value = /*inputAttributes*/ ctx[16].name)) {
    				attr_dev(input_1, "name", input_1_name_value);
    			}

    			if (dirty[0] & /*value, getSelectionLabel*/ 4100 && input_1_value_value !== (input_1_value_value = /*value*/ ctx[2]
    			? /*getSelectionLabel*/ ctx[12](/*value*/ ctx[2])
    			: null)) {
    				prop_dev(input_1, "value", input_1_value_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(976:4) {#if !isMulti || (isMulti && !showMultiSelect)}",
    		ctx
    	});

    	return block;
    }

    // (983:4) {#if isMulti && showMultiSelect}
    function create_if_block$6(ctx) {
    	let each_1_anchor;
    	let each_value = /*value*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*inputAttributes, value, getSelectionLabel*/ 69636) {
    				each_value = /*value*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(983:4) {#if isMulti && showMultiSelect}",
    		ctx
    	});

    	return block;
    }

    // (984:8) {#each value as item}
    function create_each_block$4(ctx) {
    	let input_1;
    	let input_1_name_value;
    	let input_1_value_value;

    	const block = {
    		c: function create() {
    			input_1 = element("input");
    			attr_dev(input_1, "name", input_1_name_value = /*inputAttributes*/ ctx[16].name);
    			attr_dev(input_1, "type", "hidden");

    			input_1.value = input_1_value_value = /*item*/ ctx[103]
    			? /*getSelectionLabel*/ ctx[12](/*item*/ ctx[103])
    			: null;

    			attr_dev(input_1, "class", "svelte-17l1npl");
    			add_location(input_1, file$b, 984, 12, 27136);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input_1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*inputAttributes*/ 65536 && input_1_name_value !== (input_1_name_value = /*inputAttributes*/ ctx[16].name)) {
    				attr_dev(input_1, "name", input_1_name_value);
    			}

    			if (dirty[0] & /*value, getSelectionLabel*/ 4100 && input_1_value_value !== (input_1_value_value = /*item*/ ctx[103]
    			? /*getSelectionLabel*/ ctx[12](/*item*/ ctx[103])
    			: null)) {
    				prop_dev(input_1, "value", input_1_value_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(984:8) {#each value as item}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let div;
    	let span;
    	let t0;
    	let t1;
    	let t2;
    	let input_1;
    	let input_1_readonly_value;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let t9;
    	let div_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*isFocused*/ ctx[1] && create_if_block_10(ctx);
    	let if_block1 = /*Icon*/ ctx[17] && create_if_block_9(ctx);
    	let if_block2 = /*showMultiSelect*/ ctx[35] && create_if_block_8(ctx);

    	let input_1_levels = [
    		{
    			readOnly: input_1_readonly_value = !/*isSearchable*/ ctx[13]
    		},
    		/*_inputAttributes*/ ctx[31],
    		{ placeholder: /*placeholderText*/ ctx[36] },
    		{ style: /*inputStyles*/ ctx[14] },
    		{ disabled: /*isDisabled*/ ctx[9] }
    	];

    	let input_1_data = {};

    	for (let i = 0; i < input_1_levels.length; i += 1) {
    		input_1_data = assign(input_1_data, input_1_levels[i]);
    	}

    	let if_block3 = !/*isMulti*/ ctx[7] && /*showSelectedItem*/ ctx[29] && create_if_block_7(ctx);
    	let if_block4 = /*showClearIcon*/ ctx[37] && create_if_block_6(ctx);
    	let if_block5 = !/*showClearIcon*/ ctx[37] && (/*showIndicator*/ ctx[20] || /*showChevron*/ ctx[19] && !/*value*/ ctx[2] || !/*isSearchable*/ ctx[13] && !/*isDisabled*/ ctx[9] && !/*isWaiting*/ ctx[4] && (/*showSelectedItem*/ ctx[29] && !/*isClearable*/ ctx[15] || !/*showSelectedItem*/ ctx[29])) && create_if_block_4$1(ctx);
    	let if_block6 = /*isWaiting*/ ctx[4] && create_if_block_3$1(ctx);
    	let if_block7 = /*listOpen*/ ctx[5] && create_if_block_2$2(ctx);
    	let if_block8 = (!/*isMulti*/ ctx[7] || /*isMulti*/ ctx[7] && !/*showMultiSelect*/ ctx[35]) && create_if_block_1$5(ctx);
    	let if_block9 = /*isMulti*/ ctx[7] && /*showMultiSelect*/ ctx[35] && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			input_1 = element("input");
    			t3 = space();
    			if (if_block3) if_block3.c();
    			t4 = space();
    			if (if_block4) if_block4.c();
    			t5 = space();
    			if (if_block5) if_block5.c();
    			t6 = space();
    			if (if_block6) if_block6.c();
    			t7 = space();
    			if (if_block7) if_block7.c();
    			t8 = space();
    			if (if_block8) if_block8.c();
    			t9 = space();
    			if (if_block9) if_block9.c();
    			attr_dev(span, "aria-live", "polite");
    			attr_dev(span, "aria-atomic", "false");
    			attr_dev(span, "aria-relevant", "additions text");
    			attr_dev(span, "class", "a11yText svelte-17l1npl");
    			add_location(span, file$b, 870, 4, 23680);
    			set_attributes(input_1, input_1_data);
    			toggle_class(input_1, "svelte-17l1npl", true);
    			add_location(input_1, file$b, 899, 4, 24419);
    			attr_dev(div, "class", div_class_value = "selectContainer " + /*containerClasses*/ ctx[21] + " svelte-17l1npl");
    			attr_dev(div, "style", /*containerStyles*/ ctx[11]);
    			toggle_class(div, "hasError", /*hasError*/ ctx[10]);
    			toggle_class(div, "multiSelect", /*isMulti*/ ctx[7]);
    			toggle_class(div, "disabled", /*isDisabled*/ ctx[9]);
    			toggle_class(div, "focused", /*isFocused*/ ctx[1]);
    			add_location(div, file$b, 861, 0, 23429);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    			if (if_block0) if_block0.m(span, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			if (if_block2) if_block2.m(div, null);
    			append_dev(div, t2);
    			append_dev(div, input_1);
    			if (input_1.autofocus) input_1.focus();
    			/*input_1_binding*/ ctx[82](input_1);
    			set_input_value(input_1, /*filterText*/ ctx[3]);
    			append_dev(div, t3);
    			if (if_block3) if_block3.m(div, null);
    			append_dev(div, t4);
    			if (if_block4) if_block4.m(div, null);
    			append_dev(div, t5);
    			if (if_block5) if_block5.m(div, null);
    			append_dev(div, t6);
    			if (if_block6) if_block6.m(div, null);
    			append_dev(div, t7);
    			if (if_block7) if_block7.m(div, null);
    			append_dev(div, t8);
    			if (if_block8) if_block8.m(div, null);
    			append_dev(div, t9);
    			if (if_block9) if_block9.m(div, null);
    			/*div_binding*/ ctx[85](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(window, "click", /*handleWindowEvent*/ ctx[41], false, false, false),
    					listen_dev(window, "focusin", /*handleWindowEvent*/ ctx[41], false, false, false),
    					listen_dev(window, "keydown", /*handleKeyDown*/ ctx[39], false, false, false),
    					listen_dev(input_1, "focus", /*handleFocus*/ ctx[40], false, false, false),
    					listen_dev(input_1, "input", /*input_1_input_handler*/ ctx[83]),
    					listen_dev(div, "click", /*handleClick*/ ctx[42], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*isFocused*/ ctx[1]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_10(ctx);
    					if_block0.c();
    					if_block0.m(span, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*Icon*/ ctx[17]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*Icon*/ 131072) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_9(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*showMultiSelect*/ ctx[35]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[1] & /*showMultiSelect*/ 16) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_8(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, t2);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			set_attributes(input_1, input_1_data = get_spread_update(input_1_levels, [
    				(!current || dirty[0] & /*isSearchable*/ 8192 && input_1_readonly_value !== (input_1_readonly_value = !/*isSearchable*/ ctx[13])) && { readOnly: input_1_readonly_value },
    				dirty[1] & /*_inputAttributes*/ 1 && /*_inputAttributes*/ ctx[31],
    				(!current || dirty[1] & /*placeholderText*/ 32) && { placeholder: /*placeholderText*/ ctx[36] },
    				(!current || dirty[0] & /*inputStyles*/ 16384) && { style: /*inputStyles*/ ctx[14] },
    				(!current || dirty[0] & /*isDisabled*/ 512) && { disabled: /*isDisabled*/ ctx[9] }
    			]));

    			if (dirty[0] & /*filterText*/ 8 && input_1.value !== /*filterText*/ ctx[3]) {
    				set_input_value(input_1, /*filterText*/ ctx[3]);
    			}

    			toggle_class(input_1, "svelte-17l1npl", true);

    			if (!/*isMulti*/ ctx[7] && /*showSelectedItem*/ ctx[29]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[0] & /*isMulti, showSelectedItem*/ 536871040) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_7(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div, t4);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*showClearIcon*/ ctx[37]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[1] & /*showClearIcon*/ 64) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_6(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div, t5);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (!/*showClearIcon*/ ctx[37] && (/*showIndicator*/ ctx[20] || /*showChevron*/ ctx[19] && !/*value*/ ctx[2] || !/*isSearchable*/ ctx[13] && !/*isDisabled*/ ctx[9] && !/*isWaiting*/ ctx[4] && (/*showSelectedItem*/ ctx[29] && !/*isClearable*/ ctx[15] || !/*showSelectedItem*/ ctx[29]))) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);
    				} else {
    					if_block5 = create_if_block_4$1(ctx);
    					if_block5.c();
    					if_block5.m(div, t6);
    				}
    			} else if (if_block5) {
    				if_block5.d(1);
    				if_block5 = null;
    			}

    			if (/*isWaiting*/ ctx[4]) {
    				if (if_block6) ; else {
    					if_block6 = create_if_block_3$1(ctx);
    					if_block6.c();
    					if_block6.m(div, t7);
    				}
    			} else if (if_block6) {
    				if_block6.d(1);
    				if_block6 = null;
    			}

    			if (/*listOpen*/ ctx[5]) {
    				if (if_block7) {
    					if_block7.p(ctx, dirty);

    					if (dirty[0] & /*listOpen*/ 32) {
    						transition_in(if_block7, 1);
    					}
    				} else {
    					if_block7 = create_if_block_2$2(ctx);
    					if_block7.c();
    					transition_in(if_block7, 1);
    					if_block7.m(div, t8);
    				}
    			} else if (if_block7) {
    				group_outros();

    				transition_out(if_block7, 1, 1, () => {
    					if_block7 = null;
    				});

    				check_outros();
    			}

    			if (!/*isMulti*/ ctx[7] || /*isMulti*/ ctx[7] && !/*showMultiSelect*/ ctx[35]) {
    				if (if_block8) {
    					if_block8.p(ctx, dirty);
    				} else {
    					if_block8 = create_if_block_1$5(ctx);
    					if_block8.c();
    					if_block8.m(div, t9);
    				}
    			} else if (if_block8) {
    				if_block8.d(1);
    				if_block8 = null;
    			}

    			if (/*isMulti*/ ctx[7] && /*showMultiSelect*/ ctx[35]) {
    				if (if_block9) {
    					if_block9.p(ctx, dirty);
    				} else {
    					if_block9 = create_if_block$6(ctx);
    					if_block9.c();
    					if_block9.m(div, null);
    				}
    			} else if (if_block9) {
    				if_block9.d(1);
    				if_block9 = null;
    			}

    			if (!current || dirty[0] & /*containerClasses*/ 2097152 && div_class_value !== (div_class_value = "selectContainer " + /*containerClasses*/ ctx[21] + " svelte-17l1npl")) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (!current || dirty[0] & /*containerStyles*/ 2048) {
    				attr_dev(div, "style", /*containerStyles*/ ctx[11]);
    			}

    			if (!current || dirty[0] & /*containerClasses, hasError*/ 2098176) {
    				toggle_class(div, "hasError", /*hasError*/ ctx[10]);
    			}

    			if (!current || dirty[0] & /*containerClasses, isMulti*/ 2097280) {
    				toggle_class(div, "multiSelect", /*isMulti*/ ctx[7]);
    			}

    			if (!current || dirty[0] & /*containerClasses, isDisabled*/ 2097664) {
    				toggle_class(div, "disabled", /*isDisabled*/ ctx[9]);
    			}

    			if (!current || dirty[0] & /*containerClasses, isFocused*/ 2097154) {
    				toggle_class(div, "focused", /*isFocused*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(if_block7);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(if_block7);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			/*input_1_binding*/ ctx[82](null);
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			if (if_block6) if_block6.d();
    			if (if_block7) if_block7.d();
    			if (if_block8) if_block8.d();
    			if (if_block9) if_block9.d();
    			/*div_binding*/ ctx[85](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function convertStringItemsToObjects(_items) {
    	return _items.map((item, index) => {
    		return { index, value: item, label: `${item}` };
    	});
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let filteredItems;
    	let showSelectedItem;
    	let showClearIcon;
    	let placeholderText;
    	let showMultiSelect;
    	let listProps;
    	let ariaSelection;
    	let ariaContext;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Select', slots, []);
    	const dispatch = createEventDispatcher();
    	let { id = null } = $$props;
    	let { container = undefined } = $$props;
    	let { input = undefined } = $$props;
    	let { isMulti = false } = $$props;
    	let { multiFullItemClearable = false } = $$props;
    	let { isDisabled = false } = $$props;
    	let { isCreatable = false } = $$props;
    	let { isFocused = false } = $$props;
    	let { value = null } = $$props;
    	let { filterText = '' } = $$props;
    	let { placeholder = 'Select...' } = $$props;
    	let { placeholderAlwaysShow = false } = $$props;
    	let { items = null } = $$props;
    	let { itemFilter = (label, filterText, option) => `${label}`.toLowerCase().includes(filterText.toLowerCase()) } = $$props;
    	let { groupBy = undefined } = $$props;
    	let { groupFilter = groups => groups } = $$props;
    	let { isGroupHeaderSelectable = false } = $$props;

    	let { getGroupHeaderLabel = option => {
    		return option[labelIdentifier] || option.id;
    	} } = $$props;

    	let { labelIdentifier = 'label' } = $$props;

    	let { getOptionLabel = (option, filterText) => {
    		return option.isCreator
    		? `Create \"${filterText}\"`
    		: option[labelIdentifier];
    	} } = $$props;

    	let { optionIdentifier = 'value' } = $$props;
    	let { loadOptions = undefined } = $$props;
    	let { hasError = false } = $$props;
    	let { containerStyles = '' } = $$props;

    	let { getSelectionLabel = option => {
    		if (option) return option[labelIdentifier]; else return null;
    	} } = $$props;

    	let { createGroupHeaderItem = groupValue => {
    		return { value: groupValue, label: groupValue };
    	} } = $$props;

    	let { createItem = filterText => {
    		return { value: filterText, label: filterText };
    	} } = $$props;

    	const getFilteredItems = () => {
    		return filteredItems;
    	};

    	let { isSearchable = true } = $$props;
    	let { inputStyles = '' } = $$props;
    	let { isClearable = true } = $$props;
    	let { isWaiting = false } = $$props;
    	let { listPlacement = 'auto' } = $$props;
    	let { listOpen = false } = $$props;
    	let { isVirtualList = false } = $$props;
    	let { loadOptionsInterval = 300 } = $$props;
    	let { noOptionsMessage = 'No options' } = $$props;
    	let { hideEmptyState = false } = $$props;
    	let { inputAttributes = {} } = $$props;
    	let { listAutoWidth = true } = $$props;
    	let { itemHeight = 40 } = $$props;
    	let { Icon = undefined } = $$props;
    	let { iconProps = {} } = $$props;
    	let { showChevron = false } = $$props;
    	let { showIndicator = false } = $$props;
    	let { containerClasses = '' } = $$props;
    	let { indicatorSvg = undefined } = $$props;
    	let { listOffset = 5 } = $$props;
    	let { ClearIcon: ClearIcon$1 = ClearIcon } = $$props;
    	let { Item: Item$1 = Item } = $$props;
    	let { List: List$1 = List } = $$props;
    	let { Selection: Selection$1 = Selection } = $$props;
    	let { MultiSelection: MultiSelection$1 = MultiSelection } = $$props;
    	let { VirtualList: VirtualList$1 = VirtualList } = $$props;

    	function filterMethod(args) {
    		if (args.loadOptions && args.filterText.length > 0) return;
    		if (!args.items) return [];

    		if (args.items && args.items.length > 0 && typeof args.items[0] !== 'object') {
    			args.items = convertStringItemsToObjects(args.items);
    		}

    		let filterResults = args.items.filter(item => {
    			let matchesFilter = itemFilter(getOptionLabel(item, args.filterText), args.filterText, item);

    			if (matchesFilter && args.isMulti && args.value && Array.isArray(args.value)) {
    				matchesFilter = !args.value.some(x => {
    					return x[args.optionIdentifier] === item[args.optionIdentifier];
    				});
    			}

    			return matchesFilter;
    		});

    		if (args.groupBy) {
    			filterResults = filterGroupedItems(filterResults);
    		}

    		if (args.isCreatable) {
    			filterResults = addCreatableItem(filterResults, args.filterText);
    		}

    		return filterResults;
    	}

    	function addCreatableItem(_items, _filterText) {
    		if (_filterText.length === 0) return _items;
    		const itemToCreate = createItem(_filterText);
    		if (_items[0] && _filterText === _items[0][labelIdentifier]) return _items;
    		itemToCreate.isCreator = true;
    		return [..._items, itemToCreate];
    	}

    	let { selectedValue = null } = $$props;
    	let activeValue;
    	let prev_value;
    	let prev_filterText;
    	let prev_isFocused;
    	let prev_isMulti;
    	let hoverItemIndex;

    	const getItems = debounce(
    		async () => {
    			$$invalidate(4, isWaiting = true);

    			let res = await loadOptions(filterText).catch(err => {
    				console.warn('svelte-select loadOptions error :>> ', err);
    				dispatch('error', { type: 'loadOptions', details: err });
    			});

    			if (res && !res.cancelled) {
    				if (res) {
    					if (res && res.length > 0 && typeof res[0] !== 'object') {
    						res = convertStringItemsToObjects(res);
    					}

    					$$invalidate(81, filteredItems = [...res]);
    					dispatch('loaded', { items: filteredItems });
    				} else {
    					$$invalidate(81, filteredItems = []);
    				}

    				if (isCreatable) {
    					$$invalidate(81, filteredItems = addCreatableItem(filteredItems, filterText));
    				}

    				$$invalidate(4, isWaiting = false);
    				$$invalidate(1, isFocused = true);
    				$$invalidate(5, listOpen = true);
    			}
    		},
    		loadOptionsInterval
    	);

    	function setValue() {
    		if (typeof value === 'string') {
    			$$invalidate(2, value = { [optionIdentifier]: value, label: value });
    		} else if (isMulti && Array.isArray(value) && value.length > 0) {
    			$$invalidate(2, value = value.map(item => typeof item === 'string'
    			? { value: item, label: item }
    			: item));
    		}
    	}

    	let _inputAttributes;

    	function assignInputAttributes() {
    		$$invalidate(31, _inputAttributes = Object.assign(
    			{
    				autocapitalize: 'none',
    				autocomplete: 'off',
    				autocorrect: 'off',
    				spellcheck: false,
    				tabindex: 0,
    				type: 'text',
    				'aria-autocomplete': 'list'
    			},
    			inputAttributes
    		));

    		if (id) {
    			$$invalidate(31, _inputAttributes.id = id, _inputAttributes);
    		}

    		if (!isSearchable) {
    			$$invalidate(31, _inputAttributes.readonly = true, _inputAttributes);
    		}
    	}

    	function filterGroupedItems(_items) {
    		const groupValues = [];
    		const groups = {};

    		_items.forEach(item => {
    			const groupValue = groupBy(item);

    			if (!groupValues.includes(groupValue)) {
    				groupValues.push(groupValue);
    				groups[groupValue] = [];

    				if (groupValue) {
    					groups[groupValue].push(Object.assign(createGroupHeaderItem(groupValue, item), {
    						id: groupValue,
    						isGroupHeader: true,
    						isSelectable: isGroupHeaderSelectable
    					}));
    				}
    			}

    			groups[groupValue].push(Object.assign({ isGroupItem: !!groupValue }, item));
    		});

    		const sortedGroupedItems = [];

    		groupFilter(groupValues).forEach(groupValue => {
    			sortedGroupedItems.push(...groups[groupValue]);
    		});

    		return sortedGroupedItems;
    	}

    	function dispatchSelectedItem() {
    		if (isMulti) {
    			if (JSON.stringify(value) !== JSON.stringify(prev_value)) {
    				if (checkValueForDuplicates()) {
    					dispatch('select', value);
    				}
    			}

    			return;
    		}

    		if (!prev_value || JSON.stringify(value[optionIdentifier]) !== JSON.stringify(prev_value[optionIdentifier])) {
    			dispatch('select', value);
    		}
    	}

    	function setupFocus() {
    		if (isFocused || listOpen) {
    			handleFocus();
    		} else {
    			if (input) input.blur();
    		}
    	}

    	function setupMulti() {
    		if (value) {
    			if (Array.isArray(value)) {
    				$$invalidate(2, value = [...value]);
    			} else {
    				$$invalidate(2, value = [value]);
    			}
    		}
    	}

    	function setupSingle() {
    		if (value) $$invalidate(2, value = null);
    	}

    	function setupFilterText() {
    		if (filterText.length === 0) return;
    		$$invalidate(1, isFocused = true);
    		$$invalidate(5, listOpen = true);

    		if (loadOptions) {
    			getItems();
    		} else {
    			$$invalidate(5, listOpen = true);

    			if (isMulti) {
    				$$invalidate(30, activeValue = undefined);
    			}
    		}
    	}

    	beforeUpdate(async () => {
    		$$invalidate(77, prev_value = value);
    		$$invalidate(78, prev_filterText = filterText);
    		$$invalidate(79, prev_isFocused = isFocused);
    		$$invalidate(80, prev_isMulti = isMulti);
    	});

    	function checkValueForDuplicates() {
    		let noDuplicates = true;

    		if (value) {
    			const ids = [];
    			const uniqueValues = [];

    			value.forEach(val => {
    				if (!ids.includes(val[optionIdentifier])) {
    					ids.push(val[optionIdentifier]);
    					uniqueValues.push(val);
    				} else {
    					noDuplicates = false;
    				}
    			});

    			if (!noDuplicates) $$invalidate(2, value = uniqueValues);
    		}

    		return noDuplicates;
    	}

    	function findItem(selection) {
    		let matchTo = selection
    		? selection[optionIdentifier]
    		: value[optionIdentifier];

    		return items.find(item => item[optionIdentifier] === matchTo);
    	}

    	function updateValueDisplay(items) {
    		if (!items || items.length === 0 || items.some(item => typeof item !== 'object')) return;

    		if (!value || (isMulti
    		? value.some(selection => !selection || !selection[optionIdentifier])
    		: !value[optionIdentifier])) return;

    		if (Array.isArray(value)) {
    			$$invalidate(2, value = value.map(selection => findItem(selection) || selection));
    		} else {
    			$$invalidate(2, value = findItem() || value);
    		}
    	}

    	function handleMultiItemClear(event) {
    		const { detail } = event;
    		const itemToRemove = value[detail ? detail.i : value.length - 1];

    		if (value.length === 1) {
    			$$invalidate(2, value = undefined);
    		} else {
    			$$invalidate(2, value = value.filter(item => {
    				return item !== itemToRemove;
    			}));
    		}

    		dispatch('clear', itemToRemove);
    	}

    	function handleKeyDown(e) {
    		if (!isFocused) return;

    		switch (e.key) {
    			case 'ArrowDown':
    				e.preventDefault();
    				$$invalidate(5, listOpen = true);
    				$$invalidate(30, activeValue = undefined);
    				break;
    			case 'ArrowUp':
    				e.preventDefault();
    				$$invalidate(5, listOpen = true);
    				$$invalidate(30, activeValue = undefined);
    				break;
    			case 'Tab':
    				if (!listOpen) $$invalidate(1, isFocused = false);
    				break;
    			case 'Backspace':
    				if (!isMulti || filterText.length > 0) return;
    				if (isMulti && value && value.length > 0) {
    					handleMultiItemClear(activeValue !== undefined
    					? activeValue
    					: value.length - 1);

    					if (activeValue === 0 || activeValue === undefined) break;
    					$$invalidate(30, activeValue = value.length > activeValue ? activeValue - 1 : undefined);
    				}
    				break;
    			case 'ArrowLeft':
    				if (!isMulti || filterText.length > 0) return;
    				if (activeValue === undefined) {
    					$$invalidate(30, activeValue = value.length - 1);
    				} else if (value.length > activeValue && activeValue !== 0) {
    					$$invalidate(30, activeValue -= 1);
    				}
    				break;
    			case 'ArrowRight':
    				if (!isMulti || filterText.length > 0 || activeValue === undefined) return;
    				if (activeValue === value.length - 1) {
    					$$invalidate(30, activeValue = undefined);
    				} else if (activeValue < value.length - 1) {
    					$$invalidate(30, activeValue += 1);
    				}
    				break;
    		}
    	}

    	function handleFocus() {
    		$$invalidate(1, isFocused = true);
    		if (input) input.focus();
    	}

    	function handleWindowEvent(event) {
    		if (!container) return;

    		const eventTarget = event.path && event.path.length > 0
    		? event.path[0]
    		: event.target;

    		if (container.contains(eventTarget) || container.contains(event.relatedTarget)) {
    			return;
    		}

    		$$invalidate(1, isFocused = false);
    		$$invalidate(5, listOpen = false);
    		$$invalidate(30, activeValue = undefined);
    		if (input) input.blur();
    	}

    	function handleClick() {
    		if (isDisabled) return;
    		$$invalidate(1, isFocused = true);
    		$$invalidate(5, listOpen = !listOpen);
    	}

    	function handleClear() {
    		$$invalidate(2, value = undefined);
    		$$invalidate(5, listOpen = false);
    		dispatch('clear', value);
    		handleFocus();
    	}

    	onMount(() => {
    		if (isFocused && input) input.focus();
    	});

    	function itemSelected(event) {
    		const { detail } = event;

    		if (detail) {
    			$$invalidate(3, filterText = '');
    			const item = Object.assign({}, detail);

    			if (!item.isGroupHeader || item.isSelectable) {
    				if (isMulti) {
    					$$invalidate(2, value = value ? value.concat([item]) : [item]);
    				} else {
    					$$invalidate(2, value = item);
    				}

    				$$invalidate(2, value);

    				setTimeout(() => {
    					$$invalidate(5, listOpen = false);
    					$$invalidate(30, activeValue = undefined);
    				});
    			}
    		}
    	}

    	function itemCreated(event) {
    		const { detail } = event;

    		if (isMulti) {
    			$$invalidate(2, value = value || []);
    			$$invalidate(2, value = [...value, createItem(detail)]);
    		} else {
    			$$invalidate(2, value = createItem(detail));
    		}

    		dispatch('itemCreated', detail);
    		$$invalidate(3, filterText = '');
    		$$invalidate(5, listOpen = false);
    		$$invalidate(30, activeValue = undefined);
    	}

    	function closeList() {
    		$$invalidate(3, filterText = '');
    		$$invalidate(5, listOpen = false);
    	}

    	let { ariaValues = values => {
    		return `Option ${values}, selected.`;
    	} } = $$props;

    	let { ariaListOpen = (label, count) => {
    		return `You are currently focused on option ${label}. There are ${count} results available.`;
    	} } = $$props;

    	let { ariaFocused = () => {
    		return `Select is focused, type to refine list, press down to open the menu.`;
    	} } = $$props;

    	function handleAriaSelection() {
    		let selected = undefined;

    		if (isMulti && value.length > 0) {
    			selected = value.map(v => getSelectionLabel(v)).join(', ');
    		} else {
    			selected = getSelectionLabel(value);
    		}

    		return ariaValues(selected);
    	}

    	function handleAriaContent() {
    		if (!isFocused || !filteredItems || filteredItems.length === 0) return '';
    		let _item = filteredItems[hoverItemIndex];

    		if (listOpen && _item) {
    			let label = getSelectionLabel(_item);
    			let count = filteredItems ? filteredItems.length : 0;
    			return ariaListOpen(label, count);
    		} else {
    			return ariaFocused();
    		}
    	}

    	const writable_props = [
    		'id',
    		'container',
    		'input',
    		'isMulti',
    		'multiFullItemClearable',
    		'isDisabled',
    		'isCreatable',
    		'isFocused',
    		'value',
    		'filterText',
    		'placeholder',
    		'placeholderAlwaysShow',
    		'items',
    		'itemFilter',
    		'groupBy',
    		'groupFilter',
    		'isGroupHeaderSelectable',
    		'getGroupHeaderLabel',
    		'labelIdentifier',
    		'getOptionLabel',
    		'optionIdentifier',
    		'loadOptions',
    		'hasError',
    		'containerStyles',
    		'getSelectionLabel',
    		'createGroupHeaderItem',
    		'createItem',
    		'isSearchable',
    		'inputStyles',
    		'isClearable',
    		'isWaiting',
    		'listPlacement',
    		'listOpen',
    		'isVirtualList',
    		'loadOptionsInterval',
    		'noOptionsMessage',
    		'hideEmptyState',
    		'inputAttributes',
    		'listAutoWidth',
    		'itemHeight',
    		'Icon',
    		'iconProps',
    		'showChevron',
    		'showIndicator',
    		'containerClasses',
    		'indicatorSvg',
    		'listOffset',
    		'ClearIcon',
    		'Item',
    		'List',
    		'Selection',
    		'MultiSelection',
    		'VirtualList',
    		'selectedValue',
    		'ariaValues',
    		'ariaListOpen',
    		'ariaFocused'
    	];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<Select> was created with unknown prop '${key}'`);
    	});

    	function input_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			input = $$value;
    			$$invalidate(6, input);
    		});
    	}

    	function input_1_input_handler() {
    		filterText = this.value;
    		$$invalidate(3, filterText);
    	}

    	function switch_instance_hoverItemIndex_binding(value) {
    		hoverItemIndex = value;
    		$$invalidate(28, hoverItemIndex);
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			container = $$value;
    			$$invalidate(0, container);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('id' in $$props) $$invalidate(46, id = $$props.id);
    		if ('container' in $$props) $$invalidate(0, container = $$props.container);
    		if ('input' in $$props) $$invalidate(6, input = $$props.input);
    		if ('isMulti' in $$props) $$invalidate(7, isMulti = $$props.isMulti);
    		if ('multiFullItemClearable' in $$props) $$invalidate(8, multiFullItemClearable = $$props.multiFullItemClearable);
    		if ('isDisabled' in $$props) $$invalidate(9, isDisabled = $$props.isDisabled);
    		if ('isCreatable' in $$props) $$invalidate(47, isCreatable = $$props.isCreatable);
    		if ('isFocused' in $$props) $$invalidate(1, isFocused = $$props.isFocused);
    		if ('value' in $$props) $$invalidate(2, value = $$props.value);
    		if ('filterText' in $$props) $$invalidate(3, filterText = $$props.filterText);
    		if ('placeholder' in $$props) $$invalidate(48, placeholder = $$props.placeholder);
    		if ('placeholderAlwaysShow' in $$props) $$invalidate(49, placeholderAlwaysShow = $$props.placeholderAlwaysShow);
    		if ('items' in $$props) $$invalidate(50, items = $$props.items);
    		if ('itemFilter' in $$props) $$invalidate(51, itemFilter = $$props.itemFilter);
    		if ('groupBy' in $$props) $$invalidate(52, groupBy = $$props.groupBy);
    		if ('groupFilter' in $$props) $$invalidate(53, groupFilter = $$props.groupFilter);
    		if ('isGroupHeaderSelectable' in $$props) $$invalidate(54, isGroupHeaderSelectable = $$props.isGroupHeaderSelectable);
    		if ('getGroupHeaderLabel' in $$props) $$invalidate(55, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
    		if ('labelIdentifier' in $$props) $$invalidate(56, labelIdentifier = $$props.labelIdentifier);
    		if ('getOptionLabel' in $$props) $$invalidate(57, getOptionLabel = $$props.getOptionLabel);
    		if ('optionIdentifier' in $$props) $$invalidate(58, optionIdentifier = $$props.optionIdentifier);
    		if ('loadOptions' in $$props) $$invalidate(59, loadOptions = $$props.loadOptions);
    		if ('hasError' in $$props) $$invalidate(10, hasError = $$props.hasError);
    		if ('containerStyles' in $$props) $$invalidate(11, containerStyles = $$props.containerStyles);
    		if ('getSelectionLabel' in $$props) $$invalidate(12, getSelectionLabel = $$props.getSelectionLabel);
    		if ('createGroupHeaderItem' in $$props) $$invalidate(60, createGroupHeaderItem = $$props.createGroupHeaderItem);
    		if ('createItem' in $$props) $$invalidate(61, createItem = $$props.createItem);
    		if ('isSearchable' in $$props) $$invalidate(13, isSearchable = $$props.isSearchable);
    		if ('inputStyles' in $$props) $$invalidate(14, inputStyles = $$props.inputStyles);
    		if ('isClearable' in $$props) $$invalidate(15, isClearable = $$props.isClearable);
    		if ('isWaiting' in $$props) $$invalidate(4, isWaiting = $$props.isWaiting);
    		if ('listPlacement' in $$props) $$invalidate(63, listPlacement = $$props.listPlacement);
    		if ('listOpen' in $$props) $$invalidate(5, listOpen = $$props.listOpen);
    		if ('isVirtualList' in $$props) $$invalidate(64, isVirtualList = $$props.isVirtualList);
    		if ('loadOptionsInterval' in $$props) $$invalidate(65, loadOptionsInterval = $$props.loadOptionsInterval);
    		if ('noOptionsMessage' in $$props) $$invalidate(66, noOptionsMessage = $$props.noOptionsMessage);
    		if ('hideEmptyState' in $$props) $$invalidate(67, hideEmptyState = $$props.hideEmptyState);
    		if ('inputAttributes' in $$props) $$invalidate(16, inputAttributes = $$props.inputAttributes);
    		if ('listAutoWidth' in $$props) $$invalidate(68, listAutoWidth = $$props.listAutoWidth);
    		if ('itemHeight' in $$props) $$invalidate(69, itemHeight = $$props.itemHeight);
    		if ('Icon' in $$props) $$invalidate(17, Icon = $$props.Icon);
    		if ('iconProps' in $$props) $$invalidate(18, iconProps = $$props.iconProps);
    		if ('showChevron' in $$props) $$invalidate(19, showChevron = $$props.showChevron);
    		if ('showIndicator' in $$props) $$invalidate(20, showIndicator = $$props.showIndicator);
    		if ('containerClasses' in $$props) $$invalidate(21, containerClasses = $$props.containerClasses);
    		if ('indicatorSvg' in $$props) $$invalidate(22, indicatorSvg = $$props.indicatorSvg);
    		if ('listOffset' in $$props) $$invalidate(70, listOffset = $$props.listOffset);
    		if ('ClearIcon' in $$props) $$invalidate(23, ClearIcon$1 = $$props.ClearIcon);
    		if ('Item' in $$props) $$invalidate(71, Item$1 = $$props.Item);
    		if ('List' in $$props) $$invalidate(24, List$1 = $$props.List);
    		if ('Selection' in $$props) $$invalidate(25, Selection$1 = $$props.Selection);
    		if ('MultiSelection' in $$props) $$invalidate(26, MultiSelection$1 = $$props.MultiSelection);
    		if ('VirtualList' in $$props) $$invalidate(72, VirtualList$1 = $$props.VirtualList);
    		if ('selectedValue' in $$props) $$invalidate(73, selectedValue = $$props.selectedValue);
    		if ('ariaValues' in $$props) $$invalidate(74, ariaValues = $$props.ariaValues);
    		if ('ariaListOpen' in $$props) $$invalidate(75, ariaListOpen = $$props.ariaListOpen);
    		if ('ariaFocused' in $$props) $$invalidate(76, ariaFocused = $$props.ariaFocused);
    	};

    	$$self.$capture_state = () => ({
    		beforeUpdate,
    		createEventDispatcher,
    		onMount,
    		_List: List,
    		_Item: Item,
    		_Selection: Selection,
    		_MultiSelection: MultiSelection,
    		_VirtualList: VirtualList,
    		_ClearIcon: ClearIcon,
    		debounce,
    		dispatch,
    		id,
    		container,
    		input,
    		isMulti,
    		multiFullItemClearable,
    		isDisabled,
    		isCreatable,
    		isFocused,
    		value,
    		filterText,
    		placeholder,
    		placeholderAlwaysShow,
    		items,
    		itemFilter,
    		groupBy,
    		groupFilter,
    		isGroupHeaderSelectable,
    		getGroupHeaderLabel,
    		labelIdentifier,
    		getOptionLabel,
    		optionIdentifier,
    		loadOptions,
    		hasError,
    		containerStyles,
    		getSelectionLabel,
    		createGroupHeaderItem,
    		createItem,
    		getFilteredItems,
    		isSearchable,
    		inputStyles,
    		isClearable,
    		isWaiting,
    		listPlacement,
    		listOpen,
    		isVirtualList,
    		loadOptionsInterval,
    		noOptionsMessage,
    		hideEmptyState,
    		inputAttributes,
    		listAutoWidth,
    		itemHeight,
    		Icon,
    		iconProps,
    		showChevron,
    		showIndicator,
    		containerClasses,
    		indicatorSvg,
    		listOffset,
    		ClearIcon: ClearIcon$1,
    		Item: Item$1,
    		List: List$1,
    		Selection: Selection$1,
    		MultiSelection: MultiSelection$1,
    		VirtualList: VirtualList$1,
    		filterMethod,
    		addCreatableItem,
    		selectedValue,
    		activeValue,
    		prev_value,
    		prev_filterText,
    		prev_isFocused,
    		prev_isMulti,
    		hoverItemIndex,
    		getItems,
    		setValue,
    		_inputAttributes,
    		assignInputAttributes,
    		convertStringItemsToObjects,
    		filterGroupedItems,
    		dispatchSelectedItem,
    		setupFocus,
    		setupMulti,
    		setupSingle,
    		setupFilterText,
    		checkValueForDuplicates,
    		findItem,
    		updateValueDisplay,
    		handleMultiItemClear,
    		handleKeyDown,
    		handleFocus,
    		handleWindowEvent,
    		handleClick,
    		handleClear,
    		itemSelected,
    		itemCreated,
    		closeList,
    		ariaValues,
    		ariaListOpen,
    		ariaFocused,
    		handleAriaSelection,
    		handleAriaContent,
    		filteredItems,
    		ariaContext,
    		ariaSelection,
    		listProps,
    		showMultiSelect,
    		placeholderText,
    		showSelectedItem,
    		showClearIcon
    	});

    	$$self.$inject_state = $$props => {
    		if ('id' in $$props) $$invalidate(46, id = $$props.id);
    		if ('container' in $$props) $$invalidate(0, container = $$props.container);
    		if ('input' in $$props) $$invalidate(6, input = $$props.input);
    		if ('isMulti' in $$props) $$invalidate(7, isMulti = $$props.isMulti);
    		if ('multiFullItemClearable' in $$props) $$invalidate(8, multiFullItemClearable = $$props.multiFullItemClearable);
    		if ('isDisabled' in $$props) $$invalidate(9, isDisabled = $$props.isDisabled);
    		if ('isCreatable' in $$props) $$invalidate(47, isCreatable = $$props.isCreatable);
    		if ('isFocused' in $$props) $$invalidate(1, isFocused = $$props.isFocused);
    		if ('value' in $$props) $$invalidate(2, value = $$props.value);
    		if ('filterText' in $$props) $$invalidate(3, filterText = $$props.filterText);
    		if ('placeholder' in $$props) $$invalidate(48, placeholder = $$props.placeholder);
    		if ('placeholderAlwaysShow' in $$props) $$invalidate(49, placeholderAlwaysShow = $$props.placeholderAlwaysShow);
    		if ('items' in $$props) $$invalidate(50, items = $$props.items);
    		if ('itemFilter' in $$props) $$invalidate(51, itemFilter = $$props.itemFilter);
    		if ('groupBy' in $$props) $$invalidate(52, groupBy = $$props.groupBy);
    		if ('groupFilter' in $$props) $$invalidate(53, groupFilter = $$props.groupFilter);
    		if ('isGroupHeaderSelectable' in $$props) $$invalidate(54, isGroupHeaderSelectable = $$props.isGroupHeaderSelectable);
    		if ('getGroupHeaderLabel' in $$props) $$invalidate(55, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
    		if ('labelIdentifier' in $$props) $$invalidate(56, labelIdentifier = $$props.labelIdentifier);
    		if ('getOptionLabel' in $$props) $$invalidate(57, getOptionLabel = $$props.getOptionLabel);
    		if ('optionIdentifier' in $$props) $$invalidate(58, optionIdentifier = $$props.optionIdentifier);
    		if ('loadOptions' in $$props) $$invalidate(59, loadOptions = $$props.loadOptions);
    		if ('hasError' in $$props) $$invalidate(10, hasError = $$props.hasError);
    		if ('containerStyles' in $$props) $$invalidate(11, containerStyles = $$props.containerStyles);
    		if ('getSelectionLabel' in $$props) $$invalidate(12, getSelectionLabel = $$props.getSelectionLabel);
    		if ('createGroupHeaderItem' in $$props) $$invalidate(60, createGroupHeaderItem = $$props.createGroupHeaderItem);
    		if ('createItem' in $$props) $$invalidate(61, createItem = $$props.createItem);
    		if ('isSearchable' in $$props) $$invalidate(13, isSearchable = $$props.isSearchable);
    		if ('inputStyles' in $$props) $$invalidate(14, inputStyles = $$props.inputStyles);
    		if ('isClearable' in $$props) $$invalidate(15, isClearable = $$props.isClearable);
    		if ('isWaiting' in $$props) $$invalidate(4, isWaiting = $$props.isWaiting);
    		if ('listPlacement' in $$props) $$invalidate(63, listPlacement = $$props.listPlacement);
    		if ('listOpen' in $$props) $$invalidate(5, listOpen = $$props.listOpen);
    		if ('isVirtualList' in $$props) $$invalidate(64, isVirtualList = $$props.isVirtualList);
    		if ('loadOptionsInterval' in $$props) $$invalidate(65, loadOptionsInterval = $$props.loadOptionsInterval);
    		if ('noOptionsMessage' in $$props) $$invalidate(66, noOptionsMessage = $$props.noOptionsMessage);
    		if ('hideEmptyState' in $$props) $$invalidate(67, hideEmptyState = $$props.hideEmptyState);
    		if ('inputAttributes' in $$props) $$invalidate(16, inputAttributes = $$props.inputAttributes);
    		if ('listAutoWidth' in $$props) $$invalidate(68, listAutoWidth = $$props.listAutoWidth);
    		if ('itemHeight' in $$props) $$invalidate(69, itemHeight = $$props.itemHeight);
    		if ('Icon' in $$props) $$invalidate(17, Icon = $$props.Icon);
    		if ('iconProps' in $$props) $$invalidate(18, iconProps = $$props.iconProps);
    		if ('showChevron' in $$props) $$invalidate(19, showChevron = $$props.showChevron);
    		if ('showIndicator' in $$props) $$invalidate(20, showIndicator = $$props.showIndicator);
    		if ('containerClasses' in $$props) $$invalidate(21, containerClasses = $$props.containerClasses);
    		if ('indicatorSvg' in $$props) $$invalidate(22, indicatorSvg = $$props.indicatorSvg);
    		if ('listOffset' in $$props) $$invalidate(70, listOffset = $$props.listOffset);
    		if ('ClearIcon' in $$props) $$invalidate(23, ClearIcon$1 = $$props.ClearIcon);
    		if ('Item' in $$props) $$invalidate(71, Item$1 = $$props.Item);
    		if ('List' in $$props) $$invalidate(24, List$1 = $$props.List);
    		if ('Selection' in $$props) $$invalidate(25, Selection$1 = $$props.Selection);
    		if ('MultiSelection' in $$props) $$invalidate(26, MultiSelection$1 = $$props.MultiSelection);
    		if ('VirtualList' in $$props) $$invalidate(72, VirtualList$1 = $$props.VirtualList);
    		if ('selectedValue' in $$props) $$invalidate(73, selectedValue = $$props.selectedValue);
    		if ('activeValue' in $$props) $$invalidate(30, activeValue = $$props.activeValue);
    		if ('prev_value' in $$props) $$invalidate(77, prev_value = $$props.prev_value);
    		if ('prev_filterText' in $$props) $$invalidate(78, prev_filterText = $$props.prev_filterText);
    		if ('prev_isFocused' in $$props) $$invalidate(79, prev_isFocused = $$props.prev_isFocused);
    		if ('prev_isMulti' in $$props) $$invalidate(80, prev_isMulti = $$props.prev_isMulti);
    		if ('hoverItemIndex' in $$props) $$invalidate(28, hoverItemIndex = $$props.hoverItemIndex);
    		if ('_inputAttributes' in $$props) $$invalidate(31, _inputAttributes = $$props._inputAttributes);
    		if ('ariaValues' in $$props) $$invalidate(74, ariaValues = $$props.ariaValues);
    		if ('ariaListOpen' in $$props) $$invalidate(75, ariaListOpen = $$props.ariaListOpen);
    		if ('ariaFocused' in $$props) $$invalidate(76, ariaFocused = $$props.ariaFocused);
    		if ('filteredItems' in $$props) $$invalidate(81, filteredItems = $$props.filteredItems);
    		if ('ariaContext' in $$props) $$invalidate(32, ariaContext = $$props.ariaContext);
    		if ('ariaSelection' in $$props) $$invalidate(33, ariaSelection = $$props.ariaSelection);
    		if ('listProps' in $$props) $$invalidate(34, listProps = $$props.listProps);
    		if ('showMultiSelect' in $$props) $$invalidate(35, showMultiSelect = $$props.showMultiSelect);
    		if ('placeholderText' in $$props) $$invalidate(36, placeholderText = $$props.placeholderText);
    		if ('showSelectedItem' in $$props) $$invalidate(29, showSelectedItem = $$props.showSelectedItem);
    		if ('showClearIcon' in $$props) $$invalidate(37, showClearIcon = $$props.showClearIcon);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*filterText, value, isMulti*/ 140 | $$self.$$.dirty[1] & /*loadOptions, items, optionIdentifier, groupBy, isCreatable*/ 405340160) {
    			$$invalidate(81, filteredItems = filterMethod({
    				loadOptions,
    				filterText,
    				items,
    				value,
    				isMulti,
    				optionIdentifier,
    				groupBy,
    				isCreatable
    			}));
    		}

    		if ($$self.$$.dirty[2] & /*selectedValue*/ 2048) {
    			{
    				if (selectedValue) console.warn('selectedValue is no longer used. Please use value instead.');
    			}
    		}

    		if ($$self.$$.dirty[1] & /*items*/ 524288) {
    			updateValueDisplay(items);
    		}

    		if ($$self.$$.dirty[0] & /*value*/ 4) {
    			{
    				if (value) setValue();
    			}
    		}

    		if ($$self.$$.dirty[0] & /*inputAttributes, isSearchable*/ 73728) {
    			{
    				if (inputAttributes || !isSearchable) assignInputAttributes();
    			}
    		}

    		if ($$self.$$.dirty[0] & /*isMulti*/ 128 | $$self.$$.dirty[2] & /*prev_isMulti*/ 262144) {
    			{
    				if (isMulti) {
    					setupMulti();
    				}

    				if (prev_isMulti && !isMulti) {
    					setupSingle();
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*isMulti, value*/ 132) {
    			{
    				if (isMulti && value && value.length > 1) {
    					checkValueForDuplicates();
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*value*/ 4) {
    			{
    				if (value) dispatchSelectedItem();
    			}
    		}

    		if ($$self.$$.dirty[0] & /*value, isMulti*/ 132 | $$self.$$.dirty[2] & /*prev_value*/ 32768) {
    			{
    				if (!value && isMulti && prev_value) {
    					dispatch('select', value);
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*isFocused*/ 2 | $$self.$$.dirty[2] & /*prev_isFocused*/ 131072) {
    			{
    				if (isFocused !== prev_isFocused) {
    					setupFocus();
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*filterText*/ 8 | $$self.$$.dirty[2] & /*prev_filterText*/ 65536) {
    			{
    				if (filterText !== prev_filterText) {
    					setupFilterText();
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*value, filterText*/ 12) {
    			$$invalidate(29, showSelectedItem = value && filterText.length === 0);
    		}

    		if ($$self.$$.dirty[0] & /*showSelectedItem, isClearable, isDisabled, isWaiting*/ 536904208) {
    			$$invalidate(37, showClearIcon = showSelectedItem && isClearable && !isDisabled && !isWaiting);
    		}

    		if ($$self.$$.dirty[0] & /*isMulti, value*/ 132 | $$self.$$.dirty[1] & /*placeholderAlwaysShow, placeholder*/ 393216) {
    			$$invalidate(36, placeholderText = placeholderAlwaysShow && isMulti
    			? placeholder
    			: value ? '' : placeholder);
    		}

    		if ($$self.$$.dirty[0] & /*isMulti, value*/ 132) {
    			$$invalidate(35, showMultiSelect = isMulti && value && value.length > 0);
    		}

    		if ($$self.$$.dirty[0] & /*filterText, value, isMulti, container*/ 141 | $$self.$$.dirty[1] & /*optionIdentifier, getGroupHeaderLabel, getOptionLabel*/ 218103808 | $$self.$$.dirty[2] & /*Item, noOptionsMessage, hideEmptyState, isVirtualList, VirtualList, filteredItems, itemHeight, listPlacement, listAutoWidth, listOffset*/ 526326) {
    			$$invalidate(34, listProps = {
    				Item: Item$1,
    				filterText,
    				optionIdentifier,
    				noOptionsMessage,
    				hideEmptyState,
    				isVirtualList,
    				VirtualList: VirtualList$1,
    				value,
    				isMulti,
    				getGroupHeaderLabel,
    				items: filteredItems,
    				itemHeight,
    				getOptionLabel,
    				listPlacement,
    				parent: container,
    				listAutoWidth,
    				listOffset
    			});
    		}

    		if ($$self.$$.dirty[0] & /*value, isMulti*/ 132) {
    			$$invalidate(33, ariaSelection = value ? handleAriaSelection() : '');
    		}

    		if ($$self.$$.dirty[0] & /*hoverItemIndex, isFocused, listOpen*/ 268435490 | $$self.$$.dirty[2] & /*filteredItems*/ 524288) {
    			$$invalidate(32, ariaContext = handleAriaContent());
    		}
    	};

    	return [
    		container,
    		isFocused,
    		value,
    		filterText,
    		isWaiting,
    		listOpen,
    		input,
    		isMulti,
    		multiFullItemClearable,
    		isDisabled,
    		hasError,
    		containerStyles,
    		getSelectionLabel,
    		isSearchable,
    		inputStyles,
    		isClearable,
    		inputAttributes,
    		Icon,
    		iconProps,
    		showChevron,
    		showIndicator,
    		containerClasses,
    		indicatorSvg,
    		ClearIcon$1,
    		List$1,
    		Selection$1,
    		MultiSelection$1,
    		handleClear,
    		hoverItemIndex,
    		showSelectedItem,
    		activeValue,
    		_inputAttributes,
    		ariaContext,
    		ariaSelection,
    		listProps,
    		showMultiSelect,
    		placeholderText,
    		showClearIcon,
    		handleMultiItemClear,
    		handleKeyDown,
    		handleFocus,
    		handleWindowEvent,
    		handleClick,
    		itemSelected,
    		itemCreated,
    		closeList,
    		id,
    		isCreatable,
    		placeholder,
    		placeholderAlwaysShow,
    		items,
    		itemFilter,
    		groupBy,
    		groupFilter,
    		isGroupHeaderSelectable,
    		getGroupHeaderLabel,
    		labelIdentifier,
    		getOptionLabel,
    		optionIdentifier,
    		loadOptions,
    		createGroupHeaderItem,
    		createItem,
    		getFilteredItems,
    		listPlacement,
    		isVirtualList,
    		loadOptionsInterval,
    		noOptionsMessage,
    		hideEmptyState,
    		listAutoWidth,
    		itemHeight,
    		listOffset,
    		Item$1,
    		VirtualList$1,
    		selectedValue,
    		ariaValues,
    		ariaListOpen,
    		ariaFocused,
    		prev_value,
    		prev_filterText,
    		prev_isFocused,
    		prev_isMulti,
    		filteredItems,
    		input_1_binding,
    		input_1_input_handler,
    		switch_instance_hoverItemIndex_binding,
    		div_binding
    	];
    }

    class Select extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$c,
    			create_fragment$c,
    			safe_not_equal,
    			{
    				id: 46,
    				container: 0,
    				input: 6,
    				isMulti: 7,
    				multiFullItemClearable: 8,
    				isDisabled: 9,
    				isCreatable: 47,
    				isFocused: 1,
    				value: 2,
    				filterText: 3,
    				placeholder: 48,
    				placeholderAlwaysShow: 49,
    				items: 50,
    				itemFilter: 51,
    				groupBy: 52,
    				groupFilter: 53,
    				isGroupHeaderSelectable: 54,
    				getGroupHeaderLabel: 55,
    				labelIdentifier: 56,
    				getOptionLabel: 57,
    				optionIdentifier: 58,
    				loadOptions: 59,
    				hasError: 10,
    				containerStyles: 11,
    				getSelectionLabel: 12,
    				createGroupHeaderItem: 60,
    				createItem: 61,
    				getFilteredItems: 62,
    				isSearchable: 13,
    				inputStyles: 14,
    				isClearable: 15,
    				isWaiting: 4,
    				listPlacement: 63,
    				listOpen: 5,
    				isVirtualList: 64,
    				loadOptionsInterval: 65,
    				noOptionsMessage: 66,
    				hideEmptyState: 67,
    				inputAttributes: 16,
    				listAutoWidth: 68,
    				itemHeight: 69,
    				Icon: 17,
    				iconProps: 18,
    				showChevron: 19,
    				showIndicator: 20,
    				containerClasses: 21,
    				indicatorSvg: 22,
    				listOffset: 70,
    				ClearIcon: 23,
    				Item: 71,
    				List: 24,
    				Selection: 25,
    				MultiSelection: 26,
    				VirtualList: 72,
    				selectedValue: 73,
    				handleClear: 27,
    				ariaValues: 74,
    				ariaListOpen: 75,
    				ariaFocused: 76
    			},
    			null,
    			[-1, -1, -1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Select",
    			options,
    			id: create_fragment$c.name
    		});
    	}

    	get id() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get container() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set container(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get input() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set input(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isMulti() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isMulti(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get multiFullItemClearable() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set multiFullItemClearable(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isDisabled() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isDisabled(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isCreatable() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isCreatable(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isFocused() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isFocused(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filterText() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filterText(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholderAlwaysShow() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholderAlwaysShow(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get items() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get itemFilter() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set itemFilter(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get groupBy() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set groupBy(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get groupFilter() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set groupFilter(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isGroupHeaderSelectable() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isGroupHeaderSelectable(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getGroupHeaderLabel() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getGroupHeaderLabel(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelIdentifier() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelIdentifier(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getOptionLabel() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getOptionLabel(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get optionIdentifier() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set optionIdentifier(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loadOptions() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loadOptions(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hasError() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hasError(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get containerStyles() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set containerStyles(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getSelectionLabel() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getSelectionLabel(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get createGroupHeaderItem() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set createGroupHeaderItem(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get createItem() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set createItem(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getFilteredItems() {
    		return this.$$.ctx[62];
    	}

    	set getFilteredItems(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isSearchable() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isSearchable(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputStyles() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputStyles(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isClearable() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isClearable(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isWaiting() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isWaiting(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get listPlacement() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set listPlacement(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get listOpen() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set listOpen(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isVirtualList() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isVirtualList(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loadOptionsInterval() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loadOptionsInterval(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noOptionsMessage() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noOptionsMessage(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideEmptyState() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideEmptyState(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputAttributes() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputAttributes(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get listAutoWidth() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set listAutoWidth(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get itemHeight() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set itemHeight(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Icon() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Icon(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconProps() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconProps(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showChevron() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showChevron(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showIndicator() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showIndicator(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get containerClasses() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set containerClasses(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicatorSvg() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicatorSvg(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get listOffset() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set listOffset(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ClearIcon() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ClearIcon(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Item() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Item(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get List() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set List(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Selection() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Selection(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get MultiSelection() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set MultiSelection(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get VirtualList() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set VirtualList(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectedValue() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedValue(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get handleClear() {
    		return this.$$.ctx[27];
    	}

    	set handleClear(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ariaValues() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ariaValues(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ariaListOpen() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ariaListOpen(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ariaFocused() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ariaFocused(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\client\svelte\components\ui\PointerzSelect.svelte generated by Svelte v3.50.1 */
    const file$a = "src\\client\\svelte\\components\\ui\\PointerzSelect.svelte";

    // (21:0) <Label {label}>
    function create_default_slot$4(ctx) {
    	let div;
    	let select;
    	let current;

    	select = new Select({
    			props: {
    				value: /*passedValue*/ ctx[2],
    				items: /*items*/ ctx[0],
    				isClearable: false,
    				isSearchable: false
    			},
    			$$inline: true
    		});

    	select.$on("select", /*handleSelect*/ ctx[3]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(select.$$.fragment);
    			attr_dev(div, "class", "selectLowerContainer svelte-1tvven1");
    			set_style(div, "margin-bottom", css.default.margin + "px");
    			add_location(div, file$a, 21, 2, 483);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(select, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const select_changes = {};
    			if (dirty & /*items*/ 1) select_changes.items = /*items*/ ctx[0];
    			select.$set(select_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(select.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(select.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(select);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(21:0) <Label {label}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let label_1;
    	let current;

    	label_1 = new Label({
    			props: {
    				label: /*label*/ ctx[1],
    				$$slots: { default: [create_default_slot$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(label_1.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(label_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const label_1_changes = {};
    			if (dirty & /*label*/ 2) label_1_changes.label = /*label*/ ctx[1];

    			if (dirty & /*$$scope, items*/ 65) {
    				label_1_changes.$$scope = { dirty, ctx };
    			}

    			label_1.$set(label_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(label_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PointerzSelect', slots, []);
    	const dispatch = createEventDispatcher();
    	let { items = [] } = $$props;
    	let { value } = $$props;
    	let { label } = $$props;
    	let passedValue = value;

    	function handleSelect(event) {
    		$$invalidate(4, value = event.detail);
    		dispatch("change", { value: event.detail.value });
    	}

    	const writable_props = ['items', 'value', 'label'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PointerzSelect> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('items' in $$props) $$invalidate(0, items = $$props.items);
    		if ('value' in $$props) $$invalidate(4, value = $$props.value);
    		if ('label' in $$props) $$invalidate(1, label = $$props.label);
    	};

    	$$self.$capture_state = () => ({
    		Select,
    		createEventDispatcher,
    		css,
    		Label,
    		dispatch,
    		items,
    		value,
    		label,
    		passedValue,
    		handleSelect
    	});

    	$$self.$inject_state = $$props => {
    		if ('items' in $$props) $$invalidate(0, items = $$props.items);
    		if ('value' in $$props) $$invalidate(4, value = $$props.value);
    		if ('label' in $$props) $$invalidate(1, label = $$props.label);
    		if ('passedValue' in $$props) $$invalidate(2, passedValue = $$props.passedValue);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [items, label, passedValue, handleSelect, value];
    }

    class PointerzSelect extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, { items: 0, value: 4, label: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PointerzSelect",
    			options,
    			id: create_fragment$b.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*value*/ ctx[4] === undefined && !('value' in props)) {
    			console.warn("<PointerzSelect> was created without expected prop 'value'");
    		}

    		if (/*label*/ ctx[1] === undefined && !('label' in props)) {
    			console.warn("<PointerzSelect> was created without expected prop 'label'");
    		}
    	}

    	get items() {
    		throw new Error("<PointerzSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<PointerzSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<PointerzSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<PointerzSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<PointerzSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<PointerzSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function is_date(obj) {
        return Object.prototype.toString.call(obj) === '[object Date]';
    }

    function get_interpolator(a, b) {
        if (a === b || a !== a)
            return () => a;
        const type = typeof a;
        if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
            throw new Error('Cannot interpolate values of different type');
        }
        if (Array.isArray(a)) {
            const arr = b.map((bi, i) => {
                return get_interpolator(a[i], bi);
            });
            return t => arr.map(fn => fn(t));
        }
        if (type === 'object') {
            if (!a || !b)
                throw new Error('Object cannot be null');
            if (is_date(a) && is_date(b)) {
                a = a.getTime();
                b = b.getTime();
                const delta = b - a;
                return t => new Date(a + t * delta);
            }
            const keys = Object.keys(b);
            const interpolators = {};
            keys.forEach(key => {
                interpolators[key] = get_interpolator(a[key], b[key]);
            });
            return t => {
                const result = {};
                keys.forEach(key => {
                    result[key] = interpolators[key](t);
                });
                return result;
            };
        }
        if (type === 'number') {
            const delta = b - a;
            return t => a + t * delta;
        }
        throw new Error(`Cannot interpolate ${type} values`);
    }
    function tweened(value, defaults = {}) {
        const store = writable(value);
        let task;
        let target_value = value;
        function set(new_value, opts) {
            if (value == null) {
                store.set(value = new_value);
                return Promise.resolve();
            }
            target_value = new_value;
            let previous_task = task;
            let started = false;
            let { delay = 0, duration = 400, easing = identity$1, interpolate = get_interpolator } = assign(assign({}, defaults), opts);
            if (duration === 0) {
                if (previous_task) {
                    previous_task.abort();
                    previous_task = null;
                }
                store.set(value = target_value);
                return Promise.resolve();
            }
            const start = now() + delay;
            let fn;
            task = loop(now => {
                if (now < start)
                    return true;
                if (!started) {
                    fn = interpolate(value, new_value);
                    if (typeof duration === 'function')
                        duration = duration(value, new_value);
                    started = true;
                }
                if (previous_task) {
                    previous_task.abort();
                    previous_task = null;
                }
                const elapsed = now - start;
                if (elapsed > duration) {
                    store.set(value = new_value);
                    return false;
                }
                // @ts-ignore
                store.set(value = fn(easing(elapsed / duration)));
                return true;
            });
            return task.promise;
        }
        return {
            set,
            update: (fn, opts) => set(fn(target_value, value), opts),
            subscribe: store.subscribe
        };
    }

    const createStyle = ({
      from = 0,
      to = 1,
      reverse = false,
      duration = 300,
      delay = 0,
      css = {},
      onChange = () => false,
      onEnd = () => false,
      easing
    }) => {
      const animation = tweened(reverse ? to : from, {
        duration,
        delay,
        easing
      });
      animation.subscribe(t => {
        let newStyle = "";
        for (let item in css) {
          const {
            input,
            output,
            onComplete = () => false,
            beforeStart = () => false
          } = css[item];
          const inRange = input.filter(i => i <= t).reverse()[0];
          const index = input.indexOf(inRange);
          let val;
          if (!inRange && inRange !== 0) {
            val = output[0];
            beforeStart();
          } else {
            if (input.length - 1 === index) {
              val = output[output.length - 1];
              input[input.length - 1] <= t && onComplete();
            } else {
              const endRange = input[index + 1];
              const percent = ((t - inRange) * 100) / (endRange - inRange);
              const firstItem = output[index];
              const lastItem = output[index + 1];
              if (typeof lastItem === "object") {
                val = "";
                lastItem.map(i => {
                  val += firstItem + ((i - firstItem) * percent) / 100;
                  val += " ";
                });
              } else {
                val = firstItem + ((lastItem - firstItem) * percent) / 100;
              }
            }
          }
          newStyle += `${item}: ${val};`;
        }
        onChange(newStyle);
        if (t === to || t === from) {
          onEnd();
        }
      });
      return {
        play: () => animation.set(to),
        reverse: () => animation.set(from)
      };
    };

    /* node_modules\svelte-checkbox\Checkbox.svelte generated by Svelte v3.50.1 */
    const file$9 = "node_modules\\svelte-checkbox\\Checkbox.svelte";

    function create_fragment$a(ctx) {
    	let div;
    	let input;
    	let t;
    	let svg;
    	let rect0;
    	let rect1;
    	let path;
    	let div_class_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			input = element("input");
    			t = space();
    			svg = svg_element("svg");
    			rect0 = svg_element("rect");
    			rect1 = svg_element("rect");
    			path = svg_element("path");
    			attr_dev(input, "id", /*labelId*/ ctx[4]);
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "name", /*name*/ ctx[2]);
    			attr_dev(input, "class", "svelte-d8g7vy");
    			add_location(input, file$9, 147, 2, 3647);
    			attr_dev(rect0, "class", "checkbox__border svelte-d8g7vy");
    			attr_dev(rect0, "rx", "15%");
    			add_location(rect0, file$9, 149, 4, 3801);
    			attr_dev(rect1, "class", "checkbox__border -active svelte-d8g7vy");
    			attr_dev(rect1, "style", /*borderStyle*/ ctx[8]);
    			attr_dev(rect1, "rx", "15%");
    			add_location(rect1, file$9, 150, 4, 3848);
    			attr_dev(path, "style", /*checkStyle*/ ctx[9]);
    			attr_dev(path, "class", "checkbox__check svelte-d8g7vy");
    			attr_dev(path, "d", "M 89.5 13 L 46 71 L 28 54");
    			add_location(path, file$9, 151, 4, 3923);
    			attr_dev(svg, "class", "checkbox__svg svelte-d8g7vy");
    			attr_dev(svg, "preserveAspectRatio", "none");
    			attr_dev(svg, "viewBox", "0 0 100 100");
    			add_location(svg, file$9, 148, 2, 3720);
    			attr_dev(div, "id", /*id*/ ctx[3]);
    			attr_dev(div, "class", div_class_value = "checkbox " + /*$$props*/ ctx[11].class + " svelte-d8g7vy");
    			set_style(div, "width", /*size*/ ctx[1]);
    			set_style(div, "height", /*size*/ ctx[1]);
    			toggle_class(div, "-changeBg", /*changeBg*/ ctx[7]);
    			toggle_class(div, "-checked", /*checked*/ ctx[0] || !/*canChange*/ ctx[6]);
    			add_location(div, file$9, 140, 0, 3468);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, input);
    			append_dev(div, t);
    			append_dev(div, svg);
    			append_dev(svg, rect0);
    			append_dev(svg, rect1);
    			append_dev(svg, path);
    			/*div_binding*/ ctx[15](div);

    			if (!mounted) {
    				dispose = listen_dev(input, "change", /*handleChange*/ ctx[10], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*labelId*/ 16) {
    				attr_dev(input, "id", /*labelId*/ ctx[4]);
    			}

    			if (dirty & /*name*/ 4) {
    				attr_dev(input, "name", /*name*/ ctx[2]);
    			}

    			if (dirty & /*borderStyle*/ 256) {
    				attr_dev(rect1, "style", /*borderStyle*/ ctx[8]);
    			}

    			if (dirty & /*checkStyle*/ 512) {
    				attr_dev(path, "style", /*checkStyle*/ ctx[9]);
    			}

    			if (dirty & /*id*/ 8) {
    				attr_dev(div, "id", /*id*/ ctx[3]);
    			}

    			if (dirty & /*$$props*/ 2048 && div_class_value !== (div_class_value = "checkbox " + /*$$props*/ ctx[11].class + " svelte-d8g7vy")) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (dirty & /*size*/ 2) {
    				set_style(div, "width", /*size*/ ctx[1]);
    			}

    			if (dirty & /*size*/ 2) {
    				set_style(div, "height", /*size*/ ctx[1]);
    			}

    			if (dirty & /*$$props, changeBg*/ 2176) {
    				toggle_class(div, "-changeBg", /*changeBg*/ ctx[7]);
    			}

    			if (dirty & /*$$props, checked, canChange*/ 2113) {
    				toggle_class(div, "-checked", /*checked*/ ctx[0] || !/*canChange*/ ctx[6]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			/*div_binding*/ ctx[15](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Checkbox', slots, []);
    	let self, canChange = true, changeBg = false, borderStyle, checkStyle;
    	let { checked = false, size = "3rem", name = "", id = "", labelId = "", duration = 900, primaryColor = "#242432", secondaryColor = "#d8d8ea" } = $$props;
    	const dispatch = createEventDispatcher();

    	const animationOptions = {
    		to: 100,
    		duration,
    		easing: sineInOut,
    		reverse: checked
    	};

    	const borderAnimation = createStyle({
    		...animationOptions,
    		duration,
    		css: {
    			"stroke-dashoffset": {
    				input: [0, 45, 75],
    				output: [342, -150, -307],
    				onComplete: () => $$invalidate(7, changeBg = true)
    			},
    			"stroke-dasharray": {
    				input: [0, 45, 75],
    				output: [342, 154, [0, 310]]
    			},
    			opacity: { input: [0, 5], output: [0, 1] }
    		},
    		onChange: style => $$invalidate(8, borderStyle = style),
    		onEnd: () => $$invalidate(6, canChange = true)
    	});

    	const checkAnimation = createStyle({
    		...animationOptions,
    		css: {
    			"stroke-dashoffset": {
    				input: [65, 100],
    				output: [300, 144],
    				beforeStart: () => $$invalidate(7, changeBg = false)
    			},
    			"stroke-dasharray": { input: [65, 100], output: [100, 84] }
    		},
    		onChange: style => $$invalidate(9, checkStyle = style)
    	});

    	const handleChange = () => {
    		if (!canChange) return false;

    		if (checked) {
    			borderAnimation.reverse();
    			checkAnimation.reverse();
    		} else {
    			borderAnimation.play();
    			checkAnimation.play();
    		}

    		$$invalidate(6, canChange = false);
    		$$invalidate(0, checked = !checked);
    		dispatch("change", checked);
    	};

    	const setProp = (prop, val) => self.style.setProperty(prop, val);

    	onMount(() => {
    		setProp("--checkbox-color-primary", primaryColor);
    		setProp("--checkbox-color-secondary", secondaryColor);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			self = $$value;
    			$$invalidate(5, self);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('checked' in $$new_props) $$invalidate(0, checked = $$new_props.checked);
    		if ('size' in $$new_props) $$invalidate(1, size = $$new_props.size);
    		if ('name' in $$new_props) $$invalidate(2, name = $$new_props.name);
    		if ('id' in $$new_props) $$invalidate(3, id = $$new_props.id);
    		if ('labelId' in $$new_props) $$invalidate(4, labelId = $$new_props.labelId);
    		if ('duration' in $$new_props) $$invalidate(12, duration = $$new_props.duration);
    		if ('primaryColor' in $$new_props) $$invalidate(13, primaryColor = $$new_props.primaryColor);
    		if ('secondaryColor' in $$new_props) $$invalidate(14, secondaryColor = $$new_props.secondaryColor);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		sineInOut,
    		createStyle,
    		self,
    		canChange,
    		changeBg,
    		checked,
    		size,
    		name,
    		id,
    		labelId,
    		borderStyle,
    		checkStyle,
    		duration,
    		primaryColor,
    		secondaryColor,
    		dispatch,
    		animationOptions,
    		borderAnimation,
    		checkAnimation,
    		handleChange,
    		setProp
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(11, $$props = assign(assign({}, $$props), $$new_props));
    		if ('self' in $$props) $$invalidate(5, self = $$new_props.self);
    		if ('canChange' in $$props) $$invalidate(6, canChange = $$new_props.canChange);
    		if ('changeBg' in $$props) $$invalidate(7, changeBg = $$new_props.changeBg);
    		if ('checked' in $$props) $$invalidate(0, checked = $$new_props.checked);
    		if ('size' in $$props) $$invalidate(1, size = $$new_props.size);
    		if ('name' in $$props) $$invalidate(2, name = $$new_props.name);
    		if ('id' in $$props) $$invalidate(3, id = $$new_props.id);
    		if ('labelId' in $$props) $$invalidate(4, labelId = $$new_props.labelId);
    		if ('borderStyle' in $$props) $$invalidate(8, borderStyle = $$new_props.borderStyle);
    		if ('checkStyle' in $$props) $$invalidate(9, checkStyle = $$new_props.checkStyle);
    		if ('duration' in $$props) $$invalidate(12, duration = $$new_props.duration);
    		if ('primaryColor' in $$props) $$invalidate(13, primaryColor = $$new_props.primaryColor);
    		if ('secondaryColor' in $$props) $$invalidate(14, secondaryColor = $$new_props.secondaryColor);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);

    	return [
    		checked,
    		size,
    		name,
    		id,
    		labelId,
    		self,
    		canChange,
    		changeBg,
    		borderStyle,
    		checkStyle,
    		handleChange,
    		$$props,
    		duration,
    		primaryColor,
    		secondaryColor,
    		div_binding
    	];
    }

    class Checkbox extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {
    			checked: 0,
    			size: 1,
    			name: 2,
    			id: 3,
    			labelId: 4,
    			duration: 12,
    			primaryColor: 13,
    			secondaryColor: 14
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Checkbox",
    			options,
    			id: create_fragment$a.name
    		});
    	}

    	get checked() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set checked(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelId() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelId(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get duration() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set duration(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get primaryColor() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set primaryColor(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get secondaryColor() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set secondaryColor(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\client\svelte\components\ui\PointerzCheckbox.svelte generated by Svelte v3.50.1 */
    const file$8 = "src\\client\\svelte\\components\\ui\\PointerzCheckbox.svelte";

    // (20:0) <Label {label}>
    function create_default_slot$3(ctx) {
    	let div;
    	let checkbox;
    	let t0;
    	let span;
    	let t1_value = (/*value*/ ctx[0] ? "Closed" : "Opened") + "";
    	let t1;
    	let current;

    	checkbox = new Checkbox({
    			props: {
    				checked: /*value*/ ctx[0],
    				id: /*label*/ ctx[1] + "Checkbox",
    				size: "20px",
    				primaryColor: "#dddbdb",
    				secondaryColor: "#dddbdb"
    			},
    			$$inline: true
    		});

    	checkbox.$on("change", /*forwardChangeEvent*/ ctx[2]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(checkbox.$$.fragment);
    			t0 = space();
    			span = element("span");
    			t1 = text(t1_value);
    			attr_dev(span, "class", "checkboxValueLabel svelte-1pua0p2");
    			add_location(span, file$8, 30, 4, 815);
    			attr_dev(div, "class", "checkboxContainer svelte-1pua0p2");
    			set_style(div, "margin-bottom", css.default.margin - 4 + "px");
    			set_style(div, "margin-top", "2px");
    			add_location(div, file$8, 20, 2, 512);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(checkbox, div, null);
    			append_dev(div, t0);
    			append_dev(div, span);
    			append_dev(span, t1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const checkbox_changes = {};
    			if (dirty & /*value*/ 1) checkbox_changes.checked = /*value*/ ctx[0];
    			if (dirty & /*label*/ 2) checkbox_changes.id = /*label*/ ctx[1] + "Checkbox";
    			checkbox.$set(checkbox_changes);
    			if ((!current || dirty & /*value*/ 1) && t1_value !== (t1_value = (/*value*/ ctx[0] ? "Closed" : "Opened") + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(checkbox.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(checkbox.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(checkbox);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(20:0) <Label {label}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let label_1;
    	let current;

    	label_1 = new Label({
    			props: {
    				label: /*label*/ ctx[1],
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(label_1.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(label_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const label_1_changes = {};
    			if (dirty & /*label*/ 2) label_1_changes.label = /*label*/ ctx[1];

    			if (dirty & /*$$scope, value, label*/ 19) {
    				label_1_changes.$$scope = { dirty, ctx };
    			}

    			label_1.$set(label_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(label_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PointerzCheckbox', slots, []);
    	const dispatch = createEventDispatcher();
    	let { label } = $$props;
    	let { value } = $$props;

    	function forwardChangeEvent(event) {
    		Client$1.phaser.playSound("checking");
    		$$invalidate(0, value = event.detail);
    		dispatch("change", { value });
    	}

    	const writable_props = ['label', 'value'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PointerzCheckbox> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('label' in $$props) $$invalidate(1, label = $$props.label);
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    	};

    	$$self.$capture_state = () => ({
    		Checkbox,
    		css,
    		createEventDispatcher,
    		Label,
    		Client: Client$1,
    		dispatch,
    		label,
    		value,
    		forwardChangeEvent
    	});

    	$$self.$inject_state = $$props => {
    		if ('label' in $$props) $$invalidate(1, label = $$props.label);
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [value, label, forwardChangeEvent];
    }

    class PointerzCheckbox extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, { label: 1, value: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PointerzCheckbox",
    			options,
    			id: create_fragment$9.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*label*/ ctx[1] === undefined && !('label' in props)) {
    			console.warn("<PointerzCheckbox> was created without expected prop 'label'");
    		}

    		if (/*value*/ ctx[0] === undefined && !('value' in props)) {
    			console.warn("<PointerzCheckbox> was created without expected prop 'value'");
    		}
    	}

    	get label() {
    		throw new Error("<PointerzCheckbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<PointerzCheckbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<PointerzCheckbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<PointerzCheckbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\client\svelte\components\editor\BlockProperty.svelte generated by Svelte v3.50.1 */

    // (51:0) {:else}
    function create_else_block$2(ctx) {
    	let pointerzinput;
    	let current;

    	pointerzinput = new PointerzInput({
    			props: {
    				label: /*formatPropertyName*/ ctx[1](/*property*/ ctx[0]),
    				placeholder: /*formatPropertyName*/ ctx[1](/*property*/ ctx[0]),
    				value: /*parent*/ ctx[2][/*property*/ ctx[0]],
    				editorInput: true
    			},
    			$$inline: true
    		});

    	pointerzinput.$on("change", /*change_handler_2*/ ctx[8]);

    	const block = {
    		c: function create() {
    			create_component(pointerzinput.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pointerzinput, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pointerzinput_changes = {};
    			if (dirty & /*formatPropertyName, property*/ 3) pointerzinput_changes.label = /*formatPropertyName*/ ctx[1](/*property*/ ctx[0]);
    			if (dirty & /*formatPropertyName, property*/ 3) pointerzinput_changes.placeholder = /*formatPropertyName*/ ctx[1](/*property*/ ctx[0]);
    			if (dirty & /*parent, property*/ 5) pointerzinput_changes.value = /*parent*/ ctx[2][/*property*/ ctx[0]];
    			pointerzinput.$set(pointerzinput_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerzinput.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerzinput.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pointerzinput, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(51:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (43:63) 
    function create_if_block_1$4(ctx) {
    	let pointerzcheckbox;
    	let current;

    	pointerzcheckbox = new PointerzCheckbox({
    			props: {
    				label: /*formatPropertyName*/ ctx[1](/*property*/ ctx[0]),
    				value: /*parent*/ ctx[2][/*property*/ ctx[0]]
    			},
    			$$inline: true
    		});

    	pointerzcheckbox.$on("change", /*change_handler_1*/ ctx[7]);

    	const block = {
    		c: function create() {
    			create_component(pointerzcheckbox.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pointerzcheckbox, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pointerzcheckbox_changes = {};
    			if (dirty & /*formatPropertyName, property*/ 3) pointerzcheckbox_changes.label = /*formatPropertyName*/ ctx[1](/*property*/ ctx[0]);
    			if (dirty & /*parent, property*/ 5) pointerzcheckbox_changes.value = /*parent*/ ctx[2][/*property*/ ctx[0]];
    			pointerzcheckbox.$set(pointerzcheckbox_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerzcheckbox.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerzcheckbox.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pointerzcheckbox, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(43:63) ",
    		ctx
    	});

    	return block;
    }

    // (34:0) {#if blockPropertiesComponentType[property] == "list"}
    function create_if_block$5(ctx) {
    	let pointerzselect;
    	let current;

    	pointerzselect = new PointerzSelect({
    			props: {
    				label: /*formatPropertyName*/ ctx[1](/*property*/ ctx[0]),
    				items: /*blockPropertiesValueLists*/ ctx[3][/*property*/ ctx[0]],
    				value: {
    					value: /*parent*/ ctx[2][/*property*/ ctx[0]]
    				}
    			},
    			$$inline: true
    		});

    	pointerzselect.$on("change", /*change_handler*/ ctx[6]);

    	const block = {
    		c: function create() {
    			create_component(pointerzselect.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pointerzselect, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pointerzselect_changes = {};
    			if (dirty & /*formatPropertyName, property*/ 3) pointerzselect_changes.label = /*formatPropertyName*/ ctx[1](/*property*/ ctx[0]);
    			if (dirty & /*blockPropertiesValueLists, property*/ 9) pointerzselect_changes.items = /*blockPropertiesValueLists*/ ctx[3][/*property*/ ctx[0]];

    			if (dirty & /*parent, property*/ 5) pointerzselect_changes.value = {
    				value: /*parent*/ ctx[2][/*property*/ ctx[0]]
    			};

    			pointerzselect.$set(pointerzselect_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerzselect.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerzselect.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pointerzselect, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(34:0) {#if blockPropertiesComponentType[property] == \\\"list\\\"}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$5, create_if_block_1$4, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*blockPropertiesComponentType*/ ctx[4][/*property*/ ctx[0]] == "list") return 0;
    		if (/*blockPropertiesComponentType*/ ctx[4][/*property*/ ctx[0]] == "checkbox") return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let $editorSelectedBlock;
    	validate_store(editorSelectedBlock, 'editorSelectedBlock');
    	component_subscribe($$self, editorSelectedBlock, $$value => $$invalidate(9, $editorSelectedBlock = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('BlockProperty', slots, []);
    	let { property } = $$props;
    	let { formatPropertyName } = $$props;
    	let { parent = $editorSelectedBlock } = $$props;

    	var blockPropertiesComponentType = {
    		environment: "list",
    		right_side: "checkbox",
    		left_side: "checkbox"
    	};

    	var blockPropertiesValueLists = {};
    	let environmentValueList = [];

    	for (let environment in Client$1.race.Constants.environments) {
    		environmentValueList.push({
    			label: formatPropertyName(environment),
    			value: Client$1.race.Constants.environments[environment]
    		});
    	}

    	blockPropertiesValueLists.environment = environmentValueList;

    	let changeProperty = function (propertyName, newValue) {
    		Client$1.phaser.editor.setSelectedProperty(parent, propertyName, newValue);
    	};

    	const writable_props = ['property', 'formatPropertyName', 'parent'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BlockProperty> was created with unknown prop '${key}'`);
    	});

    	const change_handler = event => {
    		changeProperty(property, event.detail.value);
    	};

    	const change_handler_1 = event => {
    		changeProperty(property, event.detail.value);
    	};

    	const change_handler_2 = event => {
    		changeProperty(property, event.detail.value);
    	};

    	$$self.$$set = $$props => {
    		if ('property' in $$props) $$invalidate(0, property = $$props.property);
    		if ('formatPropertyName' in $$props) $$invalidate(1, formatPropertyName = $$props.formatPropertyName);
    		if ('parent' in $$props) $$invalidate(2, parent = $$props.parent);
    	};

    	$$self.$capture_state = () => ({
    		Client: Client$1,
    		editorSelectedBlock,
    		PointerzInput,
    		PointerzSelect,
    		PointerzCheckbox,
    		property,
    		formatPropertyName,
    		parent,
    		blockPropertiesComponentType,
    		blockPropertiesValueLists,
    		environmentValueList,
    		changeProperty,
    		$editorSelectedBlock
    	});

    	$$self.$inject_state = $$props => {
    		if ('property' in $$props) $$invalidate(0, property = $$props.property);
    		if ('formatPropertyName' in $$props) $$invalidate(1, formatPropertyName = $$props.formatPropertyName);
    		if ('parent' in $$props) $$invalidate(2, parent = $$props.parent);
    		if ('blockPropertiesComponentType' in $$props) $$invalidate(4, blockPropertiesComponentType = $$props.blockPropertiesComponentType);
    		if ('blockPropertiesValueLists' in $$props) $$invalidate(3, blockPropertiesValueLists = $$props.blockPropertiesValueLists);
    		if ('environmentValueList' in $$props) environmentValueList = $$props.environmentValueList;
    		if ('changeProperty' in $$props) $$invalidate(5, changeProperty = $$props.changeProperty);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		property,
    		formatPropertyName,
    		parent,
    		blockPropertiesValueLists,
    		blockPropertiesComponentType,
    		changeProperty,
    		change_handler,
    		change_handler_1,
    		change_handler_2
    	];
    }

    class BlockProperty extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {
    			property: 0,
    			formatPropertyName: 1,
    			parent: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BlockProperty",
    			options,
    			id: create_fragment$8.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*property*/ ctx[0] === undefined && !('property' in props)) {
    			console.warn("<BlockProperty> was created without expected prop 'property'");
    		}

    		if (/*formatPropertyName*/ ctx[1] === undefined && !('formatPropertyName' in props)) {
    			console.warn("<BlockProperty> was created without expected prop 'formatPropertyName'");
    		}
    	}

    	get property() {
    		throw new Error("<BlockProperty>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set property(value) {
    		throw new Error("<BlockProperty>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get formatPropertyName() {
    		throw new Error("<BlockProperty>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set formatPropertyName(value) {
    		throw new Error("<BlockProperty>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get parent() {
    		throw new Error("<BlockProperty>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set parent(value) {
    		throw new Error("<BlockProperty>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\client\svelte\components\editor\BlockPropertiesPanel.svelte generated by Svelte v3.50.1 */
    const file$7 = "src\\client\\svelte\\components\\editor\\BlockPropertiesPanel.svelte";

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[27] = list[i];
    	child_ctx[23] = i;
    	return child_ctx;
    }

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[21] = list[i];
    	child_ctx[23] = i;
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[24] = list[i];
    	return child_ctx;
    }

    // (131:4) {:else}
    function create_else_block$1(ctx) {
    	let div;
    	let t0_value = /*formatPropertyName*/ ctx[12](/*selectedPredefinedBlockConstants*/ ctx[3].TYPE) + "";
    	let t0;
    	let t1;
    	let img;
    	let img_src_value;
    	let t2;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value_2 = /*selectedBlockPropertiesList*/ ctx[4];
    	validate_each_argument(each_value_2);
    	const get_key = ctx => /*selectedElement*/ ctx[2]._id + /*blockProperty*/ ctx[27];
    	validate_each_keys(ctx, each_value_2, get_each_context_2, get_key);

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		let child_ctx = get_each_context_2(ctx, each_value_2, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_2(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = text(" block\r\n        ");
    			img = element("img");
    			t2 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    			attr_dev(img, "alt", "customize");
    			if (!src_url_equal(img.src, img_src_value = "../../../assets/images/blockProperties/customize.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "class", "customizeImage svelte-191a60x");
    			add_location(img, file$7, 133, 8, 4691);
    			attr_dev(div, "class", "panelTitle svelte-191a60x");
    			add_location(div, file$7, 131, 6, 4582);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, img);
    			insert_dev(target, t2, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(img, "click", /*convertIntoCustom*/ ctx[13], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*selectedPredefinedBlockConstants*/ 8) && t0_value !== (t0_value = /*formatPropertyName*/ ctx[12](/*selectedPredefinedBlockConstants*/ ctx[3].TYPE) + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*selectedBlockPropertiesList, formatPropertyName, selectedElement*/ 4116) {
    				each_value_2 = /*selectedBlockPropertiesList*/ ctx[4];
    				validate_each_argument(each_value_2);
    				group_outros();
    				validate_each_keys(ctx, each_value_2, get_each_context_2, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_2, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_2, each_1_anchor, get_each_context_2);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(131:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (67:4) {#if isComponent}
    function create_if_block$4(ctx) {
    	let div2;
    	let div0;
    	let img0;
    	let img0_src_value;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5_value = /*formatPropertyName*/ ctx[12](/*selectedElement*/ ctx[2].shape) + "";
    	let t5;
    	let t6;
    	let div1;
    	let img1;
    	let img1_src_value;
    	let img1_style_value;
    	let div2_style_value;
    	let t7;
    	let if_block4_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*showAddMenu*/ ctx[1] && create_if_block_5(ctx);
    	let if_block1 = /*canDelete*/ ctx[7] && create_if_block_4(ctx);
    	let if_block2 = /*canMoveDown*/ ctx[9] && create_if_block_3(ctx);
    	let if_block3 = /*canMoveUp*/ ctx[8] && create_if_block_2$1(ctx);
    	let if_block4 = /*opened*/ ctx[0] && create_if_block_1$3(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			img0 = element("img");
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			if (if_block3) if_block3.c();
    			t4 = space();
    			t5 = text(t5_value);
    			t6 = space();
    			div1 = element("div");
    			img1 = element("img");
    			t7 = space();
    			if (if_block4) if_block4.c();
    			if_block4_anchor = empty();
    			attr_dev(img0, "alt", "add");
    			if (!src_url_equal(img0.src, img0_src_value = "../../../assets/images/blockProperties/addComponent.png")) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "class", "panelTitleImage leftImage svelte-191a60x");
    			add_location(img0, file$7, 69, 10, 2281);
    			attr_dev(div0, "class", "leftCommandsContainer svelte-191a60x");
    			add_location(div0, file$7, 68, 8, 2234);
    			attr_dev(img1, "alt", "arrow");
    			if (!src_url_equal(img1.src, img1_src_value = "../../../assets/images/blockProperties/arrow.png")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "style", img1_style_value = /*opened*/ ctx[0] && "transform: rotate(180deg)");
    			attr_dev(img1, "class", "panelTitleImage svelte-191a60x");
    			add_location(img1, file$7, 111, 10, 3878);
    			attr_dev(div1, "class", "rightCommandsContainer svelte-191a60x");
    			add_location(div1, file$7, 110, 8, 3830);
    			attr_dev(div2, "class", "panelTitle svelte-191a60x");
    			attr_dev(div2, "style", div2_style_value = !/*opened*/ ctx[0] && "margin-bottom: 0px;");
    			add_location(div2, file$7, 67, 6, 2159);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, img0);
    			append_dev(div0, t0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div0, t1);
    			if (if_block1) if_block1.m(div0, null);
    			append_dev(div0, t2);
    			if (if_block2) if_block2.m(div0, null);
    			append_dev(div0, t3);
    			if (if_block3) if_block3.m(div0, null);
    			append_dev(div2, t4);
    			append_dev(div2, t5);
    			append_dev(div2, t6);
    			append_dev(div2, div1);
    			append_dev(div1, img1);
    			insert_dev(target, t7, anchor);
    			if (if_block4) if_block4.m(target, anchor);
    			insert_dev(target, if_block4_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(img0, "click", /*addComponent*/ ctx[17], false, false, false),
    					listen_dev(img1, "click", /*openOrClose*/ ctx[19], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*showAddMenu*/ ctx[1]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*showAddMenu*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_5(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div0, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*canDelete*/ ctx[7]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_4(ctx);
    					if_block1.c();
    					if_block1.m(div0, t2);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*canMoveDown*/ ctx[9]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_3(ctx);
    					if_block2.c();
    					if_block2.m(div0, t3);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (/*canMoveUp*/ ctx[8]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block_2$1(ctx);
    					if_block3.c();
    					if_block3.m(div0, null);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if ((!current || dirty & /*selectedElement*/ 4) && t5_value !== (t5_value = /*formatPropertyName*/ ctx[12](/*selectedElement*/ ctx[2].shape) + "")) set_data_dev(t5, t5_value);

    			if (!current || dirty & /*opened*/ 1 && img1_style_value !== (img1_style_value = /*opened*/ ctx[0] && "transform: rotate(180deg)")) {
    				attr_dev(img1, "style", img1_style_value);
    			}

    			if (!current || dirty & /*opened*/ 1 && div2_style_value !== (div2_style_value = !/*opened*/ ctx[0] && "margin-bottom: 0px;")) {
    				attr_dev(div2, "style", div2_style_value);
    			}

    			if (/*opened*/ ctx[0]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty & /*opened*/ 1) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_1$3(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block4);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block4);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (detaching) detach_dev(t7);
    			if (if_block4) if_block4.d(detaching);
    			if (detaching) detach_dev(if_block4_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(67:4) {#if isComponent}",
    		ctx
    	});

    	return block;
    }

    // (140:6) {#each selectedBlockPropertiesList as blockProperty, index (selectedElement._id + blockProperty)}
    function create_each_block_2(key_1, ctx) {
    	let first;
    	let blockproperty;
    	let current;

    	blockproperty = new BlockProperty({
    			props: {
    				property: /*blockProperty*/ ctx[27],
    				formatPropertyName: /*formatPropertyName*/ ctx[12],
    				parent: /*selectedElement*/ ctx[2]
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(blockproperty.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(blockproperty, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const blockproperty_changes = {};
    			if (dirty & /*selectedBlockPropertiesList*/ 16) blockproperty_changes.property = /*blockProperty*/ ctx[27];
    			if (dirty & /*selectedElement*/ 4) blockproperty_changes.parent = /*selectedElement*/ ctx[2];
    			blockproperty.$set(blockproperty_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(blockproperty.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(blockproperty.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(blockproperty, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(140:6) {#each selectedBlockPropertiesList as blockProperty, index (selectedElement._id + blockProperty)}",
    		ctx
    	});

    	return block;
    }

    // (75:10) {#if showAddMenu}
    function create_if_block_5(ctx) {
    	let div;
    	let current;
    	let each_value_1 = /*componentsTypeList*/ ctx[11];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "showAddMenuContainer svelte-191a60x");
    			add_location(div, file$7, 75, 12, 2513);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*addSelectedTypeComponent, componentsTypeList*/ 264192) {
    				each_value_1 = /*componentsTypeList*/ ctx[11];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(75:10) {#if showAddMenu}",
    		ctx
    	});

    	return block;
    }

    // (77:14) {#each componentsTypeList as componentType}
    function create_each_block_1(ctx) {
    	let div;
    	let t0_value = /*componentType*/ ctx[24] + "";
    	let t0;
    	let t1;
    	let div_transition;
    	let current;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[20](/*componentType*/ ctx[24]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(div, "class", "showAddMenuComponent svelte-191a60x");
    			add_location(div, file$7, 77, 16, 2624);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {}, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {}, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching && div_transition) div_transition.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(77:14) {#each componentsTypeList as componentType}",
    		ctx
    	});

    	return block;
    }

    // (87:10) {#if canDelete}
    function create_if_block_4(ctx) {
    	let img;
    	let img_src_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "alt", "delete");
    			if (!src_url_equal(img.src, img_src_value = "../../../assets/images/blockProperties/deleteComponent.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "class", "panelTitleImage leftImage svelte-191a60x");
    			add_location(img, file$7, 87, 12, 2949);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);

    			if (!mounted) {
    				dispose = listen_dev(img, "click", /*deleteComponent*/ ctx[16], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(87:10) {#if canDelete}",
    		ctx
    	});

    	return block;
    }

    // (94:10) {#if canMoveDown}
    function create_if_block_3(ctx) {
    	let img;
    	let img_src_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "alt", "moveDown");
    			if (!src_url_equal(img.src, img_src_value = "../../../assets/images/blockProperties/moveComponent.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "class", "panelTitleImage leftImage svelte-191a60x");
    			add_location(img, file$7, 94, 12, 3215);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);

    			if (!mounted) {
    				dispose = listen_dev(img, "click", /*moveComponentDown*/ ctx[15], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(94:10) {#if canMoveDown}",
    		ctx
    	});

    	return block;
    }

    // (101:10) {#if canMoveUp}
    function create_if_block_2$1(ctx) {
    	let img;
    	let img_src_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "alt", "moveUp");
    			if (!src_url_equal(img.src, img_src_value = "../../../assets/images/blockProperties/moveComponent.png")) attr_dev(img, "src", img_src_value);
    			set_style(img, "transform", "rotate(180deg)");
    			attr_dev(img, "class", "panelTitleImage leftImage svelte-191a60x");
    			add_location(img, file$7, 101, 12, 3481);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);

    			if (!mounted) {
    				dispose = listen_dev(img, "click", /*moveComponentUp*/ ctx[14], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(101:10) {#if canMoveUp}",
    		ctx
    	});

    	return block;
    }

    // (120:6) {#if opened}
    function create_if_block_1$3(ctx) {
    	let div;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let div_transition;
    	let current;
    	let each_value = /*componentTypes*/ ctx[10][/*selectedElement*/ ctx[2].shape].PROPERTIES;
    	validate_each_argument(each_value);
    	const get_key = ctx => /*selectedElement*/ ctx[2]._id + /*componentProperty*/ ctx[21];
    	validate_each_keys(ctx, each_value, get_each_context$3, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$3(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(div, file$7, 120, 8, 4170);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*componentTypes, selectedElement, componentIndex, formatPropertyName*/ 5188) {
    				each_value = /*componentTypes*/ ctx[10][/*selectedElement*/ ctx[2].shape].PROPERTIES;
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$3, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$3, null, get_each_context$3);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {}, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {}, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(120:6) {#if opened}",
    		ctx
    	});

    	return block;
    }

    // (122:10) {#each componentTypes[selectedElement.shape].PROPERTIES as componentProperty, index (selectedElement._id + componentProperty)}
    function create_each_block$3(key_1, ctx) {
    	let first;
    	let blockproperty;
    	let current;

    	blockproperty = new BlockProperty({
    			props: {
    				property: /*componentProperty*/ ctx[21],
    				parent: /*selectedElement*/ ctx[2],
    				componentIndex: /*componentIndex*/ ctx[6],
    				formatPropertyName: /*formatPropertyName*/ ctx[12]
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(blockproperty.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(blockproperty, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const blockproperty_changes = {};
    			if (dirty & /*selectedElement*/ 4) blockproperty_changes.property = /*componentProperty*/ ctx[21];
    			if (dirty & /*selectedElement*/ 4) blockproperty_changes.parent = /*selectedElement*/ ctx[2];
    			if (dirty & /*componentIndex*/ 64) blockproperty_changes.componentIndex = /*componentIndex*/ ctx[6];
    			blockproperty.$set(blockproperty_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(blockproperty.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(blockproperty.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(blockproperty, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(122:10) {#each componentTypes[selectedElement.shape].PROPERTIES as componentProperty, index (selectedElement._id + componentProperty)}",
    		ctx
    	});

    	return block;
    }

    // (66:2) <Cell>
    function create_default_slot$2(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$4, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*isComponent*/ ctx[5]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(66:2) <Cell>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let div;
    	let cell;
    	let current;

    	cell = new Cell({
    			props: {
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(cell.$$.fragment);
    			attr_dev(div, "class", "panel svelte-191a60x");
    			add_location(div, file$7, 64, 0, 2099);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(cell, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const cell_changes = {};

    			if (dirty & /*$$scope, selectedElement, componentIndex, opened, canMoveUp, canMoveDown, canDelete, showAddMenu, isComponent, selectedBlockPropertiesList, selectedPredefinedBlockConstants*/ 536871935) {
    				cell_changes.$$scope = { dirty, ctx };
    			}

    			cell.$set(cell_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cell.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cell.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(cell);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('BlockPropertiesPanel', slots, []);
    	let { selectedElement } = $$props;
    	let { selectedPredefinedBlockConstants = {} } = $$props;
    	let { selectedBlockPropertiesList = [] } = $$props;
    	var componentTypes = Client$1.race.Constants.componentTypes;
    	let { isComponent = false } = $$props;
    	let { componentIndex } = $$props;
    	let { opened = !isComponent } = $$props;
    	let { canDelete = true } = $$props;
    	let { canMoveUp = true } = $$props;
    	let { canMoveDown = true } = $$props;
    	let { showAddMenu = false } = $$props;
    	let componentsTypeList = [];

    	for (let componentName in Client$1.race.Constants.componentTypes) {
    		componentsTypeList.push(componentName);
    	}

    	let formatPropertyName = function (propertyName) {
    		return (propertyName.charAt(0).toUpperCase() + propertyName.slice(1).toLowerCase()).replaceAll("_", " ");
    	};

    	let convertIntoCustom = function () {
    		Client$1.phaser.playSound("blockSeparation");
    		Client$1.phaser.editor.convertSelectedBlockIntoCustomBlock();
    	};

    	let moveComponentUp = function () {
    		Client$1.phaser.playSound("blockModification");
    		Client$1.phaser.editor.moveComponent(selectedElement, false);
    	};

    	let moveComponentDown = function () {
    		Client$1.phaser.playSound("blockModification");
    		Client$1.phaser.editor.moveComponent(selectedElement, true);
    	};

    	let deleteComponent = function () {
    		Client$1.phaser.playSound("blockDeletion");
    		Client$1.phaser.editor.deleteComponent(selectedElement);
    	};

    	let addComponent = function () {
    		Client$1.phaser.playSound("checking");
    		$$invalidate(1, showAddMenu = true);
    	};

    	let addSelectedTypeComponent = function (selectedType) {
    		Client$1.phaser.playSound("blockModification");
    		$$invalidate(1, showAddMenu = false);
    		Client$1.phaser.editor.addComponent(selectedElement, selectedType);
    	};

    	let openOrClose = function () {
    		Client$1.phaser.playSound("buttonSelection");
    		$$invalidate(0, opened = !opened);
    	};

    	const writable_props = [
    		'selectedElement',
    		'selectedPredefinedBlockConstants',
    		'selectedBlockPropertiesList',
    		'isComponent',
    		'componentIndex',
    		'opened',
    		'canDelete',
    		'canMoveUp',
    		'canMoveDown',
    		'showAddMenu'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BlockPropertiesPanel> was created with unknown prop '${key}'`);
    	});

    	const click_handler = componentType => addSelectedTypeComponent(componentType);

    	$$self.$$set = $$props => {
    		if ('selectedElement' in $$props) $$invalidate(2, selectedElement = $$props.selectedElement);
    		if ('selectedPredefinedBlockConstants' in $$props) $$invalidate(3, selectedPredefinedBlockConstants = $$props.selectedPredefinedBlockConstants);
    		if ('selectedBlockPropertiesList' in $$props) $$invalidate(4, selectedBlockPropertiesList = $$props.selectedBlockPropertiesList);
    		if ('isComponent' in $$props) $$invalidate(5, isComponent = $$props.isComponent);
    		if ('componentIndex' in $$props) $$invalidate(6, componentIndex = $$props.componentIndex);
    		if ('opened' in $$props) $$invalidate(0, opened = $$props.opened);
    		if ('canDelete' in $$props) $$invalidate(7, canDelete = $$props.canDelete);
    		if ('canMoveUp' in $$props) $$invalidate(8, canMoveUp = $$props.canMoveUp);
    		if ('canMoveDown' in $$props) $$invalidate(9, canMoveDown = $$props.canMoveDown);
    		if ('showAddMenu' in $$props) $$invalidate(1, showAddMenu = $$props.showAddMenu);
    	};

    	$$self.$capture_state = () => ({
    		Client: Client$1,
    		slide,
    		BlockProperty,
    		Cell,
    		selectedElement,
    		selectedPredefinedBlockConstants,
    		selectedBlockPropertiesList,
    		componentTypes,
    		isComponent,
    		componentIndex,
    		opened,
    		canDelete,
    		canMoveUp,
    		canMoveDown,
    		showAddMenu,
    		componentsTypeList,
    		formatPropertyName,
    		convertIntoCustom,
    		moveComponentUp,
    		moveComponentDown,
    		deleteComponent,
    		addComponent,
    		addSelectedTypeComponent,
    		openOrClose
    	});

    	$$self.$inject_state = $$props => {
    		if ('selectedElement' in $$props) $$invalidate(2, selectedElement = $$props.selectedElement);
    		if ('selectedPredefinedBlockConstants' in $$props) $$invalidate(3, selectedPredefinedBlockConstants = $$props.selectedPredefinedBlockConstants);
    		if ('selectedBlockPropertiesList' in $$props) $$invalidate(4, selectedBlockPropertiesList = $$props.selectedBlockPropertiesList);
    		if ('componentTypes' in $$props) $$invalidate(10, componentTypes = $$props.componentTypes);
    		if ('isComponent' in $$props) $$invalidate(5, isComponent = $$props.isComponent);
    		if ('componentIndex' in $$props) $$invalidate(6, componentIndex = $$props.componentIndex);
    		if ('opened' in $$props) $$invalidate(0, opened = $$props.opened);
    		if ('canDelete' in $$props) $$invalidate(7, canDelete = $$props.canDelete);
    		if ('canMoveUp' in $$props) $$invalidate(8, canMoveUp = $$props.canMoveUp);
    		if ('canMoveDown' in $$props) $$invalidate(9, canMoveDown = $$props.canMoveDown);
    		if ('showAddMenu' in $$props) $$invalidate(1, showAddMenu = $$props.showAddMenu);
    		if ('componentsTypeList' in $$props) $$invalidate(11, componentsTypeList = $$props.componentsTypeList);
    		if ('formatPropertyName' in $$props) $$invalidate(12, formatPropertyName = $$props.formatPropertyName);
    		if ('convertIntoCustom' in $$props) $$invalidate(13, convertIntoCustom = $$props.convertIntoCustom);
    		if ('moveComponentUp' in $$props) $$invalidate(14, moveComponentUp = $$props.moveComponentUp);
    		if ('moveComponentDown' in $$props) $$invalidate(15, moveComponentDown = $$props.moveComponentDown);
    		if ('deleteComponent' in $$props) $$invalidate(16, deleteComponent = $$props.deleteComponent);
    		if ('addComponent' in $$props) $$invalidate(17, addComponent = $$props.addComponent);
    		if ('addSelectedTypeComponent' in $$props) $$invalidate(18, addSelectedTypeComponent = $$props.addSelectedTypeComponent);
    		if ('openOrClose' in $$props) $$invalidate(19, openOrClose = $$props.openOrClose);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		opened,
    		showAddMenu,
    		selectedElement,
    		selectedPredefinedBlockConstants,
    		selectedBlockPropertiesList,
    		isComponent,
    		componentIndex,
    		canDelete,
    		canMoveUp,
    		canMoveDown,
    		componentTypes,
    		componentsTypeList,
    		formatPropertyName,
    		convertIntoCustom,
    		moveComponentUp,
    		moveComponentDown,
    		deleteComponent,
    		addComponent,
    		addSelectedTypeComponent,
    		openOrClose,
    		click_handler
    	];
    }

    class BlockPropertiesPanel extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {
    			selectedElement: 2,
    			selectedPredefinedBlockConstants: 3,
    			selectedBlockPropertiesList: 4,
    			isComponent: 5,
    			componentIndex: 6,
    			opened: 0,
    			canDelete: 7,
    			canMoveUp: 8,
    			canMoveDown: 9,
    			showAddMenu: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BlockPropertiesPanel",
    			options,
    			id: create_fragment$7.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*selectedElement*/ ctx[2] === undefined && !('selectedElement' in props)) {
    			console.warn("<BlockPropertiesPanel> was created without expected prop 'selectedElement'");
    		}

    		if (/*componentIndex*/ ctx[6] === undefined && !('componentIndex' in props)) {
    			console.warn("<BlockPropertiesPanel> was created without expected prop 'componentIndex'");
    		}
    	}

    	get selectedElement() {
    		throw new Error("<BlockPropertiesPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedElement(value) {
    		throw new Error("<BlockPropertiesPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectedPredefinedBlockConstants() {
    		throw new Error("<BlockPropertiesPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedPredefinedBlockConstants(value) {
    		throw new Error("<BlockPropertiesPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectedBlockPropertiesList() {
    		throw new Error("<BlockPropertiesPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedBlockPropertiesList(value) {
    		throw new Error("<BlockPropertiesPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isComponent() {
    		throw new Error("<BlockPropertiesPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isComponent(value) {
    		throw new Error("<BlockPropertiesPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get componentIndex() {
    		throw new Error("<BlockPropertiesPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set componentIndex(value) {
    		throw new Error("<BlockPropertiesPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opened() {
    		throw new Error("<BlockPropertiesPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opened(value) {
    		throw new Error("<BlockPropertiesPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get canDelete() {
    		throw new Error("<BlockPropertiesPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set canDelete(value) {
    		throw new Error("<BlockPropertiesPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get canMoveUp() {
    		throw new Error("<BlockPropertiesPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set canMoveUp(value) {
    		throw new Error("<BlockPropertiesPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get canMoveDown() {
    		throw new Error("<BlockPropertiesPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set canMoveDown(value) {
    		throw new Error("<BlockPropertiesPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showAddMenu() {
    		throw new Error("<BlockPropertiesPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showAddMenu(value) {
    		throw new Error("<BlockPropertiesPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\client\svelte\components\editor\PanelContainer.svelte generated by Svelte v3.50.1 */
    const file$6 = "src\\client\\svelte\\components\\editor\\PanelContainer.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	child_ctx[7] = i;
    	return child_ctx;
    }

    // (33:0) {#if $editorSelectedBlock && $editorSelectedBlock.predefinedEditorBlockType}
    function create_if_block_1$2(ctx) {
    	let div;
    	let blockpropertiespanel;
    	let div_transition;
    	let current;

    	blockpropertiespanel = new BlockPropertiesPanel({
    			props: {
    				selectedElement: /*$editorSelectedBlock*/ ctx[3],
    				selectedPredefinedBlockConstants: /*selectedPredefinedBlockConstants*/ ctx[0],
    				selectedBlockPropertiesList: /*selectedBlockPropertiesList*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(blockpropertiespanel.$$.fragment);
    			attr_dev(div, "class", "panelsContainer svelte-12jjdmv");
    			add_location(div, file$6, 33, 2, 1188);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(blockpropertiespanel, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const blockpropertiespanel_changes = {};
    			if (dirty & /*$editorSelectedBlock*/ 8) blockpropertiespanel_changes.selectedElement = /*$editorSelectedBlock*/ ctx[3];
    			if (dirty & /*selectedPredefinedBlockConstants*/ 1) blockpropertiespanel_changes.selectedPredefinedBlockConstants = /*selectedPredefinedBlockConstants*/ ctx[0];
    			if (dirty & /*selectedBlockPropertiesList*/ 2) blockpropertiespanel_changes.selectedBlockPropertiesList = /*selectedBlockPropertiesList*/ ctx[1];
    			blockpropertiespanel.$set(blockpropertiespanel_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(blockpropertiespanel.$$.fragment, local);

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, scale, {}, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(blockpropertiespanel.$$.fragment, local);
    			if (!div_transition) div_transition = create_bidirectional_transition(div, scale, {}, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(blockpropertiespanel);
    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(33:0) {#if $editorSelectedBlock && $editorSelectedBlock.predefinedEditorBlockType}",
    		ctx
    	});

    	return block;
    }

    // (43:0) {#if $editorSelectedBlock && !$editorSelectedBlock.predefinedEditorBlockType}
    function create_if_block$3(ctx) {
    	let div;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let div_transition;
    	let current;
    	let each_value = /*selectedBlockComponents*/ ctx[2];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*$editorSelectedBlock*/ ctx[3]._id + /*selectedBlockComponent*/ ctx[5]._id;
    	validate_each_keys(ctx, each_value, get_each_context$2, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$2(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "panelsContainer svelte-12jjdmv");
    			add_location(div, file$6, 43, 2, 1496);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*selectedBlockComponents, $editorSelectedBlock*/ 12) {
    				each_value = /*selectedBlockComponents*/ ctx[2];
    				validate_each_argument(each_value);
    				group_outros();
    				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].r();
    				validate_each_keys(ctx, each_value, get_each_context$2, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, fix_and_outro_and_destroy_block, create_each_block$2, null, get_each_context$2);
    				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].a();
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, scale, {}, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			if (!div_transition) div_transition = create_bidirectional_transition(div, scale, {}, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(43:0) {#if $editorSelectedBlock && !$editorSelectedBlock.predefinedEditorBlockType}",
    		ctx
    	});

    	return block;
    }

    // (45:4) {#each selectedBlockComponents as selectedBlockComponent, index ($editorSelectedBlock._id + selectedBlockComponent._id)}
    function create_each_block$2(key_1, ctx) {
    	let div;
    	let blockpropertiespanel;
    	let t;
    	let rect;
    	let stop_animation = noop;
    	let current;

    	blockpropertiespanel = new BlockPropertiesPanel({
    			props: {
    				isComponent: true,
    				componentIndex: /*index*/ ctx[7],
    				canMoveUp: /*index*/ ctx[7] > 0,
    				canMoveDown: /*index*/ ctx[7] < /*$editorSelectedBlock*/ ctx[3].components.length - 1,
    				canDelete: /*$editorSelectedBlock*/ ctx[3].components.length > 1,
    				selectedElement: /*selectedBlockComponent*/ ctx[5]
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			div = element("div");
    			create_component(blockpropertiespanel.$$.fragment);
    			t = space();
    			add_location(div, file$6, 45, 6, 1676);
    			this.first = div;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(blockpropertiespanel, div, null);
    			append_dev(div, t);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const blockpropertiespanel_changes = {};
    			if (dirty & /*selectedBlockComponents*/ 4) blockpropertiespanel_changes.componentIndex = /*index*/ ctx[7];
    			if (dirty & /*selectedBlockComponents*/ 4) blockpropertiespanel_changes.canMoveUp = /*index*/ ctx[7] > 0;
    			if (dirty & /*selectedBlockComponents, $editorSelectedBlock*/ 12) blockpropertiespanel_changes.canMoveDown = /*index*/ ctx[7] < /*$editorSelectedBlock*/ ctx[3].components.length - 1;
    			if (dirty & /*$editorSelectedBlock*/ 8) blockpropertiespanel_changes.canDelete = /*$editorSelectedBlock*/ ctx[3].components.length > 1;
    			if (dirty & /*selectedBlockComponents*/ 4) blockpropertiespanel_changes.selectedElement = /*selectedBlockComponent*/ ctx[5];
    			blockpropertiespanel.$set(blockpropertiespanel_changes);
    		},
    		r: function measure() {
    			rect = div.getBoundingClientRect();
    		},
    		f: function fix() {
    			fix_position(div);
    			stop_animation();
    		},
    		a: function animate() {
    			stop_animation();
    			stop_animation = create_animation(div, rect, flip, {});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(blockpropertiespanel.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(blockpropertiespanel.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(blockpropertiespanel);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(45:4) {#each selectedBlockComponents as selectedBlockComponent, index ($editorSelectedBlock._id + selectedBlockComponent._id)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let t;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = /*$editorSelectedBlock*/ ctx[3] && /*$editorSelectedBlock*/ ctx[3].predefinedEditorBlockType && create_if_block_1$2(ctx);
    	let if_block1 = /*$editorSelectedBlock*/ ctx[3] && !/*$editorSelectedBlock*/ ctx[3].predefinedEditorBlockType && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$editorSelectedBlock*/ ctx[3] && /*$editorSelectedBlock*/ ctx[3].predefinedEditorBlockType) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*$editorSelectedBlock*/ 8) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*$editorSelectedBlock*/ ctx[3] && !/*$editorSelectedBlock*/ ctx[3].predefinedEditorBlockType) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*$editorSelectedBlock*/ 8) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$3(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let $editorSelectedBlock;
    	validate_store(editorSelectedBlock, 'editorSelectedBlock');
    	component_subscribe($$self, editorSelectedBlock, $$value => $$invalidate(3, $editorSelectedBlock = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PanelContainer', slots, []);
    	var selectedPredefinedBlockConstants = {};
    	var selectedBlockPropertiesList = [];
    	var selectedBlockComponents = [];

    	Client$1.svelte.updateSelectedBlock = function () {
    		set_store_value(editorSelectedBlock, $editorSelectedBlock = Client$1.phaser.editor.selectedBlock, $editorSelectedBlock);

    		if ($editorSelectedBlock) {
    			// For reactivity on array and objects
    			$$invalidate(2, selectedBlockComponents = $editorSelectedBlock.components);

    			$$invalidate(0, selectedPredefinedBlockConstants = $editorSelectedBlock.predefinedEditorBlockType);
    			selectedPredefinedBlockConstants && $$invalidate(1, selectedBlockPropertiesList = selectedPredefinedBlockConstants.PROPERTIES);
    		} else {
    			$$invalidate(0, selectedPredefinedBlockConstants = {});
    			$$invalidate(1, selectedBlockPropertiesList = []);
    			$$invalidate(2, selectedBlockComponents = []);
    		}
    	};

    	Client$1.svelte.updateSelectedBlock();
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PanelContainer> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		scale,
    		flip,
    		Client: Client$1,
    		editorSelectedBlock,
    		BlockPropertiesPanel,
    		selectedPredefinedBlockConstants,
    		selectedBlockPropertiesList,
    		selectedBlockComponents,
    		$editorSelectedBlock
    	});

    	$$self.$inject_state = $$props => {
    		if ('selectedPredefinedBlockConstants' in $$props) $$invalidate(0, selectedPredefinedBlockConstants = $$props.selectedPredefinedBlockConstants);
    		if ('selectedBlockPropertiesList' in $$props) $$invalidate(1, selectedBlockPropertiesList = $$props.selectedBlockPropertiesList);
    		if ('selectedBlockComponents' in $$props) $$invalidate(2, selectedBlockComponents = $$props.selectedBlockComponents);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		selectedPredefinedBlockConstants,
    		selectedBlockPropertiesList,
    		selectedBlockComponents,
    		$editorSelectedBlock
    	];
    }

    class PanelContainer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PanelContainer",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    /* src\client\svelte\components\editor\EditorBlockbarComponent.svelte generated by Svelte v3.50.1 */
    const file$5 = "src\\client\\svelte\\components\\editor\\EditorBlockbarComponent.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    // (57:20) 
    function create_if_block_1$1(ctx) {
    	let div2;
    	let div0;
    	let img;
    	let img_src_value;
    	let t0;
    	let div1;
    	let t1_value = /*formatBlockbarName*/ ctx[7](/*blocksMenu*/ ctx[1].name) + "";
    	let t1;
    	let t2;
    	let div2_class_value;
    	let div2_transition;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*blocksMenu*/ ctx[1].subMenu && create_if_block_2(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			img = element("img");
    			t0 = space();
    			div1 = element("div");
    			t1 = text(t1_value);
    			t2 = space();
    			if (if_block) if_block.c();
    			attr_dev(img, "alt", "blockbarImage");
    			if (!src_url_equal(img.src, img_src_value = /*imagesPath*/ ctx[5] + /*blocksMenu*/ ctx[1].name + ".png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "class", "blockbarImage svelte-1wymftd");
    			add_location(img, file$5, 63, 6, 2076);
    			attr_dev(div0, "class", "blockbarImageContainer svelte-1wymftd");
    			add_location(div0, file$5, 62, 4, 2032);
    			attr_dev(div1, "class", "blockbarLabel svelte-1wymftd");
    			add_location(div1, file$5, 68, 4, 2214);

    			attr_dev(div2, "class", div2_class_value = "" + (null_to_empty("blockComponent " + (/*$editorMenuLastClick*/ ctx[3].name == /*blocksMenu*/ ctx[1].name
    			? "selectedBlock"
    			: "")) + " svelte-1wymftd"));

    			add_location(div2, file$5, 57, 2, 1840);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, img);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, t1);
    			append_dev(div2, t2);
    			if (if_block) if_block.m(div2, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div2, "click", stop_propagation(/*onComponentClick*/ ctx[8]), false, false, true);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*blocksMenu*/ 2 && !src_url_equal(img.src, img_src_value = /*imagesPath*/ ctx[5] + /*blocksMenu*/ ctx[1].name + ".png")) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if ((!current || dirty & /*blocksMenu*/ 2) && t1_value !== (t1_value = /*formatBlockbarName*/ ctx[7](/*blocksMenu*/ ctx[1].name) + "")) set_data_dev(t1, t1_value);

    			if (/*blocksMenu*/ ctx[1].subMenu) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*blocksMenu*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div2, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*$editorMenuLastClick, blocksMenu*/ 10 && div2_class_value !== (div2_class_value = "" + (null_to_empty("blockComponent " + (/*$editorMenuLastClick*/ ctx[3].name == /*blocksMenu*/ ctx[1].name
    			? "selectedBlock"
    			: "")) + " svelte-1wymftd"))) {
    				attr_dev(div2, "class", div2_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);

    			add_render_callback(() => {
    				if (!div2_transition) div2_transition = create_bidirectional_transition(div2, scale, {}, true);
    				div2_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			if (!div2_transition) div2_transition = create_bidirectional_transition(div2, scale, {}, false);
    			div2_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (if_block) if_block.d();
    			if (detaching && div2_transition) div2_transition.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(57:20) ",
    		ctx
    	});

    	return block;
    }

    // (47:0) {#if isArrayOfComponents}
    function create_if_block$2(ctx) {
    	let div;
    	let div_style_value;
    	let current;
    	let each_value = /*blocksMenu*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "blocksContainer svelte-1wymftd");
    			attr_dev(div, "style", div_style_value = "bottom:" + (menuHeightPerDepth + css.default.margin) * /*menuDepth*/ ctx[0] + "px;");
    			add_location(div, file$5, 47, 2, 1554);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*blocksMenu, menuDepth, directParent*/ 7) {
    				each_value = /*blocksMenu*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty & /*menuDepth*/ 1 && div_style_value !== (div_style_value = "bottom:" + (menuHeightPerDepth + css.default.margin) * /*menuDepth*/ ctx[0] + "px;")) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(47:0) {#if isArrayOfComponents}",
    		ctx
    	});

    	return block;
    }

    // (72:4) {#if blocksMenu.subMenu}
    function create_if_block_2(ctx) {
    	let editorblockbarcomponent;
    	let current;

    	editorblockbarcomponent = new EditorBlockbarComponent({
    			props: {
    				blocksMenu: /*blocksMenu*/ ctx[1].subMenu,
    				directParent: /*blocksMenu*/ ctx[1].name,
    				menuDepth: /*menuDepth*/ ctx[0] + 1
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(editorblockbarcomponent.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(editorblockbarcomponent, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const editorblockbarcomponent_changes = {};
    			if (dirty & /*blocksMenu*/ 2) editorblockbarcomponent_changes.blocksMenu = /*blocksMenu*/ ctx[1].subMenu;
    			if (dirty & /*blocksMenu*/ 2) editorblockbarcomponent_changes.directParent = /*blocksMenu*/ ctx[1].name;
    			if (dirty & /*menuDepth*/ 1) editorblockbarcomponent_changes.menuDepth = /*menuDepth*/ ctx[0] + 1;
    			editorblockbarcomponent.$set(editorblockbarcomponent_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(editorblockbarcomponent.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(editorblockbarcomponent.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(editorblockbarcomponent, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(72:4) {#if blocksMenu.subMenu}",
    		ctx
    	});

    	return block;
    }

    // (53:4) {#each blocksMenu as block}
    function create_each_block$1(ctx) {
    	let editorblockbarcomponent;
    	let current;

    	editorblockbarcomponent = new EditorBlockbarComponent({
    			props: {
    				blocksMenu: /*block*/ ctx[9],
    				menuDepth: /*menuDepth*/ ctx[0],
    				directParent: /*directParent*/ ctx[2]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(editorblockbarcomponent.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(editorblockbarcomponent, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const editorblockbarcomponent_changes = {};
    			if (dirty & /*blocksMenu*/ 2) editorblockbarcomponent_changes.blocksMenu = /*block*/ ctx[9];
    			if (dirty & /*menuDepth*/ 1) editorblockbarcomponent_changes.menuDepth = /*menuDepth*/ ctx[0];
    			if (dirty & /*directParent*/ 4) editorblockbarcomponent_changes.directParent = /*directParent*/ ctx[2];
    			editorblockbarcomponent.$set(editorblockbarcomponent_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(editorblockbarcomponent.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(editorblockbarcomponent.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(editorblockbarcomponent, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(53:4) {#each blocksMenu as block}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$2, create_if_block_1$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (dirty & /*hidden*/ 16) show_if = null;
    		if (/*isArrayOfComponents*/ ctx[6]) return 0;
    		if (show_if == null) show_if = !!!/*hidden*/ ctx[4]();
    		if (show_if) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx, -1))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const menuHeightPerDepth = 64;

    function instance$5($$self, $$props, $$invalidate) {
    	let hidden;
    	let $editorMenuLastClick;
    	validate_store(editorMenuLastClick, 'editorMenuLastClick');
    	component_subscribe($$self, editorMenuLastClick, $$value => $$invalidate(3, $editorMenuLastClick = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EditorBlockbarComponent', slots, []);
    	let imagesPath = "../../../assets/images/blockbar/";
    	let { menuDepth = 0 } = $$props;
    	let { blocksMenu } = $$props;
    	let { directParent = "" } = $$props;
    	let isArrayOfComponents = Array.isArray(blocksMenu);

    	let formatBlockbarName = function (name) {
    		return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
    	};

    	let onComponentClick = function () {
    		Client$1.phaser.playSound("menuSelection");

    		$editorMenuLastClick.name == blocksMenu.name
    		? Client$1.svelte.resetSelectedBlockType()
    		: set_store_value(editorMenuLastClick, $editorMenuLastClick = { name: blocksMenu.name, directParent }, $editorMenuLastClick);

    		if (!blocksMenu.subMenu) {
    			Client$1.phaser.editor.deletePlacedBlock();
    			Client$1.phaser.editor.placeNewBlock(blocksMenu.name, directParent == "DRAW");
    		}
    	};

    	const writable_props = ['menuDepth', 'blocksMenu', 'directParent'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EditorBlockbarComponent> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('menuDepth' in $$props) $$invalidate(0, menuDepth = $$props.menuDepth);
    		if ('blocksMenu' in $$props) $$invalidate(1, blocksMenu = $$props.blocksMenu);
    		if ('directParent' in $$props) $$invalidate(2, directParent = $$props.directParent);
    	};

    	$$self.$capture_state = () => ({
    		scale,
    		css,
    		Client: Client$1,
    		editorMenuLastClick,
    		menuHeightPerDepth,
    		imagesPath,
    		menuDepth,
    		blocksMenu,
    		directParent,
    		isArrayOfComponents,
    		formatBlockbarName,
    		onComponentClick,
    		hidden,
    		$editorMenuLastClick
    	});

    	$$self.$inject_state = $$props => {
    		if ('imagesPath' in $$props) $$invalidate(5, imagesPath = $$props.imagesPath);
    		if ('menuDepth' in $$props) $$invalidate(0, menuDepth = $$props.menuDepth);
    		if ('blocksMenu' in $$props) $$invalidate(1, blocksMenu = $$props.blocksMenu);
    		if ('directParent' in $$props) $$invalidate(2, directParent = $$props.directParent);
    		if ('isArrayOfComponents' in $$props) $$invalidate(6, isArrayOfComponents = $$props.isArrayOfComponents);
    		if ('formatBlockbarName' in $$props) $$invalidate(7, formatBlockbarName = $$props.formatBlockbarName);
    		if ('onComponentClick' in $$props) $$invalidate(8, onComponentClick = $$props.onComponentClick);
    		if ('hidden' in $$props) $$invalidate(4, hidden = $$props.hidden);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*menuDepth, $editorMenuLastClick, directParent, blocksMenu*/ 15) {
    			// TODO : le menu ne marche pas pour plus d'un niveau -> il faut rajouter plusieurs conditions = vérifier si l'élément cliqué est un des enfants (récursif) + vérifier si c'est un frère ou soeur (= même parent)
    			$$invalidate(4, hidden = () => {
    				let show = menuDepth == 0 || $editorMenuLastClick.name == directParent || $editorMenuLastClick.name == blocksMenu.name || $editorMenuLastClick.directParent == directParent;
    				return !show;
    			});
    		}
    	};

    	return [
    		menuDepth,
    		blocksMenu,
    		directParent,
    		$editorMenuLastClick,
    		hidden,
    		imagesPath,
    		isArrayOfComponents,
    		formatBlockbarName,
    		onComponentClick
    	];
    }

    class EditorBlockbarComponent extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
    			menuDepth: 0,
    			blocksMenu: 1,
    			directParent: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EditorBlockbarComponent",
    			options,
    			id: create_fragment$5.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*blocksMenu*/ ctx[1] === undefined && !('blocksMenu' in props)) {
    			console.warn("<EditorBlockbarComponent> was created without expected prop 'blocksMenu'");
    		}
    	}

    	get menuDepth() {
    		throw new Error("<EditorBlockbarComponent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set menuDepth(value) {
    		throw new Error("<EditorBlockbarComponent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get blocksMenu() {
    		throw new Error("<EditorBlockbarComponent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set blocksMenu(value) {
    		throw new Error("<EditorBlockbarComponent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get directParent() {
    		throw new Error("<EditorBlockbarComponent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set directParent(value) {
    		throw new Error("<EditorBlockbarComponent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\client\svelte\components\editor\EditorBlockbar.svelte generated by Svelte v3.50.1 */
    const file$4 = "src\\client\\svelte\\components\\editor\\EditorBlockbar.svelte";

    function create_fragment$4(ctx) {
    	let div;
    	let editorblockbarcomponent;
    	let current;

    	editorblockbarcomponent = new EditorBlockbarComponent({
    			props: { blocksMenu: /*blocksMenu*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(editorblockbarcomponent.$$.fragment);
    			attr_dev(div, "class", "blockbarContainer svelte-13lzkgx");
    			add_location(div, file$4, 33, 0, 739);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(editorblockbarcomponent, div, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(editorblockbarcomponent.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(editorblockbarcomponent.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(editorblockbarcomponent);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let $editorMenuLastClick;
    	validate_store(editorMenuLastClick, 'editorMenuLastClick');
    	component_subscribe($$self, editorMenuLastClick, $$value => $$invalidate(1, $editorMenuLastClick = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EditorBlockbar', slots, []);

    	let blocksMenu = [
    		{
    			name: "STRUCTURE",
    			subMenu: [{ name: "STRAIGHT" }, { name: "TURN" }]
    		},
    		{
    			name: "RACE",
    			subMenu: [
    				{ name: "CHECKPOINT" },
    				{ name: "START" },
    				{ name: "END" },
    				{ name: "MULTILAP" }
    			]
    		},
    		{
    			name: "EFFECTS",
    			subMenu: [{ name: "BOOST" }]
    		},
    		{
    			name: "DRAW",
    			subMenu: [{ name: "LINE" }, { name: "ARC" }]
    		}
    	];

    	Client.svelte.resetSelectedBlockType = function () {
    		set_store_value(editorMenuLastClick, $editorMenuLastClick = { name: "" }, $editorMenuLastClick);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EditorBlockbar> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		EditorBlockbarComponent,
    		editorMenuLastClick,
    		blocksMenu,
    		$editorMenuLastClick
    	});

    	$$self.$inject_state = $$props => {
    		if ('blocksMenu' in $$props) $$invalidate(0, blocksMenu = $$props.blocksMenu);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [blocksMenu];
    }

    class EditorBlockbar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EditorBlockbar",
    			options,
    			id: create_fragment$4.name
    		});
    	}
    }

    /* src\client\svelte\components\editor\EditorCircuitActionsMenu.svelte generated by Svelte v3.50.1 */
    const file$3 = "src\\client\\svelte\\components\\editor\\EditorCircuitActionsMenu.svelte";

    // (87:2) <PointerzConfirm      color="green"      confirmTitle="Save and leave"      cancelTitle="Leave without saving"      let:confirm={confirmThis}      cancelFunction={() => {        Client.phaser.playSound("cancelClick");        leaveEditor();      }}      showConfirm={!circuitSaved}>
    function create_default_slot_1$1(ctx) {
    	let div;
    	let img;
    	let img_src_value;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[7](/*confirmThis*/ ctx[14]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			img = element("img");
    			attr_dev(img, "class", "actionImage svelte-1eho0cl");
    			attr_dev(img, "alt", "actionImage");
    			if (!src_url_equal(img.src, img_src_value = /*imagesPath*/ ctx[3] + "back.png")) attr_dev(img, "src", img_src_value);
    			add_location(img, file$3, 99, 6, 2909);
    			attr_dev(div, "class", "actionContainer svelte-1eho0cl");
    			add_location(div, file$3, 96, 4, 2809);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, img);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(87:2) <PointerzConfirm      color=\\\"green\\\"      confirmTitle=\\\"Save and leave\\\"      cancelTitle=\\\"Leave without saving\\\"      let:confirm={confirmThis}      cancelFunction={() => {        Client.phaser.playSound(\\\"cancelClick\\\");        leaveEditor();      }}      showConfirm={!circuitSaved}>",
    		ctx
    	});

    	return block;
    }

    // (105:4) 
    function create_title_slot_1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Do you really want to leave the editor without saving changes ?";
    			attr_dev(span, "slot", "title");
    			add_location(span, file$3, 104, 4, 3029);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot_1.name,
    		type: "slot",
    		source: "(105:4) ",
    		ctx
    	});

    	return block;
    }

    // (130:2) <PointerzConfirm      color="red"      confirmTitle={circuitSaved && circuitValidated        ? "Publish"        : "Save and validate"}      cancelTitle="Cancel"      let:confirm={confirmThis}>
    function create_default_slot$1(ctx) {
    	let div;
    	let img;
    	let img_src_value;
    	let mounted;
    	let dispose;

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[9](/*confirmThis*/ ctx[14]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			img = element("img");
    			attr_dev(img, "class", "actionImage svelte-1eho0cl");
    			attr_dev(img, "alt", "actionImage");
    			if (!src_url_equal(img.src, img_src_value = /*imagesPath*/ ctx[3] + "share.png")) attr_dev(img, "src", img_src_value);
    			add_location(img, file$3, 144, 6, 4358);
    			attr_dev(div, "class", "actionContainer svelte-1eho0cl");
    			add_location(div, file$3, 136, 4, 4134);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, img);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler_1, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(130:2) <PointerzConfirm      color=\\\"red\\\"      confirmTitle={circuitSaved && circuitValidated        ? \\\"Publish\\\"        : \\\"Save and validate\\\"}      cancelTitle=\\\"Cancel\\\"      let:confirm={confirmThis}>",
    		ctx
    	});

    	return block;
    }

    // (150:4) 
    function create_title_slot(ctx) {
    	let span;

    	let t_value = (/*circuitSaved*/ ctx[1] && /*circuitValidated*/ ctx[2]
    	? "Publishing circuit"
    	: "Error publishing circuit") + "";

    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "slot", "title");
    			add_location(span, file$3, 149, 4, 4479);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*circuitSaved, circuitValidated*/ 6 && t_value !== (t_value = (/*circuitSaved*/ ctx[1] && /*circuitValidated*/ ctx[2]
    			? "Publishing circuit"
    			: "Error publishing circuit") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot.name,
    		type: "slot",
    		source: "(150:4) ",
    		ctx
    	});

    	return block;
    }

    // (155:4) 
    function create_description_slot(ctx) {
    	let span;

    	let t_value = (/*circuitSaved*/ ctx[1] && /*circuitValidated*/ ctx[2]
    	? "Do you really want to publish your circuit in the weekly list ?"
    	: "In order to publish your circuit, you need to save and validate it (author race time).") + "";

    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "slot", "description");
    			add_location(span, file$3, 154, 4, 4629);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*circuitSaved, circuitValidated*/ 6 && t_value !== (t_value = (/*circuitSaved*/ ctx[1] && /*circuitValidated*/ ctx[2]
    			? "Do you really want to publish your circuit in the weekly list ?"
    			: "In order to publish your circuit, you need to save and validate it (author race time).") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_description_slot.name,
    		type: "slot",
    		source: "(155:4) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let div4;
    	let pointerzconfirm0;
    	let t0;
    	let div1;
    	let img0;
    	let img0_src_value;
    	let t1;
    	let div0;
    	let img1;
    	let img1_src_value;
    	let t2;
    	let div3;
    	let img2;
    	let img2_src_value;
    	let t3;
    	let div2;
    	let img3;
    	let img3_src_value;
    	let t4;
    	let pointerzconfirm1;
    	let current;
    	let mounted;
    	let dispose;

    	pointerzconfirm0 = new PointerzConfirm({
    			props: {
    				color: "green",
    				confirmTitle: "Save and leave",
    				cancelTitle: "Leave without saving",
    				cancelFunction: /*func*/ ctx[8],
    				showConfirm: !/*circuitSaved*/ ctx[1],
    				$$slots: {
    					title: [
    						create_title_slot_1,
    						({ confirm: confirmThis }) => ({ 14: confirmThis }),
    						({ confirm: confirmThis }) => confirmThis ? 16384 : 0
    					],
    					default: [
    						create_default_slot_1$1,
    						({ confirm: confirmThis }) => ({ 14: confirmThis }),
    						({ confirm: confirmThis }) => confirmThis ? 16384 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pointerzconfirm1 = new PointerzConfirm({
    			props: {
    				color: "red",
    				confirmTitle: /*circuitSaved*/ ctx[1] && /*circuitValidated*/ ctx[2]
    				? "Publish"
    				: "Save and validate",
    				cancelTitle: "Cancel",
    				$$slots: {
    					description: [
    						create_description_slot,
    						({ confirm: confirmThis }) => ({ 14: confirmThis }),
    						({ confirm: confirmThis }) => confirmThis ? 16384 : 0
    					],
    					title: [
    						create_title_slot,
    						({ confirm: confirmThis }) => ({ 14: confirmThis }),
    						({ confirm: confirmThis }) => confirmThis ? 16384 : 0
    					],
    					default: [
    						create_default_slot$1,
    						({ confirm: confirmThis }) => ({ 14: confirmThis }),
    						({ confirm: confirmThis }) => confirmThis ? 16384 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			create_component(pointerzconfirm0.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			img0 = element("img");
    			t1 = space();
    			div0 = element("div");
    			img1 = element("img");
    			t2 = space();
    			div3 = element("div");
    			img2 = element("img");
    			t3 = space();
    			div2 = element("div");
    			img3 = element("img");
    			t4 = space();
    			create_component(pointerzconfirm1.$$.fragment);
    			attr_dev(img0, "class", "actionImage svelte-1eho0cl");
    			attr_dev(img0, "alt", "actionImage");
    			if (!src_url_equal(img0.src, img0_src_value = /*imagesPath*/ ctx[3] + "save.png")) attr_dev(img0, "src", img0_src_value);
    			add_location(img0, file$3, 109, 4, 3225);
    			attr_dev(img1, "class", "actionImageState svelte-1eho0cl");
    			attr_dev(img1, "alt", "actionImageState");
    			if (!src_url_equal(img1.src, img1_src_value = /*imagesPath*/ ctx[3] + (/*circuitSaved*/ ctx[1] ? "saved.png" : "unsaved.png"))) attr_dev(img1, "src", img1_src_value);
    			add_location(img1, file$3, 111, 6, 3353);
    			attr_dev(div0, "class", "actionImageStateContainer svelte-1eho0cl");
    			add_location(div0, file$3, 110, 4, 3306);
    			attr_dev(div1, "class", "actionContainer svelte-1eho0cl");
    			add_location(div1, file$3, 108, 2, 3158);
    			attr_dev(img2, "class", "actionImage svelte-1eho0cl");
    			attr_dev(img2, "alt", "actionImage");
    			if (!src_url_equal(img2.src, img2_src_value = /*imagesPath*/ ctx[3] + "raceTest.png")) attr_dev(img2, "src", img2_src_value);
    			add_location(img2, file$3, 118, 4, 3607);
    			attr_dev(img3, "class", "actionImageState svelte-1eho0cl");
    			attr_dev(img3, "alt", "actionImageState");

    			if (!src_url_equal(img3.src, img3_src_value = /*imagesPath*/ ctx[3] + (/*circuitValidated*/ ctx[2]
    			? "saved.png"
    			: "unsaved.png"))) attr_dev(img3, "src", img3_src_value);

    			add_location(img3, file$3, 123, 6, 3760);
    			attr_dev(div2, "class", "actionImageStateContainer svelte-1eho0cl");
    			add_location(div2, file$3, 122, 4, 3713);
    			attr_dev(div3, "class", "actionContainer svelte-1eho0cl");
    			add_location(div3, file$3, 117, 2, 3525);
    			attr_dev(div4, "class", "actionsMenuContainer svelte-1eho0cl");
    			add_location(div4, file$3, 85, 0, 2484);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			mount_component(pointerzconfirm0, div4, null);
    			append_dev(div4, t0);
    			append_dev(div4, div1);
    			append_dev(div1, img0);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			append_dev(div0, img1);
    			append_dev(div4, t2);
    			append_dev(div4, div3);
    			append_dev(div3, img2);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			append_dev(div2, img3);
    			append_dev(div4, t4);
    			mount_component(pointerzconfirm1, div4, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div1, "click", /*actionFunctions*/ ctx[4].save, false, false, false),
    					listen_dev(div3, "click", /*actionFunctions*/ ctx[4].startValidationRace, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const pointerzconfirm0_changes = {};
    			if (dirty & /*Client*/ 1) pointerzconfirm0_changes.cancelFunction = /*func*/ ctx[8];
    			if (dirty & /*circuitSaved*/ 2) pointerzconfirm0_changes.showConfirm = !/*circuitSaved*/ ctx[1];

    			if (dirty & /*$$scope, confirmThis*/ 49152) {
    				pointerzconfirm0_changes.$$scope = { dirty, ctx };
    			}

    			pointerzconfirm0.$set(pointerzconfirm0_changes);

    			if (!current || dirty & /*circuitSaved*/ 2 && !src_url_equal(img1.src, img1_src_value = /*imagesPath*/ ctx[3] + (/*circuitSaved*/ ctx[1] ? "saved.png" : "unsaved.png"))) {
    				attr_dev(img1, "src", img1_src_value);
    			}

    			if (!current || dirty & /*circuitValidated*/ 4 && !src_url_equal(img3.src, img3_src_value = /*imagesPath*/ ctx[3] + (/*circuitValidated*/ ctx[2]
    			? "saved.png"
    			: "unsaved.png"))) {
    				attr_dev(img3, "src", img3_src_value);
    			}

    			const pointerzconfirm1_changes = {};

    			if (dirty & /*circuitSaved, circuitValidated*/ 6) pointerzconfirm1_changes.confirmTitle = /*circuitSaved*/ ctx[1] && /*circuitValidated*/ ctx[2]
    			? "Publish"
    			: "Save and validate";

    			if (dirty & /*$$scope, circuitSaved, circuitValidated, confirmThis*/ 49158) {
    				pointerzconfirm1_changes.$$scope = { dirty, ctx };
    			}

    			pointerzconfirm1.$set(pointerzconfirm1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerzconfirm0.$$.fragment, local);
    			transition_in(pointerzconfirm1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerzconfirm0.$$.fragment, local);
    			transition_out(pointerzconfirm1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			destroy_component(pointerzconfirm0);
    			destroy_component(pointerzconfirm1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let $infoInfo;
    	let $infoError;
    	validate_store(infoInfo, 'infoInfo');
    	component_subscribe($$self, infoInfo, $$value => $$invalidate(10, $infoInfo = $$value));
    	validate_store(infoError, 'infoError');
    	component_subscribe($$self, infoError, $$value => $$invalidate(11, $infoError = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EditorCircuitActionsMenu', slots, []);
    	let imagesPath = "../../../assets/images/editorCircuitActions/";
    	let circuitSaved = true;
    	let circuitValidated = Client$1.editor.editedCircuit.runs.length > 0;

    	let actionFunctions = {
    		save: () => {
    			if (!circuitSaved) {
    				Client$1.socket.saveEditorCircuit(Client$1.editor.editedCircuit);
    				$$invalidate(2, circuitValidated = false);
    			}
    		},
    		startValidationRace: () => {
    			if (Client$1.editor.editedCircuit.isRaceReady()) {
    				circuitSaved ? startRace() : saveAndStartRace();
    			} else {
    				set_store_value(infoError, $infoError = "The circuit must have one starting block and at least one ending block.", $infoError);
    			}
    		},
    		publish: () => {
    			Client$1.socket.publishEditorCircuit(Client$1.editor.editedCircuit);
    		}
    	};

    	let leaveEditor = () => {
    		Client$1.socket.getEditorCircuits();
    		Client$1.editor.delete();
    		Client$1.pushRoute("/editormenu");
    	};

    	let saveAndLeaveEditor = () => {
    		actionFunctions.save();

    		let interval = setInterval(
    			() => {
    				if (circuitSaved) {
    					clearInterval(interval);
    					leaveEditor();
    				}
    			},
    			100
    		);
    	};

    	let startRace = () => {
    		let circuitId = Client$1.editor.editedCircuit._id;
    		Client$1.editor.delete();
    		Client$1.pushRoute("/race");
    		Client$1.socket.emitJoinNewRoom(circuitId, true);
    	};

    	let saveAndStartRace = () => {
    		actionFunctions.save();

    		let interval = setInterval(
    			() => {
    				if (circuitSaved) {
    					clearInterval(interval);
    					startRace();
    				}
    			},
    			100
    		);
    	};

    	Client$1.svelte.showEditorCircuitSavedState = function (dbSavedResult) {
    		if (dbSavedResult.retError) {
    			set_store_value(infoError, $infoError = dbSavedResult.retError, $infoError);
    		} else if (dbSavedResult.retInfo) {
    			Client$1.phaser.editor.setCircuitSavedState(true);
    			set_store_value(infoInfo, $infoInfo = dbSavedResult.retInfo, $infoInfo);
    		}
    	};

    	Client$1.svelte.showEditorCircuitPublishedState = function (dbSavedResult) {
    		dbSavedResult.retError
    		? set_store_value(infoError, $infoError = dbSavedResult.retError, $infoError)
    		: set_store_value(infoInfo, $infoInfo = dbSavedResult.retInfo, $infoInfo);
    	};

    	Client$1.svelte.updateCircuitSavedState = function () {
    		$$invalidate(1, circuitSaved = Client$1.phaser.editor.saved);
    	};

    	Client$1.svelte.updateCircuitValidatedState = function (newState) {
    		$$invalidate(2, circuitValidated = newState);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EditorCircuitActionsMenu> was created with unknown prop '${key}'`);
    	});

    	const click_handler = confirmThis => confirmThis(saveAndLeaveEditor);

    	const func = () => {
    		Client$1.phaser.playSound("cancelClick");
    		leaveEditor();
    	};

    	const click_handler_1 = confirmThis => confirmThis(circuitSaved && circuitValidated
    	? actionFunctions.publish
    	: actionFunctions.raceTest);

    	$$self.$capture_state = () => ({
    		Client: Client$1,
    		infoError,
    		infoInfo,
    		push,
    		PointerzConfirm,
    		imagesPath,
    		circuitSaved,
    		circuitValidated,
    		actionFunctions,
    		leaveEditor,
    		saveAndLeaveEditor,
    		startRace,
    		saveAndStartRace,
    		$infoInfo,
    		$infoError
    	});

    	$$self.$inject_state = $$props => {
    		if ('imagesPath' in $$props) $$invalidate(3, imagesPath = $$props.imagesPath);
    		if ('circuitSaved' in $$props) $$invalidate(1, circuitSaved = $$props.circuitSaved);
    		if ('circuitValidated' in $$props) $$invalidate(2, circuitValidated = $$props.circuitValidated);
    		if ('actionFunctions' in $$props) $$invalidate(4, actionFunctions = $$props.actionFunctions);
    		if ('leaveEditor' in $$props) $$invalidate(5, leaveEditor = $$props.leaveEditor);
    		if ('saveAndLeaveEditor' in $$props) $$invalidate(6, saveAndLeaveEditor = $$props.saveAndLeaveEditor);
    		if ('startRace' in $$props) startRace = $$props.startRace;
    		if ('saveAndStartRace' in $$props) saveAndStartRace = $$props.saveAndStartRace;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		Client$1,
    		circuitSaved,
    		circuitValidated,
    		imagesPath,
    		actionFunctions,
    		leaveEditor,
    		saveAndLeaveEditor,
    		click_handler,
    		func,
    		click_handler_1
    	];
    }

    class EditorCircuitActionsMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EditorCircuitActionsMenu",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    /* src\client\svelte\pages\EditorOverlay.svelte generated by Svelte v3.50.1 */
    const file$2 = "src\\client\\svelte\\pages\\EditorOverlay.svelte";

    // (24:0) {#if loadingEditor}
    function create_if_block$1(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let shadow;
    	let div2_outro;
    	let current;

    	shadow = new Shadow({
    			props: {
    				size: "80",
    				color: "var(--red-color)",
    				unit: "px"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			create_component(shadow.$$.fragment);
    			set_style(div0, "display", "inline-block");
    			add_location(div0, file$2, 26, 6, 954);
    			attr_dev(div1, "class", "centerer svelte-1u1qfsh");
    			add_location(div1, file$2, 25, 4, 924);
    			attr_dev(div2, "class", "background svelte-1u1qfsh");
    			add_location(div2, file$2, 24, 2, 865);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			mount_component(shadow, div0, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(shadow.$$.fragment, local);
    			if (div2_outro) div2_outro.end(1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(shadow.$$.fragment, local);
    			div2_outro = create_out_transition(div2, fade, { duration: 400 });
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(shadow);
    			if (detaching && div2_outro) div2_outro.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(24:0) {#if loadingEditor}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let offlineredirect;
    	let t0;
    	let panelcontainer;
    	let t1;
    	let editorcircuitactionsmenu;
    	let t2;
    	let editorblockbar;
    	let t3;
    	let if_block_anchor;
    	let current;
    	offlineredirect = new OfflineRedirect({ $$inline: true });
    	panelcontainer = new PanelContainer({ $$inline: true });
    	editorcircuitactionsmenu = new EditorCircuitActionsMenu({ $$inline: true });
    	editorblockbar = new EditorBlockbar({ $$inline: true });
    	let if_block = /*loadingEditor*/ ctx[0] && create_if_block$1(ctx);

    	const block = {
    		c: function create() {
    			create_component(offlineredirect.$$.fragment);
    			t0 = space();
    			create_component(panelcontainer.$$.fragment);
    			t1 = space();
    			create_component(editorcircuitactionsmenu.$$.fragment);
    			t2 = space();
    			create_component(editorblockbar.$$.fragment);
    			t3 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(offlineredirect, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(panelcontainer, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(editorcircuitactionsmenu, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(editorblockbar, target, anchor);
    			insert_dev(target, t3, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*loadingEditor*/ ctx[0]) {
    				if (if_block) {
    					if (dirty & /*loadingEditor*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$1(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(offlineredirect.$$.fragment, local);
    			transition_in(panelcontainer.$$.fragment, local);
    			transition_in(editorcircuitactionsmenu.$$.fragment, local);
    			transition_in(editorblockbar.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(offlineredirect.$$.fragment, local);
    			transition_out(panelcontainer.$$.fragment, local);
    			transition_out(editorcircuitactionsmenu.$$.fragment, local);
    			transition_out(editorblockbar.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(offlineredirect, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(panelcontainer, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(editorcircuitactionsmenu, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(editorblockbar, detaching);
    			if (detaching) detach_dev(t3);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EditorOverlay', slots, []);
    	let loadingEditor = true; // The loading circuit animation

    	// Circuit loading animation
    	Client$1.svelte.setEditorLoading = function (val) {
    		$$invalidate(0, loadingEditor = val);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EditorOverlay> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		fade,
    		Shadow,
    		Client: Client$1,
    		PanelContainer,
    		EditorBlockbar,
    		EditorCircuitActionsMenu,
    		OfflineRedirect,
    		loadingEditor
    	});

    	$$self.$inject_state = $$props => {
    		if ('loadingEditor' in $$props) $$invalidate(0, loadingEditor = $$props.loadingEditor);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [loadingEditor];
    }

    class EditorOverlay extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EditorOverlay",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    /* src\client\svelte\pages\CircuitVote.svelte generated by Svelte v3.50.1 */
    const file$1 = "src\\client\\svelte\\pages\\CircuitVote.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (83:10) <TextBlock              clickable              color={selectedCircuitId == circuit._id ? "darkOrange" : "grey"}              on:click={() => selectCircuit(circuit._id)}              slideTransition>
    function create_default_slot_6(ctx) {
    	let t0_value = /*circuit*/ ctx[11].name + "";
    	let t0;
    	let t1;
    	let span;
    	let t2_value = /*circuit*/ ctx[11].upvotes + "";
    	let t2;
    	let t3;
    	let t4;

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = space();
    			span = element("span");
    			t2 = text(t2_value);
    			t3 = text(" 🡅");
    			t4 = space();
    			attr_dev(span, "class", "circuitVotes svelte-150q6z8");
    			add_location(span, file$1, 88, 12, 2845);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, span, anchor);
    			append_dev(span, t2);
    			append_dev(span, t3);
    			insert_dev(target, t4, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$loadedVoteCircuits*/ 2 && t0_value !== (t0_value = /*circuit*/ ctx[11].name + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$loadedVoteCircuits*/ 2 && t2_value !== (t2_value = /*circuit*/ ctx[11].upvotes + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(span);
    			if (detaching) detach_dev(t4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(83:10) <TextBlock              clickable              color={selectedCircuitId == circuit._id ? \\\"darkOrange\\\" : \\\"grey\\\"}              on:click={() => selectCircuit(circuit._id)}              slideTransition>",
    		ctx
    	});

    	return block;
    }

    // (82:8) {#each $loadedVoteCircuits as circuit, i (circuit._id)}
    function create_each_block(key_1, ctx) {
    	let first;
    	let textblock;
    	let current;

    	function click_handler() {
    		return /*click_handler*/ ctx[6](/*circuit*/ ctx[11]);
    	}

    	textblock = new TextBlock({
    			props: {
    				clickable: true,
    				color: /*selectedCircuitId*/ ctx[0] == /*circuit*/ ctx[11]._id
    				? "darkOrange"
    				: "grey",
    				slideTransition: true,
    				$$slots: { default: [create_default_slot_6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	textblock.$on("click", click_handler);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(textblock.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(textblock, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const textblock_changes = {};

    			if (dirty & /*selectedCircuitId, $loadedVoteCircuits*/ 3) textblock_changes.color = /*selectedCircuitId*/ ctx[0] == /*circuit*/ ctx[11]._id
    			? "darkOrange"
    			: "grey";

    			if (dirty & /*$$scope, $loadedVoteCircuits*/ 16386) {
    				textblock_changes.$$scope = { dirty, ctx };
    			}

    			textblock.$set(textblock_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(textblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(82:8) {#each $loadedVoteCircuits as circuit, i (circuit._id)}",
    		ctx
    	});

    	return block;
    }

    // (78:6) <Cell          title="Circuits for vote"          color="orange"          titleImagePath="assets/images/menu/circuit.png">
    function create_default_slot_5(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let current;
    	let each_value = /*$loadedVoteCircuits*/ ctx[1];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*circuit*/ ctx[11]._id;
    	validate_each_keys(ctx, each_value, get_each_context, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*selectedCircuitId, $loadedVoteCircuits, selectCircuit*/ 11) {
    				each_value = /*$loadedVoteCircuits*/ ctx[1];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(78:6) <Cell          title=\\\"Circuits for vote\\\"          color=\\\"orange\\\"          titleImagePath=\\\"assets/images/menu/circuit.png\\\">",
    		ctx
    	});

    	return block;
    }

    // (98:8) {#if selectedCircuitId}
    function create_if_block(ctx) {
    	let div;
    	let pointerzbutton;
    	let t;
    	let current_block_type_index;
    	let if_block;
    	let div_transition;
    	let current;

    	pointerzbutton = new PointerzButton({
    			props: {
    				buttonColor: "darkBlue",
    				important: true,
    				elementsPerRow: "1",
    				imagePath: "assets/images/circuitVote/raceTest.png",
    				animateImage: "false",
    				imageHeight: "16px",
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pointerzbutton.$on("click", /*trySelectedCircuit*/ ctx[4]);
    	const if_block_creators = [create_if_block_1, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*selectedCircuit*/ ctx[2].isUpvotedByUser) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(pointerzbutton.$$.fragment);
    			t = space();
    			if_block.c();
    			set_style(div, "margin-bottom", "16px");
    			add_location(div, file$1, 98, 10, 3092);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(pointerzbutton, div, null);
    			append_dev(div, t);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pointerzbutton_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				pointerzbutton_changes.$$scope = { dirty, ctx };
    			}

    			pointerzbutton.$set(pointerzbutton_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerzbutton.$$.fragment, local);
    			transition_in(if_block);

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {}, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerzbutton.$$.fragment, local);
    			transition_out(if_block);
    			if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {}, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(pointerzbutton);
    			if_blocks[current_block_type_index].d();
    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(98:8) {#if selectedCircuitId}",
    		ctx
    	});

    	return block;
    }

    // (100:12) <PointerzButton                buttonColor="darkBlue"                important                elementsPerRow="1"                imagePath="assets/images/circuitVote/raceTest.png"                animateImage="false"                imageHeight="16px"                on:click={trySelectedCircuit}>
    function create_default_slot_4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Try circuit");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(100:12) <PointerzButton                buttonColor=\\\"darkBlue\\\"                important                elementsPerRow=\\\"1\\\"                imagePath=\\\"assets/images/circuitVote/raceTest.png\\\"                animateImage=\\\"false\\\"                imageHeight=\\\"16px\\\"                on:click={trySelectedCircuit}>",
    		ctx
    	});

    	return block;
    }

    // (121:12) {:else}
    function create_else_block(ctx) {
    	let pointerzbutton;
    	let current;

    	pointerzbutton = new PointerzButton({
    			props: {
    				buttonColor: "darkGreen",
    				important: true,
    				elementsPerRow: "1",
    				imagePath: "assets/images/circuitVote/upvote.png",
    				animateImage: "false",
    				imageHeight: "16px",
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pointerzbutton.$on("click", /*upvoteSelectedCircuit*/ ctx[5]);

    	const block = {
    		c: function create() {
    			create_component(pointerzbutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pointerzbutton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pointerzbutton_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				pointerzbutton_changes.$$scope = { dirty, ctx };
    			}

    			pointerzbutton.$set(pointerzbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerzbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerzbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pointerzbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(121:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (110:12) {#if selectedCircuit.isUpvotedByUser}
    function create_if_block_1(ctx) {
    	let pointerzbutton;
    	let current;

    	pointerzbutton = new PointerzButton({
    			props: {
    				buttonColor: "darkRed",
    				important: true,
    				elementsPerRow: "1",
    				imagePath: "assets/images/circuitVote/downvote.png",
    				animateImage: "false",
    				imageHeight: "16px",
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pointerzbutton.$on("click", /*upvoteSelectedCircuit*/ ctx[5]);

    	const block = {
    		c: function create() {
    			create_component(pointerzbutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pointerzbutton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pointerzbutton_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				pointerzbutton_changes.$$scope = { dirty, ctx };
    			}

    			pointerzbutton.$set(pointerzbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointerzbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointerzbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pointerzbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(110:12) {#if selectedCircuit.isUpvotedByUser}",
    		ctx
    	});

    	return block;
    }

    // (122:14) <PointerzButton                  buttonColor="darkGreen"                  important                  elementsPerRow="1"                  imagePath="assets/images/circuitVote/upvote.png"                  animateImage="false"                  imageHeight="16px"                  on:click={upvoteSelectedCircuit}>
    function create_default_slot_3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Upvote");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(122:14) <PointerzButton                  buttonColor=\\\"darkGreen\\\"                  important                  elementsPerRow=\\\"1\\\"                  imagePath=\\\"assets/images/circuitVote/upvote.png\\\"                  animateImage=\\\"false\\\"                  imageHeight=\\\"16px\\\"                  on:click={upvoteSelectedCircuit}>",
    		ctx
    	});

    	return block;
    }

    // (111:14) <PointerzButton                  buttonColor="darkRed"                  important                  elementsPerRow="1"                  imagePath="assets/images/circuitVote/downvote.png"                  animateImage="false"                  imageHeight="16px"                  on:click={upvoteSelectedCircuit}>
    function create_default_slot_2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Downvote");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(111:14) <PointerzButton                  buttonColor=\\\"darkRed\\\"                  important                  elementsPerRow=\\\"1\\\"                  imagePath=\\\"assets/images/circuitVote/downvote.png\\\"                  animateImage=\\\"false\\\"                  imageHeight=\\\"16px\\\"                  on:click={upvoteSelectedCircuit}>",
    		ctx
    	});

    	return block;
    }

    // (97:6) <Cell>
    function create_default_slot_1(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*selectedCircuitId*/ ctx[0] && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*selectedCircuitId*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*selectedCircuitId*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(97:6) <Cell>",
    		ctx
    	});

    	return block;
    }

    // (70:0) <AppLayout>
    function create_default_slot(ctx) {
    	let offlineredirect;
    	let t0;
    	let div2;
    	let backbutton;
    	let t1;
    	let div0;
    	let cell0;
    	let t2;
    	let div1;
    	let cell1;
    	let div2_intro;
    	let div2_outro;
    	let current;
    	offlineredirect = new OfflineRedirect({ $$inline: true });

    	backbutton = new BackButton({
    			props: { backHref: "/privatemenu" },
    			$$inline: true
    		});

    	cell0 = new Cell({
    			props: {
    				title: "Circuits for vote",
    				color: "orange",
    				titleImagePath: "assets/images/menu/circuit.png",
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	cell1 = new Cell({
    			props: {
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(offlineredirect.$$.fragment);
    			t0 = space();
    			div2 = element("div");
    			create_component(backbutton.$$.fragment);
    			t1 = space();
    			div0 = element("div");
    			create_component(cell0.$$.fragment);
    			t2 = space();
    			div1 = element("div");
    			create_component(cell1.$$.fragment);
    			attr_dev(div0, "class", "circuitsContainer svelte-150q6z8");
    			add_location(div0, file$1, 76, 4, 2367);
    			attr_dev(div1, "class", "actionsContainer svelte-150q6z8");
    			add_location(div1, file$1, 95, 4, 3003);
    			attr_dev(div2, "id", "menuContainer");
    			attr_dev(div2, "class", "svelte-150q6z8");
    			add_location(div2, file$1, 71, 2, 2210);
    		},
    		m: function mount(target, anchor) {
    			mount_component(offlineredirect, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div2, anchor);
    			mount_component(backbutton, div2, null);
    			append_dev(div2, t1);
    			append_dev(div2, div0);
    			mount_component(cell0, div0, null);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			mount_component(cell1, div1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const cell0_changes = {};

    			if (dirty & /*$$scope, $loadedVoteCircuits, selectedCircuitId*/ 16387) {
    				cell0_changes.$$scope = { dirty, ctx };
    			}

    			cell0.$set(cell0_changes);
    			const cell1_changes = {};

    			if (dirty & /*$$scope, selectedCircuit, selectedCircuitId*/ 16389) {
    				cell1_changes.$$scope = { dirty, ctx };
    			}

    			cell1.$set(cell1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(offlineredirect.$$.fragment, local);
    			transition_in(backbutton.$$.fragment, local);
    			transition_in(cell0.$$.fragment, local);
    			transition_in(cell1.$$.fragment, local);

    			add_render_callback(() => {
    				if (div2_outro) div2_outro.end(1);
    				div2_intro = create_in_transition(div2, fly, { delay: 400, duration: 400 });
    				div2_intro.start();
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(offlineredirect.$$.fragment, local);
    			transition_out(backbutton.$$.fragment, local);
    			transition_out(cell0.$$.fragment, local);
    			transition_out(cell1.$$.fragment, local);
    			if (div2_intro) div2_intro.invalidate();
    			div2_outro = create_out_transition(div2, fade, { duration: 400 });
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(offlineredirect, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div2);
    			destroy_component(backbutton);
    			destroy_component(cell0);
    			destroy_component(cell1);
    			if (detaching && div2_outro) div2_outro.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(70:0) <AppLayout>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let applayout;
    	let current;

    	applayout = new AppLayout({
    			props: {
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(applayout.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(applayout, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const applayout_changes = {};

    			if (dirty & /*$$scope, selectedCircuit, selectedCircuitId, $loadedVoteCircuits*/ 16391) {
    				applayout_changes.$$scope = { dirty, ctx };
    			}

    			applayout.$set(applayout_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(applayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(applayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(applayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let selectedCircuit;
    	let $passedData;
    	let $infoError;
    	let $userModel;
    	let $loadedVoteCircuits;
    	validate_store(passedData, 'passedData');
    	component_subscribe($$self, passedData, $$value => $$invalidate(8, $passedData = $$value));
    	validate_store(infoError, 'infoError');
    	component_subscribe($$self, infoError, $$value => $$invalidate(9, $infoError = $$value));
    	validate_store(userModel, 'userModel');
    	component_subscribe($$self, userModel, $$value => $$invalidate(10, $userModel = $$value));
    	validate_store(loadedVoteCircuits, 'loadedVoteCircuits');
    	component_subscribe($$self, loadedVoteCircuits, $$value => $$invalidate(1, $loadedVoteCircuits = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CircuitVote', slots, []);
    	let selectedCircuitId;

    	function selectCircuit(id) {
    		Client$1.phaser.playSound("buttonSelection");
    		$$invalidate(0, selectedCircuitId = id);
    	}

    	function trySelectedCircuit() {
    		Client$1.pushRoute("/race");
    		Client$1.socket.emitJoinNewRoom(selectedCircuitId, false, true);
    	}

    	function upvoteSelectedCircuit() {
    		Client$1.socket.emitUpvoteCircuit(selectedCircuitId);
    	}

    	Client$1.svelte.updateLoadedVoteCircuits = function (voteCircuits) {
    		if (!voteCircuits) {
    			return;
    		}

    		set_store_value(
    			loadedVoteCircuits,
    			$loadedVoteCircuits = voteCircuits.sort((a, b) => {
    				let upvoteDiff = b.upvotes - a.upvotes;

    				return upvoteDiff == 0
    				? b.creationDate - a.creationDate
    				: upvoteDiff;
    			}),
    			$loadedVoteCircuits
    		);

    		$loadedVoteCircuits.forEach(voteCircuit => {
    			let userVotedForThisCircuit = $userModel.circuitVotes.findIndex(vote => vote.toString() == voteCircuit._id.toString()) >= 0;
    			voteCircuit.isUpvotedByUser = userVotedForThisCircuit;
    		});
    	};

    	Client$1.svelte.handleUpvoteResult = function (data) {
    		if (data.retError) {
    			set_store_value(infoError, $infoError = data.retError, $infoError);
    		} else {
    			$$invalidate(2, selectedCircuit.upvotes = data.newCircuitModel.upvotes, selectedCircuit);
    			(($$invalidate(2, selectedCircuit), $$invalidate(1, $loadedVoteCircuits)), $$invalidate(0, selectedCircuitId));
    			$$invalidate(2, selectedCircuit.isUpvotedByUser = data.isUpvoted, selectedCircuit);
    		}
    	};

    	Client$1.svelte.updateLoadedVoteCircuits($passedData.voteCircuits);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CircuitVote> was created with unknown prop '${key}'`);
    	});

    	const click_handler = circuit => selectCircuit(circuit._id);

    	$$self.$capture_state = () => ({
    		fly,
    		fade,
    		slide,
    		push,
    		Client: Client$1,
    		loadedVoteCircuits,
    		passedData,
    		infoError,
    		infoInfo,
    		userModel,
    		OfflineRedirect,
    		PointerzButton,
    		AppLayout,
    		Cell,
    		TextBlock,
    		BackButton,
    		selectedCircuitId,
    		selectCircuit,
    		trySelectedCircuit,
    		upvoteSelectedCircuit,
    		selectedCircuit,
    		$passedData,
    		$infoError,
    		$userModel,
    		$loadedVoteCircuits
    	});

    	$$self.$inject_state = $$props => {
    		if ('selectedCircuitId' in $$props) $$invalidate(0, selectedCircuitId = $$props.selectedCircuitId);
    		if ('selectedCircuit' in $$props) $$invalidate(2, selectedCircuit = $$props.selectedCircuit);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$loadedVoteCircuits, selectedCircuitId*/ 3) {
    			$$invalidate(2, selectedCircuit = $loadedVoteCircuits.find(circuit => circuit._id == selectedCircuitId));
    		}
    	};

    	return [
    		selectedCircuitId,
    		$loadedVoteCircuits,
    		selectedCircuit,
    		selectCircuit,
    		trySelectedCircuit,
    		upvoteSelectedCircuit,
    		click_handler
    	];
    }

    class CircuitVote extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CircuitVote",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    const routes = {
      "/": PublicMenu,
      "/privatemenu": PrivateMenu,
      "/campaignmenu": CampaignMenu,
      "/race": RaceOverlay,
      "/editormenu": EditorMenu,
      "/editor": EditorOverlay,
      "/circuitvote": CircuitVote,
    };

    function playTheRightSoundtrack(route) {
      // Play the right soundtrack for the route
      if (
        route == "/privatemenu" ||
        route == "/campaignmenu" ||
        route == "/editormenu" ||
        route == "/circuitvote"
      ) {
        Client.phaser.playMainSoundtrack();
        Client.phaser.stopEngineSound();
        Client.phaser.stopSpaceshipThrustSound();
      } else if (route == "/race" || route == "/editor") {
        Client.phaser.playRandomSoundtrack();
        Client.phaser.stopEngineSound();
        Client.phaser.stopSpaceshipThrustSound();
      }
    }

    function pushRoute(route) {
      playTheRightSoundtrack(route);
      push(route);
    }

    // The soundtrack management should also work if the user navigates back using the browser's back button
    window.addEventListener("popstate", () => {
      // The new route is everything after the # in the URL, and / if there is no #
      let newRoute = location.hash.slice(1) || "/";
      playTheRightSoundtrack(newRoute);
    });

    /* src\client\svelte\App.svelte generated by Svelte v3.50.1 */

    const { console: console_1 } = globals;
    const file = "src\\client\\svelte\\App.svelte";

    function create_fragment(ctx) {
    	let router;
    	let t0;
    	let div;
    	let closabledislay0;
    	let updating_displayedText;
    	let t1;
    	let closabledislay1;
    	let updating_displayedText_1;
    	let current;
    	router = new Router({ props: { routes }, $$inline: true });

    	function closabledislay0_displayedText_binding(value) {
    		/*closabledislay0_displayedText_binding*/ ctx[2](value);
    	}

    	let closabledislay0_props = {
    		color: "red",
    		sound: "error",
    		imagePath: "assets/images/connection/error.png"
    	};

    	if (/*$infoError*/ ctx[0] !== void 0) {
    		closabledislay0_props.displayedText = /*$infoError*/ ctx[0];
    	}

    	closabledislay0 = new ClosableDisplay({
    			props: closabledislay0_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(closabledislay0, 'displayedText', closabledislay0_displayedText_binding));

    	function closabledislay1_displayedText_binding(value) {
    		/*closabledislay1_displayedText_binding*/ ctx[3](value);
    	}

    	let closabledislay1_props = {
    		color: "green",
    		sound: "info",
    		imagePath: "assets/images/connection/info.png"
    	};

    	if (/*$infoInfo*/ ctx[1] !== void 0) {
    		closabledislay1_props.displayedText = /*$infoInfo*/ ctx[1];
    	}

    	closabledislay1 = new ClosableDisplay({
    			props: closabledislay1_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(closabledislay1, 'displayedText', closabledislay1_displayedText_binding));

    	const block = {
    		c: function create() {
    			create_component(router.$$.fragment);
    			t0 = space();
    			div = element("div");
    			create_component(closabledislay0.$$.fragment);
    			t1 = space();
    			create_component(closabledislay1.$$.fragment);
    			attr_dev(div, "class", "notifications-container svelte-ophuo7");
    			add_location(div, file, 35, 0, 970);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(router, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(closabledislay0, div, null);
    			append_dev(div, t1);
    			mount_component(closabledislay1, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const closabledislay0_changes = {};

    			if (!updating_displayedText && dirty & /*$infoError*/ 1) {
    				updating_displayedText = true;
    				closabledislay0_changes.displayedText = /*$infoError*/ ctx[0];
    				add_flush_callback(() => updating_displayedText = false);
    			}

    			closabledislay0.$set(closabledislay0_changes);
    			const closabledislay1_changes = {};

    			if (!updating_displayedText_1 && dirty & /*$infoInfo*/ 2) {
    				updating_displayedText_1 = true;
    				closabledislay1_changes.displayedText = /*$infoInfo*/ ctx[1];
    				add_flush_callback(() => updating_displayedText_1 = false);
    			}

    			closabledislay1.$set(closabledislay1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(router.$$.fragment, local);
    			transition_in(closabledislay0.$$.fragment, local);
    			transition_in(closabledislay1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(router.$$.fragment, local);
    			transition_out(closabledislay0.$$.fragment, local);
    			transition_out(closabledislay1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(router, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			destroy_component(closabledislay0);
    			destroy_component(closabledislay1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let $userModel;
    	let $infoError;
    	let $infoInfo;
    	validate_store(userModel, 'userModel');
    	component_subscribe($$self, userModel, $$value => $$invalidate(5, $userModel = $$value));
    	validate_store(infoError, 'infoError');
    	component_subscribe($$self, infoError, $$value => $$invalidate(0, $infoError = $$value));
    	validate_store(infoInfo, 'infoInfo');
    	component_subscribe($$self, infoInfo, $$value => $$invalidate(1, $infoInfo = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);

    	Client$1.svelte.showError = function (error) {
    		set_store_value(infoError, $infoError = error, $infoError);
    	};

    	Client$1.svelte.showInfo = function (info) {
    		set_store_value(infoInfo, $infoInfo = info, $infoInfo);
    	};

    	Client$1.svelte.updateUserModel = function (newUserModel) {
    		set_store_value(userModel, $userModel = newUserModel, $userModel);
    		console.log($userModel.nfts.filter(nft => nft.nftSelected));
    		Client$1.phaser.updateVisualiserNFTs && Client$1.phaser.updateVisualiserNFTs($userModel.nfts.filter(nft => nft.nftSelected));
    		let ret = Client$1.unlockCryptoAccount($userModel);

    		if (ret && ret.retError) {
    			set_store_value(infoError, $infoError = retError, $infoError);
    		}
    	};

    	Client$1.svelte.getUserModel = function () {
    		return $userModel;
    	};

    	Client$1.pushRoute = pushRoute;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	function closabledislay0_displayedText_binding(value) {
    		$infoError = value;
    		infoError.set($infoError);
    	}

    	function closabledislay1_displayedText_binding(value) {
    		$infoInfo = value;
    		infoInfo.set($infoInfo);
    	}

    	$$self.$capture_state = () => ({
    		Router,
    		routes,
    		pushRoute,
    		infoInfo,
    		infoError,
    		Client: Client$1,
    		userModel,
    		ClosableDislay: ClosableDisplay,
    		$userModel,
    		$infoError,
    		$infoInfo
    	});

    	return [
    		$infoError,
    		$infoInfo,
    		closabledislay0_displayedText_binding,
    		closabledislay1_displayedText_binding
    	];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App({
      target: document.body,
      props: {},
    });

    return app;

})();
//# sourceMappingURL=svelte_bundle.js.map
